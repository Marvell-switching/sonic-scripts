diff --git a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
index 68670343b..13e7fb9c1 100644
--- a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -15,7 +15,7 @@ RUN apt-get purge -y syncd
 RUN apt-get update \
  && apt-get -y install  \
     net-tools           \
-    python-pip          \
+    python3-pip          \
     build-essential     \
     libssl-dev          \
     libffi-dev          \
@@ -24,7 +24,7 @@ RUN apt-get update \
     cmake               \
     libqt5core5a        \
     libqt5network5      \
-    libboost-atomic1.71.0
+    libboost-atomic1.74.0
 
 RUN dpkg_apt() { [ -f $1 ] && { dpkg -i $1 || apt-get -y install -f; } || return 1; } ; \
 {% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
@@ -41,9 +41,9 @@ RUN wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && cd ..               \
  && rm -fr nanomsg-1.0.0 \
  && rm -f 1.0.0.tar.gz  \
- && pip install cffi==1.7.0    \
- && pip install --upgrade cffi==1.7.0 \
- && pip install nnpy    \
+ && pip2 install cffi==1.7.0    \
+ && pip2 install --upgrade cffi==1.7.0 \
+ && pip2 install nnpy    \
  && mkdir -p /opt       \
  && cd /opt             \
  && wget https://raw.githubusercontent.com/p4lang/ptf/master/ptf_nn/ptf_nn_agent.py \
diff --git a/platform/marvell/docker-syncd-mrvl.mk b/platform/marvell/docker-syncd-mrvl.mk
index d8a205090..bfd2bbd22 100644
--- a/platform/marvell/docker-syncd-mrvl.mk
+++ b/platform/marvell/docker-syncd-mrvl.mk
@@ -1,7 +1,7 @@
 # docker image for mrvl syncd
 
 DOCKER_SYNCD_PLATFORM_CODE = mrvl
-include $(PLATFORM_PATH)/../template/docker-syncd-base.mk
+include $(PLATFORM_PATH)/../template/docker-syncd-bullseye.mk
 
 $(DOCKER_SYNCD_BASE)_DEPENDS += $(SYNCD)
 
diff --git a/platform/marvell/docker-syncd-mrvl/Dockerfile.j2 b/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
index cb2f7eadb..a8b91dbcd 100755
--- a/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
+++ b/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
@@ -1,5 +1,5 @@
 {% from "dockers/dockerfile-macros.j2" import install_debian_packages %}
-FROM docker-config-engine-buster-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
+FROM docker-config-engine-bullseye-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
 
 ARG docker_container_name
 
diff --git a/platform/marvell/linux-modules.mk b/platform/marvell/linux-modules.mk
new file mode 100644
index 000000000..001200143
--- /dev/null
+++ b/platform/marvell/linux-modules.mk
@@ -0,0 +1,6 @@
+# linux kernel package for marvell modules
+
+# Add platform specific MOD
+LINUX_KERNEL_MOD = linux-module-5.10.0-18-amd64.deb
+$(LINUX_KERNEL_MOD)_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/amd64/kernel/$(LINUX_KERNEL_MOD)
+SONIC_ONLINE_DEBS += $(LINUX_KERNEL_MOD)
diff --git a/platform/marvell/one-image.mk b/platform/marvell/one-image.mk
index fcac03854..5a4e84d20 100644
--- a/platform/marvell/one-image.mk
+++ b/platform/marvell/one-image.mk
@@ -4,6 +4,10 @@ SONIC_ONE_IMAGE = sonic-marvell.bin
 $(SONIC_ONE_IMAGE)_MACHINE = marvell
 $(SONIC_ONE_IMAGE)_IMAGE_TYPE = onie
 $(SONIC_ONE_IMAGE)_INSTALLS += $(SYSTEMD_SONIC_GENERATOR)
+$(SONIC_ONE_IMAGE)_INSTALLS += $(LINUX_KERNEL_MOD)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8540_16CD_PLATFORM)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8580_32CD_PLATFORM)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8514_10CC_PLATFORM)
 ifeq ($(INSTALL_DEBUG_TOOLS),y)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
diff --git a/platform/marvell/platform-db98cx8514-10cc.mk b/platform/marvell/platform-db98cx8514-10cc.mk
new file mode 100644
index 000000000..4a1435f28
--- /dev/null
+++ b/platform/marvell/platform-db98cx8514-10cc.mk
@@ -0,0 +1,12 @@
+# FALCON Platform 
+
+FALCON_VERSION = 1.0
+export FALCON_VERSION
+
+FALCON_DB98CX8514_10CC_PLATFORM = sonic-platform-db98cx8514-10cc-db98cx8514_$(FALCON_VERSION)_$(CONFIGURED_ARCH).deb
+$(FALCON_DB98CX8514_10CC_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-db98cx8514-10cc
+$(FALCON_DB98CX8514_10CC_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(FALCON_DB98CX8514_10CC_PLATFORM)_PLATFORM = x86_64-marvell_db98cx8514_10cc-r0 
+
+SONIC_DPKG_DEBS += $(FALCON_DB98CX8514_10CC_PLATFORM)
+
diff --git a/platform/marvell/platform-db98cx8540-16cd.mk b/platform/marvell/platform-db98cx8540-16cd.mk
new file mode 100644
index 000000000..a60d662a1
--- /dev/null
+++ b/platform/marvell/platform-db98cx8540-16cd.mk
@@ -0,0 +1,12 @@
+# FALCON Platform 
+
+FALCON_VERSION = 1.0
+export FALCON_VERSION
+
+FALCON_DB98CX8540_16CD_PLATFORM = sonic-platform-db98cx8540-16cd-db98cx8540_$(FALCON_VERSION)_$(CONFIGURED_ARCH).deb
+$(FALCON_DB98CX8540_16CD_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-db98cx8540-16cd
+$(FALCON_DB98CX8540_16CD_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(FALCON_DB98CX8540_16CD_PLATFORM)_PLATFORM = x86_64-marvell_db98cx8540_16cd-r0 
+
+SONIC_DPKG_DEBS += $(FALCON_DB98CX8540_16CD_PLATFORM)
+
diff --git a/platform/marvell/platform-db98cx8580-32cd.mk b/platform/marvell/platform-db98cx8580-32cd.mk
new file mode 100644
index 000000000..f1f9210e7
--- /dev/null
+++ b/platform/marvell/platform-db98cx8580-32cd.mk
@@ -0,0 +1,12 @@
+# FALCON Platform 
+
+FALCON_VERSION = 1.0
+export FALCON_VERSION
+
+FALCON_DB98CX8580_32CD_PLATFORM = sonic-platform-db98cx8580-32cd-db98cx8580_$(FALCON_VERSION)_$(CONFIGURED_ARCH).deb
+$(FALCON_DB98CX8580_32CD_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-db98cx8580-32cd
+$(FALCON_DB98CX8580_32CD_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(FALCON_DB98CX8580_32CD_PLATFORM)_PLATFORM = x86_64-marvell_db98cx8580_32cd-r0 
+
+SONIC_DPKG_DEBS += $(FALCON_DB98CX8580_32CD_PLATFORM)
+
diff --git a/platform/marvell/rules.mk b/platform/marvell/rules.mk
index da23e53f2..6bf0ade47 100644
--- a/platform/marvell/rules.mk
+++ b/platform/marvell/rules.mk
@@ -3,6 +3,10 @@ include $(PLATFORM_PATH)/docker-syncd-mrvl.mk
 include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk
 include $(PLATFORM_PATH)/libsaithrift-dev.mk
 include $(PLATFORM_PATH)/one-image.mk
+include $(PLATFORM_PATH)/linux-modules.mk
+include $(PLATFORM_PATH)/platform-db98cx8540-16cd.mk
+include $(PLATFORM_PATH)/platform-db98cx8580-32cd.mk
+include $(PLATFORM_PATH)/platform-db98cx8514-10cc.mk
 
 SONIC_ALL += $(SONIC_ONE_IMAGE) \
              $(DOCKER_FPM) \
diff --git a/platform/marvell/sai.mk b/platform/marvell/sai.mk
index 602f92296..f6372ca68 100644
--- a/platform/marvell/sai.mk
+++ b/platform/marvell/sai.mk
@@ -1,7 +1,7 @@
 # Marvell SAI
 
-export MRVL_SAI_VERSION = 1.8.1-1
-export MRVL_SAI = mrvllibsai_amd64_$(MRVL_SAI_VERSION).deb
+export MRVL_SAI_VERSION = 1.11.0-1
+export MRVL_SAI = mrvllibsai_$(MRVL_SAI_VERSION)_$(PLATFORM_ARCH).deb
 
 $(MRVL_SAI)_SRC_PATH = $(PLATFORM_PATH)/sai
 $(eval $(call add_conflict_package,$(MRVL_SAI),$(LIBSAIVS_DEV)))
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/scripts/db98cx8514-10cc-init.sh b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/scripts/db98cx8514-10cc-init.sh
new file mode 100644
index 000000000..4b97289e8
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/scripts/db98cx8514-10cc-init.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+# Platform init script for db98cx8514-10cc 
+
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-2/new_device
+
+exit 0
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/service/db98cx8514-10cc-init.service b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/service/db98cx8514-10cc-init.service
new file mode 100644
index 000000000..a8642ba32
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/service/db98cx8514-10cc-init.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Platform db98cx8514-10cc Service
+Before=pmon.service
+After=sysinit.target
+DefaultDependencies=no
+
+[Service]
+ExecStart=/usr/local/bin/db98cx8514-10cc-init.sh
+KillSignal=SIGKILL
+SuccessExitStatus=SIGKILL
+#StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/setup.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/setup.py
new file mode 100644
index 000000000..716624b63
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'db98cx8514/sonic_platform'},
+)
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/__init__.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/__init__.py
new file mode 100644
index 000000000..dd96fc4bb
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis","sfp_event"]
+from sonic_platform import *
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/chassis.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/chassis.py
new file mode 100644
index 000000000..ee9770bbd
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/chassis.py
@@ -0,0 +1,307 @@
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+MAX_COMPONENT=2
+MAX_SELECT_DELAY = 3600
+SFP_PORT_START = 1
+SFP_PORT_END = 48
+QSFP_PORT_START=49
+QSFP_PORT_END=80
+PORT_END = 80
+
+# profile  port_num:<port_select_val, device_register, port_status_bit>
+profile_2T80x25G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"48,0x17,0",  50:"48,0x17,0",  51:"48,0x17,0",  52:"49,0x17,1",  53:"49,0x17,1",  54:"49,0x17,1",  55:"49,0x17,1",
+ 56:"50,0x17,2",  57:"50,0x17,2",  58:"50,0x17,2",  59:"50,0x17,2",  60:"51,0x17,3",  61:"51,0x17,3",  62:"51,0x17,3",  63:"51,0x17,3",
+ 64:"52,0x17,4",  65:"52,0x17,4",  66:"52,0x17,4",  67:"52,0x17,4",  68:"53,0x17,5",  69:"53,0x17,5",  70:"53,0x17,5",  71:"53,0x17,5",
+ 72:"54,0x17,6",  73:"54,0x17,6",  74:"54,0x17,6",  75:"54,0x17,6",  76:"55,0x17,7",  77:"55,0x17,7",  78:"55,0x17,7",  79:"55,0x17,7",
+}
+
+profile_2T48x10G_8x100G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"49,0x17,1",  50:"49,0x17,2",  51:"51,0x17,3",  52:"52,0x17,4",  53:"53,0x17,5",  54:"54,0x17,6",  55:"55,0x17,7",
+}
+
+sfputil_profiles = {
+"F2T80x25G":profile_2T80x25G,
+"F2T48x25G8x100G":profile_2T48x10G_8x100G,
+"F2T48x10G8x100G":profile_2T48x10G_8x100G
+}
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for db98cx8514_10cc platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    HWSKU = "db98cx8514_10cc"
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        timeout=0
+        # Port numbers for SFP List Initialization
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.QSFP_PORT_START = QSFP_PORT_START
+        self.QSFP_PORT_END = QSFP_PORT_END
+        self.PORT_END = PORT_END
+
+        sai_profile_path=self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+        #Adding SFP port to sfp list
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 2
+            port=index-1
+            profile = sfputil_profiles[self._port_profile]
+            if port in profile:
+                eeprom_path = '/sys/bus/i2c/devices/2-0050/eeprom'
+                if not os.path.exists(eeprom_path):
+                       sonic_logger.log_info(" DEBUG - path %s -- did not exist " % eeprom_path )
+                sfp_node = Sfp(index, 'SFP', eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+        #Adding QSFP port to sfp list
+        for index in range(self.QSFP_PORT_START, self.QSFP_PORT_END+1):
+            i2cdev = 2
+            port=index-1
+            profile = sfputil_profiles[self._port_profile]
+            if port in profile:
+                sfp_node = Sfp(index, 'QSFP', eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+
+        self.sfp_event_initialized = False
+        self._eeprom = Eeprom()
+        for i in range(MAX_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+
+    def __get_path_to_sai_profile_file(self):
+        """
+        Retrieve sai.profile path
+        Returns:
+            get_path_to_platform_dir(): get platform path depend on, whether we're running on container or on the host
+            Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        #lrr = self._get_cpld_register('mb_reboot_cause')
+        #if (lrr != 'ERR'):
+        #    reset_reason = lrr
+        #    if (reset_reason in self.reset_reason_dict):
+        #        return (self.reset_reason_dict[reset_reason], None)
+        #
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/component.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/component.py
new file mode 100644
index 000000000..8856d0894
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/component.py
@@ -0,0 +1,89 @@
+########################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["BIOS", "BIOS - Basic Input/Output System"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+        if self.index == 0:
+            cmdstatus, bios_version = cmd.getstatusoutput('dmidecode -s bios-version')
+            return bios_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/eeprom.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/eeprom.py
new file mode 100644
index 000000000..cbf859f0d
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/eeprom.py
@@ -0,0 +1,227 @@
+########################################################################
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# System EEPROM : Contains Serial number, Service tag, Base MA
+#                 address, etc. in ONIE TlvInfo EEPROM format.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = "/etc/sonic/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 6
+                self.eeprom_path = self.I2C_DIR \
+                   + "i2c-3{0}/3{0}-0056/eeprom".format(self.index - 1)
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(2 - self.index)
+                self.format = psu_eeprom_format
+            else:
+                self.index = fan_index
+                self.start_offset = 13
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-4{0}/4{0}-0050/eeprom".format(self.index - 1)
+                self.format = fan_eeprom_format
+            EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                   self.start_offset, '', True)
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and retrieves the serial number and
+        model number of the device.
+        """
+        try:
+            # Read Fan/PSU EEPROM as per the specified format.
+            self.eeprom_data = EepromDecoder.read_eeprom(self)
+        except Exception as e:
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+        else:
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data
+            else:
+                self.model_str = 'NA'
+
+            (valid, data) = self._get_eeprom_field("Serial Number")
+            if valid:
+                self.serial_number = data
+            else:
+                self.serial_number = 'NA'
+
+            if self.is_psu_eeprom:
+                (valid, data) = self._get_eeprom_field("PSU Type")
+                if valid:
+                    self.psu_type = data
+                else:
+                    self.psu_type = 'NA'
+            else:
+                (valid, data) = self._get_eeprom_field("Fan Type")
+                if valid:
+                    self.fan_type = data
+                else:
+                    self.fan_type = 'NA'
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/pcie.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/pcie.py
new file mode 100644
index 000000000..c1b7289a3
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/pcie.py
@@ -0,0 +1,47 @@
+########################################################################
+# Copyright (C) 2021, mrvl CORPORATION & AFFILIATES. All rights reserved.
+# Module contains a platform specific implementation of SONiC Platform
+# Base PCIe class
+########################################################################
+import os
+import re
+
+try:
+    from sonic_platform_base.sonic_pcie.pcie_common import PcieUtil
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+SYSFS_PCI_DEVICE_PATH = '/sys/bus/pci/devices/'
+
+class Pcie(PcieUtil):
+    def get_pcie_check(self):
+        self.load_config_file()
+        for item_conf in self.confInfo:
+            id_conf = item_conf["id"]
+            dev_conf = item_conf["dev"]
+            fn_conf = item_conf["fn"]
+            bus_conf = self._device_id_to_bus_map.get(str(id_conf))
+            if bus_conf and self.check_pcie_sysfs(bus=int(bus_conf, base=16), device=int(dev_conf, base=16),
+                                                  func=int(fn_conf, base=16)):
+                item_conf["result"] = "Passed"
+            else:
+                item_conf["result"] = "Failed"
+        return self.confInfo
+
+    def _create_device_id_to_bus_map(self):
+        self._device_id_to_bus_map = {}
+        self.load_config_file()
+        device_folders = os.listdir(SYSFS_PCI_DEVICE_PATH)
+        for folder in device_folders:
+            pattern_for_device_folder = re.search('....:(..):..\..', folder)
+            if pattern_for_device_folder:
+                bus = pattern_for_device_folder.group(1)
+                with open(os.path.join('/sys/bus/pci/devices', folder, 'device'), 'r') as device_file:
+                    # The 'device' file contain an hex repesantaion of the id key in the yaml file.
+                    # We will strip the new line character, and remove the 0x prefix that is not needed.
+                    device_id = device_file.read().strip().replace('0x', '')
+                    self._device_id_to_bus_map[device_id] = bus
+
+    def __init__(self, platform_path):
+        PcieUtil.__init__(self, platform_path)
+        self._create_device_id_to_bus_map()
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/platform.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/platform.py
new file mode 100644
index 000000000..73d3cfc11
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/platform.py
@@ -0,0 +1,18 @@
+#############################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp.py
new file mode 100644
index 000000000..c7149ca39
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp.py
@@ -0,0 +1,1404 @@
+import os
+import sys
+import time
+from ctypes import create_string_buffer
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom
+    from sonic_platform_base.sonic_sfp.inf8628 import inf8628InterfaceId
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+if sys.version_info[0] < 3:
+        import commands as command
+else:
+        import subprocess as command
+
+# prfile  port_num:<port_mux_value,device_register,port_present_bit>
+profile_2T80x25G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"48,0x17,0",  50:"48,0x17,0",  51:"48,0x17,0",  52:"49,0x17,1",  53:"49,0x17,1",  54:"49,0x17,1",  55:"49,0x17,1",
+ 56:"50,0x17,2",  57:"50,0x17,2",  58:"50,0x17,2",  59:"50,0x17,2",  60:"51,0x17,3",  61:"51,0x17,3",  62:"51,0x17,3",  63:"51,0x17,3",
+ 64:"52,0x17,4",  65:"52,0x17,4",  66:"52,0x17,4",  67:"52,0x17,4",  68:"53,0x17,5",  69:"53,0x17,5",  70:"53,0x17,5",  71:"53,0x17,5",
+ 72:"54,0x17,6",  73:"54,0x17,6",  74:"54,0x17,6",  75:"54,0x17,6",  76:"55,0x17,7",  77:"55,0x17,7",  78:"55,0x17,7",  79:"55,0x17,7",
+}
+
+profile_2T48x10G_8x100G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"49,0x17,1",  50:"50,0x17,2",  51:"51,0x17,3",  52:"52,0x17,4",  53:"53,0x17,5",  54:"54,0x17,6",  55:"55,0x17,7",
+}
+
+sfputil_profiles = {
+"F2T80x25G":profile_2T80x25G,
+"F2T48x25G8x100G":profile_2T48x10G_8x100G,
+"F2T48x10G8x100G":profile_2T48x10G_8x100G
+}
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+XCVR_INTFACE_BULK_WIDTH_QSFP = 20
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+XCVR_CABLE_LENGTH_WIDTH_QSFP = 5
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+XCVR_HW_REV_WIDTH_OSFP = 2
+XCVR_HW_REV_WIDTH_QSFP = 2
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+QSFP_DOM_BULK_DATA_START = 22
+QSFP_DOM_BULK_DATA_SIZE = 36
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+# definitions of the offset for values in OSFP info eeprom
+OSFP_TYPE_OFFSET = 0
+OSFP_VENDOR_NAME_OFFSET = 129
+OSFP_VENDOR_PN_OFFSET = 148
+OSFP_HW_REV_OFFSET = 164
+OSFP_VENDOR_SN_OFFSET = 166
+
+# Offset for values in QSFP eeprom
+QSFP_DOM_REV_OFFSET = 1
+QSFP_DOM_REV_WIDTH = 1
+QSFP_TEMPE_OFFSET = 22
+QSFP_TEMPE_WIDTH = 2
+QSFP_VOLT_OFFSET = 26
+QSFP_VOLT_WIDTH = 2
+QSFP_VERSION_COMPLIANCE_OFFSET = 1
+QSFP_VERSION_COMPLIANCE_WIDTH = 2
+QSFP_CHANNL_MON_OFFSET = 34
+QSFP_CHANNL_MON_WIDTH = 16
+QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH = 24
+QSFP_CHANNL_DISABLE_STATUS_OFFSET = 86
+QSFP_CHANNL_DISABLE_STATUS_WIDTH = 1
+QSFP_CHANNL_RX_LOS_STATUS_OFFSET = 3
+QSFP_CHANNL_RX_LOS_STATUS_WIDTH = 1
+QSFP_CHANNL_TX_FAULT_STATUS_OFFSET = 4
+QSFP_CHANNL_TX_FAULT_STATUS_WIDTH = 1
+QSFP_CONTROL_OFFSET = 86
+QSFP_CONTROL_WIDTH = 8
+QSFP_MODULE_MONITOR_OFFSET = 0
+QSFP_MODULE_MONITOR_WIDTH = 9
+QSFP_POWEROVERRIDE_OFFSET = 93
+QSFP_POWEROVERRIDE_WIDTH = 1
+QSFP_POWEROVERRIDE_BIT = 0
+QSFP_POWERSET_BIT = 1
+QSFP_OPTION_VALUE_OFFSET = 192
+QSFP_OPTION_VALUE_WIDTH = 4
+QSFP_MODULE_UPPER_PAGE3_START = 384
+QSFP_MODULE_THRESHOLD_OFFSET = 128
+QSFP_MODULE_THRESHOLD_WIDTH = 24
+QSFP_CHANNL_THRESHOLD_OFFSET = 176
+QSFP_CHANNL_THRESHOLD_WIDTH = 24
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+
+qsfp_cable_length_tup = ('Length(km)', 'Length OM3(2m)',
+                         'Length OM2(m)', 'Length OM1(m)',
+                         'Length Cable Assembly(m)')
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+qsfp_compliance_code_tup = ('10/40G Ethernet Compliance Code', 'SONET Compliance codes',
+                            'SAS/SATA compliance codes', 'Gigabit Ethernet Compliant codes',
+                            'Fibre Channel link length/Transmitter Technology',
+                            'Fibre Channel transmission media', 'Fibre Channel Speed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+QSFP_TYPE = "QSFP"
+OSFP_TYPE = "OSFP"
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+# SFP PORT numbers
+SFP_PORT_START = 1
+SFP_PORT_END = 48
+# QSFP PORT numbers
+QSFP_PORT_START = 49
+QSFP_PORT_END = 83
+
+class Sfp(SfpBase):
+    """Platform-specific Sfp class"""
+    """
+    Falcon 2T  platform-specific Sfp class
+    """
+    HWSKU = "db98cx8514_10cc"
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+        self.port_to_eeprom_mapping[index] = eeprom_path
+
+        sai_profile_path = self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path  + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+        self._dom_capability_detect()
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+                cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+                os.system(cmd)
+        else:
+                bus = smbus.SMBus(2)
+                bus.write_byte_data(device_addr, offset, value)
+
+    def __get_path_to_port_config_file(self):
+        """
+        Retrieve port_config.ini path.
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns port_config.ini path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "port_config.ini"])
+
+    def __get_path_to_sai_profile_file(self):
+        """
+        Retrieve sai.profile path.
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == COPPER_TYPE:
+            return
+
+        if self.sfp_type == "QSFP":
+            self.calibration = 1
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                self.dom_supported = False
+            offset = 128
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                (offset + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qsfp_version_compliance_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_VERSION_COMPLIANCE_OFFSET, QSFP_VERSION_COMPLIANCE_WIDTH)
+                qsfp_version_compliance = int(
+                    qsfp_version_compliance_raw[0], 16)
+                dom_capability = sfpi_obj.parse_dom_capability(
+                    qsfp_dom_capability_raw, 0)
+                if qsfp_version_compliance >= 0x08:
+                    self.dom_temp_supported = dom_capability['data']['Temp_support']['value'] == 'On'
+                    self.dom_volt_supported = dom_capability['data']['Voltage_support']['value'] == 'On'
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = dom_capability['data']['Tx_power_support']['value'] == 'On'
+                else:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = True
+
+                self.dom_supported = True
+                self.calibration = 1
+                sfpd_obj = sff8436Dom()
+                if sfpd_obj is None:
+                    return None
+                qsfp_option_value_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_OPTION_VALUE_OFFSET, QSFP_OPTION_VALUE_WIDTH)
+                if qsfp_option_value_raw is not None:
+                    optional_capability = sfpd_obj.parse_option_params(
+                        qsfp_option_value_raw, 0)
+                    self.dom_tx_disable_supported = optional_capability[
+                        'data']['TxDisable']['value'] == 'On'
+                dom_status_indicator = sfpd_obj.parse_dom_status_indicator(
+                    qsfp_version_compliance_raw, 1)
+                self.qsfp_page3_available = dom_status_indicator['data']['FlatMem']['value'] == 'Off'
+            else:
+                self.dom_supported = False
+                self.dom_temp_supported = False
+                self.dom_volt_supported = False
+                self.dom_rx_power_supported = False
+                self.dom_tx_power_supported = False
+                self.calibration = 0
+                self.qsfp_page3_available = False
+
+        elif self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if self.sfp_type == OSFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            sfp_type_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                    sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                    sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                    sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                    sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if self.sfp_type == QSFP_TYPE:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+            if self.sfp_type == QSFP_TYPE:
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 0
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_DOM_BULK_DATA_START), QSFP_DOM_BULK_DATA_SIZE)
+
+            if dom_data_raw is None:
+                return transceiver_dom_info_dict
+
+            if self.dom_temp_supported:
+                start = QSFP_TEMPE_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_TEMPE_WIDTH
+                dom_temperature_data = sfpd_obj.parse_temperature(
+                    dom_data_raw[start: end], 0)
+                temp = self.__convert_string_to_num(
+                    dom_temperature_data['data']['Temperature']['value'])
+                if temp is not None:
+                    transceiver_dom_info_dict['temperature'] = temp
+
+            if self.dom_volt_supported:
+                start = QSFP_VOLT_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_VOLT_WIDTH
+                dom_voltage_data = sfpd_obj.parse_voltage(
+                    dom_data_raw[start: end], 0)
+                volt = self.__convert_string_to_num(
+                    dom_voltage_data['data']['Vcc']['value'])
+                if volt is not None:
+                    transceiver_dom_info_dict['voltage'] = volt
+
+            start = QSFP_CHANNL_MON_OFFSET - QSFP_DOM_BULK_DATA_START
+            end = start + QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                dom_data_raw[start: end], 0)
+
+            if self.dom_tx_power_supported:
+                transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX1Power']['value'])
+                transceiver_dom_info_dict['tx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX2Power']['value'])
+                transceiver_dom_info_dict['tx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX3Power']['value'])
+                transceiver_dom_info_dict['tx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX4Power']['value'])
+
+            if self.dom_rx_power_supported:
+                transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX1Power']['value'])
+                transceiver_dom_info_dict['rx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX2Power']['value'])
+                transceiver_dom_info_dict['rx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX3Power']['value'])
+                transceiver_dom_info_dict['rx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX4Power']['value'])
+
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported or not self.qsfp_page3_available:
+                return transceiver_dom_threshold_info_dict
+
+            # Dom Threshold data starts from offset 384
+            # Revert offset back to 0 once data is retrieved
+            offset = QSFP_MODULE_UPPER_PAGE3_START
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_THRESHOLD_OFFSET), QSFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_data = sfpd_obj.parse_module_threshold_values(
+                dom_module_threshold_raw, 0)
+
+            dom_channel_threshold_raw = self.__read_eeprom_specific_bytes((offset + QSFP_CHANNL_THRESHOLD_OFFSET),
+                                                                          QSFP_CHANNL_THRESHOLD_WIDTH)
+            if dom_channel_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+            dom_channel_threshold_data = sfpd_obj.parse_channel_threshold_values(
+                dom_channel_threshold_raw, 0)
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VccHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VccHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VccLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VccLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_channel_threshold_data['data']['RxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_channel_threshold_data['data']['RxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_channel_threshold_data['data']['RxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_channel_threshold_data['data']['RxPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_channel_threshold_data['data']['TxBiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_channel_threshold_data['data']['TxBiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_channel_threshold_data['data']['TxBiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_channel_threshold_data['data']['TxBiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_channel_threshold_data['data']['TxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_channel_threshold_data['data']['TxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_channel_threshold_data['data']['TxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_channel_threshold_data['data']['TxPowerLowWarning']['value']
+
+        else:
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == OSFP_TYPE:
+            return False
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+            dom_module_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_MONITOR_OFFSET), QSFP_MODULE_MONITOR_WIDTH)
+
+            if dom_module_monitor_raw is not None:
+                return True
+            else:
+                return False
+        elif self.sfp_type == SFP_TYPE:
+            offset = 0
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        return False
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        return False
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+        return False
+ 
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == QSFP_TYPE:
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return False
+
+            dom_control_raw = self.__read_eeprom_specific_bytes(
+                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None
+            if dom_control_raw is not None:
+                dom_control_data = sfpd_obj.parse_control_bytes(
+                    dom_control_raw, 0)
+                return ('On' == dom_control_data['data']['PowerOverride']['value'])
+        else:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+            A list of four integer numbers, representing TX bias in mA
+            for channel 0 to channel 4.
+            Ex. ['110.09', '111.12', '108.21', '112.09']
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx1_bs = transceiver_bulk_status.get("tx1bias", "N/A")
+        tx2_bs = transceiver_bulk_status.get("tx2bias", "N/A")
+        tx3_bs = transceiver_bulk_status.get("tx3bias", "N/A")
+        tx4_bs = transceiver_bulk_status.get("tx4bias", "N/A")
+        tx_bias_list = [tx1_bs, tx2_bs, tx3_bs, tx4_bs]
+        return tx_bias_list
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_rx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX1Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX2Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX3Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_tx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX1Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX2Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX3Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP and return all user module settings to their default srate.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        # Check for invalid port_num
+        if self.port_num < self._port_start or self.port_num > self._port_end:
+            return False
+        port_ps = "/sys/bus/i2c/devices/2-0050/sfp_port_reset"
+        try:
+            reg_file = open(port_ps, 'w')
+        except IOError as e:
+            print(e)
+            return False
+
+        #toggle reset
+        reg_file.seek(0)
+        reg_file.write('1')
+        time.sleep(1)
+        reg_file.seek(0)
+        reg_file.write('0')
+        reg_file.close()
+        return True
+
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX for all channels
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                tx_disable_ctl = 0xf if tx_disable else 0x0
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                channel_state = self.get_tx_disable_channel()
+                tx_enable_mask = [0xe, 0xd, 0xb, 0x7]
+                tx_disable_mask = [0x1, 0x3, 0x7, 0xf]
+                tx_disable_ctl = channel_state | tx_disable_mask[
+                    channel] if disable else channel_state & tx_enable_mask[channel]
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+
+            return True
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            try:
+                power_override_bit = 0
+                if power_override:
+                    power_override_bit |= 1 << 0
+
+                power_set_bit = 0
+                if power_set:
+                    power_set_bit |= 1 << 1
+
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(power_override_bit | power_set_bit)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_POWEROVERRIDE_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+        self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        port_index = self.port_num-1
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+        profile = sfputil_profiles[self._port_profile]
+
+        if  port_index not in profile:
+            return False
+        else:
+            
+            #Index is port number from port profile.
+            index = int(profile[port_index].split(",")[0])
+            
+            #Set i2cmux to select corresponding sfp port, to read EEPROM of sfp.
+            self.i2c_set(0x30, 0x09, index)
+           
+            #Read cpld register for corresponding sfp.
+            device_reg = int(profile[port_index].split(",")[1],16)
+
+            #Read sfp present bit for corresponding sfp port from cpld presence register.
+            sfp_present_bit= int(profile[port_index].split(",")[2])
+            sfp_present_mask = 1<<sfp_present_bit
+            
+            if smbus_present == 0:  # if called from sfputil outside of pmon
+                cmd = "sudo i2cget -y 2 0x30  " + hex(device_reg)
+                cmdstatus, sfpstatus = command.getstatusoutput(cmd)
+                sfpstatus = int(sfpstatus, 16)
+                status=sfpstatus&sfp_present_mask
+            else:
+                bus = smbus.SMBus(2)
+                DEVICE_ADDRESS = 0x30
+                DEVICE_REG = device_reg
+                sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+                status=sfpstatus&sfp_present_mask
+
+        if status == 0:
+            return True
+        else:
+            return False
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp_event.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..eadd9fff4
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/sfp_event.py
@@ -0,0 +1,258 @@
+#####################################################################
+#listen to the SDK for the SFP change event and return to chassis.
+#####################################################################
+
+from __future__ import print_function
+import os
+import time
+import sys
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+
+if sys.version_info[0] < 3:
+    import commands as command
+else:
+    import subprocess as command
+
+# Port  Num:<port_select_bit,device_register,port_status_bit>
+profile_2T80x25G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"48,0x17,0",  50:"48,0x17,0",  51:"48,0x17,0",  52:"49,0x17,1",  53:"49,0x17,1",  54:"49,0x17,1",  55:"49,0x17,1",
+ 56:"50,0x17,2",  57:"50,0x17,2",  58:"50,0x17,2",  59:"50,0x17,2",  60:"51,0x17,3",  61:"51,0x17,3",  62:"51,0x17,3",  63:"51,0x17,3",
+ 64:"52,0x17,4",  65:"52,0x17,4",  66:"52,0x17,4",  67:"52,0x17,4",  68:"53,0x17,5",  69:"53,0x17,5",  70:"53,0x17,5",  71:"53,0x17,5",
+ 72:"54,0x17,6",  73:"54,0x17,6",  74:"54,0x17,6",  75:"54,0x17,6",  76:"55,0x17,7",  77:"55,0x17,7",  78:"55,0x17,7",  79:"55,0x17,7",
+}
+
+profile_2T48x10G_8x100G = {
+  0:"0,0x11,0",   1:"1,0x11,1",    2:"2,0x11,2",    3:"3,0x11,3",    4:"4,0x11,4",    5:"5,0x11,5",    6:"6,0x11,6",    7:"7,0x11,7",
+  8:"8,0x12,0",   9:"9,0x12,1",    10:"10,0x12,2",  11:"11,0x12,3",  12:"12,0x12,4",  13:"13,0x12,5",  14:"14,0x12,6",  15:"15,0x12,7",
+ 16:"16,0x13,0",  17:"17,0x13,1",  18:"18,0x13,2",  19:"19,0x13,3",  20:"20,0x13,4",  21:"21,0x13,5",  22:"22,0x13,6",  23:"23,0x13,7",
+ 24:"24,0x14,0",  25:"25,0x14,1",  26:"26,0x14,2",  27:"27,0x14,3",  28:"28,0x14,4",  29:"29,0x14,5",  30:"30,0x14,6",  31:"31,0x14,7",
+ 32:"32,0x15,0",  33:"33,0x15,1",  34:"34,0x15,2",  35:"35,0x15,3",  36:"36,0x15,4",  37:"37,0x15,5",  38:"38,0x15,6",  39:"39,0x15,7",
+ 40:"40,0x16,0",  41:"41,0x16,1",  42:"42,0x16,2",  43:"43,0x16,3",  44:"44,0x16,4",  45:"45,0x16,5",  46:"46,0x16,6",  47:"47,0x16,7",
+ 48:"48,0x17,0",  49:"49,0x17,1",  50:"50,0x17,2",  51:"51,0x17,3",  52:"52,0x17,4",  53:"53,0x17,5",  54:"54,0x17,6",  55:"55,0x17,7",
+}
+
+sfputil_profiles = {
+"F2T80x25G":profile_2T80x25G,
+"F2T48x25G8x100G":profile_2T48x10G_8x100G,
+"F2T48x10G8x100G":profile_2T48x10G_8x100G
+}
+
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+#PORT numbers
+PORT_START = 1
+PORT_END = 80
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    HWSKU = "db98cx8514_10cc"
+    def __init__(self):
+        
+        self.handle = None
+        self.port_to_eeprom_mapping = {}
+        self.PORT_START=PORT_START
+        self.PORT_END=PORT_END
+        eeprom_path="/sys/bus/i2c/devices/2-0050/eeprom"
+
+        x = self.PORT_START
+        while(x<self.PORT_END+1):
+            self.port_to_eeprom_mapping[x] = eeprom_path
+            x = x + 1
+        #Reading currenr port profile
+        path=self.__get_path_to_sai_file()
+        cmd = "cat " + path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+ 
+    def initialize(self):       
+        self.modprs_register = 0 
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self.get_transceiver_status()
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+            cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+            os.system(cmd)
+        else:
+            bus = smbus.SMBus(2)
+            bus.write_byte_data(device_addr, offset, value)
+      
+
+    def get_transceiver_status(self):
+        if smbus_present == 0:
+            sfpstatus_bin = ''
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x11') 
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x12')
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x13') 
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x14')
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x15')
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x16')
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+            
+            cmdstatus, sfpstatus = cmd.getstatusoutput('i2cget -y 2 0x30 0x17')
+            sfpstatus = int(sfpstatus, 16)
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            sfpstatus_bin = ''.join('1' if j == '0' else '0' for j in sfpstatus_bin)
+            sfpstatus = int(sfpstatus_bin,2)
+        else:
+            sfpstatus_bin = ''
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x11
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x12
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin =  (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x13
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin =  (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x14
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin =  (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x15
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x16
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+            
+            bus = smbus.SMBus(2)
+            DEVICE_ADDRESS = 0x30
+            DEVICE_REG = 0x17
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)  
+            sfpstatus_bin = (format(sfpstatus, '#010b')).split('0b')[1] + sfpstatus_bin
+
+            #logger.log_info("Current SFP presence in bin   =   %s" % sfpstatus_bin )
+            sfpstatus_bin = ''.join('1' if j == '0' else '0' for j in sfpstatus_bin)
+            sfpstatus = int(sfpstatus_bin, 2)
+
+        return sfpstatus
+    def __get_path_to_sai_file(self):
+        """
+        Retrieve sai.profile path
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+         check_sfp_status called from get_change_event,
+         this will return correct status of all ports if there is a change in any of them 
+        """
+    
+        start_time = time.time()
+        port = self.PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000) # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {} # Time wrap or possibly incorrect timeout
+        
+        while (timeout >= 0):
+            all_port_status = self.get_transceiver_status()
+
+            if (all_port_status != self.modprs_register):
+                changed_ports = (self.modprs_register ^ all_port_status)
+
+                while (port >= self.PORT_START and port <=self.PORT_END):
+                    profile = sfputil_profiles[self._port_profile]
+                    port_index = port - 1
+                    if  port_index in profile:
+                        #Mask off the bit corresponding to our port
+                        real_port= int(profile[port_index].split(",")[0])
+                        mask = (1 << real_port)
+                        y=(changed_ports & mask)
+                        if (changed_ports & mask):
+                                if all_port_status & mask == 0:
+                                     port_change[port] = '0'
+                                else:
+                                     port_change[port] = '1'
+                    port += 1
+                # Update reg value
+                self.modprs_register = all_port_status
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1) # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
+            
+        return False, {}
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/watchdog.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/watchdog.py
new file mode 100644
index 000000000..8c8541ea0
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/sonic_platform/watchdog.py
@@ -0,0 +1,133 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/utils/get-base-mac.py b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/db98cx8514/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/changelog b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/changelog
new file mode 100644
index 000000000..569563c70
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/changelog
@@ -0,0 +1,4 @@
+sonic-platform-db98cx8514-10cc-db98cx8514 (1.0) unstable; urgency=low
+
+  * Add support for sonic-platform-db98cx8514-10cc
+ -- Marvell  Thu, 16 sep 2021 09:35:58 +0800
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/compat b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/control b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/control
new file mode 100644
index 000000000..9e14ca387
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-db98cx8514-10cc-db98cx8514
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-db98cx8514-10cc-db98cx8514
+Architecture: amd64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/rules b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/rules
new file mode 100644
index 000000000..ac96824c4
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/rules
@@ -0,0 +1,66 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-db98cx8514-10cc
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= db98cx8514
+UTILS_DIR := utils
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python2,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		python2 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		python2 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.install b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.install
new file mode 100644
index 000000000..23e29c1b0
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.install
@@ -0,0 +1,5 @@
+db98cx8514/scripts/db98cx8514-10cc-init.sh  usr/local/bin
+db98cx8514/service/db98cx8514-10cc-init.service etc/systemd/system
+db98cx8514/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/x86_64-marvell_db98cx8514_10cc-r0
+
+
diff --git a/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.postinst b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.postinst
new file mode 100644
index 000000000..71c5d77b3
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8514-10cc/debian/sonic-platform-db98cx8514-10cc-db98cx8514.postinst
@@ -0,0 +1,10 @@
+#!/bin/sh
+# postinst script for sonic-platform-db98cx8514-10cc
+#
+# see: dh_installdeb(1)
+
+chmod a+x /usr/local/bin/db98cx8514-10cc-init.sh
+systemctl enable db98cx8514-10cc-init.service
+systemctl start db98cx8514-10cc-init.service
+exit 0
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh
new file mode 100644
index 000000000..fc9a72477
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+# Platform init script for db98cx8540-16cd 
+
+
+# - Main entry
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-2/new_device
+
+exit 0
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service
new file mode 100644
index 000000000..f655e6646
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Platform db98cx8540-16cd Service
+Before=pmon.service
+After=sysinit.target
+DefaultDependencies=no
+
+[Service]
+ExecStart=/usr/local/bin/db98cx8540-16cd-init.sh
+KillSignal=SIGKILL
+SuccessExitStatus=SIGKILL
+#StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py
new file mode 100644
index 000000000..ba72a742c
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'db98cx8540/sonic_platform'},
+)
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py
new file mode 100644
index 000000000..b56f2c817
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py
@@ -0,0 +1,363 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_COMPONENT=2
+MAX_SELECT_DELAY = 3600
+SFP_PORT_START = 1
+SFP_PORT_END = 132
+PORT_END = 132
+
+profile_16x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_64x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x74,4",  65:"0x74,5" }
+
+profile_32x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,1",  27:"0x71,1",  28:"0x71,2",  29:"0x71,2",  30:"0x71,3",  31:"0x71,3",
+ 32:"0x74,4",  33:"0x74,5" }
+
+profile_16x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_16x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_24x25G_4x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,1",  29:"0x71,1",  30:"0x71,1",  31:"0x71,1",
+ 32:"0x71,2",  33:"0x71,2",  34:"0x71,2",  35:"0x71,2",  36:"0x71,3",  37:"0x71,3",  38:"0x71,3",  39:"0x71,3",
+ 40:"0x74,4",  41:"0x74,5" }
+
+profile_24x25G_8x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,0",  29:"0x71,0",  30:"0x71,0",  31:"0x71,0",
+ 32:"0x71,1",  33:"0x71,1",  34:"0x71,1",  35:"0x71,1",  36:"0x71,1",  37:"0x71,1",  38:"0x71,1",  39:"0x71,1",
+ 40:"0x71,2",  41:"0x71,2",  42:"0x71,2",  43:"0x71,2",  44:"0x71,2",  45:"0x71,2",  46:"0x71,2",  47:"0x71,2",
+ 48:"0x71,3",  49:"0x71,3",  50:"0x71,3",  51:"0x71,3",  52:"0x71,3",  53:"0x71,3",  54:"0x71,3",  55:"0x71,3",
+ 56:"0x74,4",  57:"0x74,5" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,0",  53:"0x71,0",  54:"0x71,0",  55:"0x71,0",
+ 56:"0x71,1",  57:"0x71,1",  58:"0x71,1",  59:"0x71,1",  60:"0x71,1",  61:"0x71,1",  62:"0x71,1",  63:"0x71,1",
+ 64:"0x71,2",  65:"0x71,2",  66:"0x71,2",  67:"0x71,2",  68:"0x71,2",  69:"0x71,2",  70:"0x71,2",  71:"0x71,2",
+ 72:"0x71,3",  73:"0x71,3",  74:"0x71,3",  75:"0x71,3",  76:"0x71,3",  77:"0x71,3",  78:"0x71,3",  79:"0x71,3",
+ 80:"0x74,4",  81:"0x74,5" }
+
+sfputil_profiles = {
+ "FALCON16X25G":profile_16x25G,
+ "FC16x25GIXIA":profile_16x25G_ixia,
+ "FALCON16x400G":profile_16x400G,
+ "FALCON128x50G":profile_16x400G,
+ "FALCON64x100G":profile_16x400G,
+ "FC16x100G8x400G":profile_16x400G,
+ "FC24x100G4x400G":profile_16x400G,
+ "FC32x100G8x400G":profile_16x400G,
+ "FALCON64x25G":profile_64x25G,
+ "FALCON32x25G64":profile_32x25G,
+ "FC24x254x200G64":profile_24x25G_4x200G,
+ "FC24x258x100G64":profile_24x25G_8x200G,
+ "FC48x10G8x100G":profile_48x25G_8x100G,
+ "FC48x25G8x100G":profile_48x25G_8x100G
+}
+
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    HWSKU = "db98cx8540_16cd"
+
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+
+        # Port numbers for Initialize SFP
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        sai_profile_path=self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+        eeprom_path = '/sys/bus/i2c/devices/2-0050/eeprom'
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            profile = sfputil_profiles[self._port_profile]
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            if port in profile:
+                sfp_node = Sfp(index, 'QSFP', port_eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+
+    def __get_path_to_sai_profile_file(self):
+        """
+        Retrieve sai.profile path
+        Returns:
+            get_path_to_platform_dir(): get platform path depend on, whether we're running on container or on the host
+            Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        #lrr = self._get_cpld_register('mb_reboot_cause')
+        #if (lrr != 'ERR'):
+        #    reset_reason = lrr
+        #    if (reset_reason in self.reset_reason_dict):
+        #        return (self.reset_reason_dict[reset_reason], None)
+        #
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py
new file mode 100644
index 000000000..ae0a76411
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py
@@ -0,0 +1,91 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["BIOS", "BIOS - Basic Input/Output System"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+        if self.index == 0:
+            cmdstatus, bios_version = cmd.getstatusoutput('dmidecode -s bios-version')
+            return bios_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py
new file mode 100644
index 000000000..a6f6bea17
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py
@@ -0,0 +1,237 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Serial number, Part number, Service Tag,
+#                PSU type, Revision.
+# - Fan EEPROM : Contains Serial number, Part number, Service Tag,
+#                Fan type, Number of Fans in Fantray, Revision.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = "/etc/sonic/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 6
+                #self.eeprom_path = self.I2C_DIR \
+                #    + "i2c-3{0}/3{0}-0056/eeprom".format(self.index - 1)
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(2 - self.index)
+                self.format = psu_eeprom_format
+            else:
+                self.index = fan_index
+                self.start_offset = 13
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-4{0}/4{0}-0050/eeprom".format(self.index - 1)
+                self.format = fan_eeprom_format
+            EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                   self.start_offset, '', True)
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and retrieves the serial number and
+        model number of the device.
+        """
+        try:
+            # Read Fan/PSU EEPROM as per the specified format.
+            self.eeprom_data = EepromDecoder.read_eeprom(self)
+        except Exception as e:
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+        else:
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data
+            else:
+                self.model_str = 'NA'
+
+            (valid, data) = self._get_eeprom_field("Serial Number")
+            if valid:
+                self.serial_number = data
+            else:
+                self.serial_number = 'NA'
+
+            if self.is_psu_eeprom:
+                (valid, data) = self._get_eeprom_field("PSU Type")
+                if valid:
+                    self.psu_type = data
+                else:
+                    self.psu_type = 'NA'
+            else:
+                (valid, data) = self._get_eeprom_field("Fan Type")
+                if valid:
+                    self.fan_type = data
+                else:
+                    self.fan_type = 'NA'
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py
new file mode 100644
index 000000000..39d8cb5da
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py
@@ -0,0 +1,1435 @@
+#!/usr/bin/env python
+import os
+import time
+from ctypes import create_string_buffer
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom
+    from sonic_platform_base.sonic_sfp.inf8628 import inf8628InterfaceId
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_16x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_64x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x74,4",  65:"0x74,5" }
+
+profile_32x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,1",  27:"0x71,1",  28:"0x71,2",  29:"0x71,2",  30:"0x71,3",  31:"0x71,3",
+ 32:"0x74,4",  33:"0x74,5" }
+
+profile_16x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_16x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_24x25G_4x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,1",  29:"0x71,1",  30:"0x71,1",  31:"0x71,1",
+ 32:"0x71,2",  33:"0x71,2",  34:"0x71,2",  35:"0x71,2",  36:"0x71,3",  37:"0x71,3",  38:"0x71,3",  39:"0x71,3",
+ 40:"0x74,4",  41:"0x74,5" }
+
+profile_24x25G_8x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,0",  29:"0x71,0",  30:"0x71,0",  31:"0x71,0",
+ 32:"0x71,1",  33:"0x71,1",  34:"0x71,1",  35:"0x71,1",  36:"0x71,1",  37:"0x71,1",  38:"0x71,1",  39:"0x71,1",
+ 40:"0x71,2",  41:"0x71,2",  42:"0x71,2",  43:"0x71,2",  44:"0x71,2",  45:"0x71,2",  46:"0x71,2",  47:"0x71,2",
+ 48:"0x71,3",  49:"0x71,3",  50:"0x71,3",  51:"0x71,3",  52:"0x71,3",  53:"0x71,3",  54:"0x71,3",  55:"0x71,3",
+ 56:"0x74,4",  57:"0x74,5" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,0",  53:"0x71,0",  54:"0x71,0",  55:"0x71,0",
+ 56:"0x71,1",  57:"0x71,1",  58:"0x71,1",  59:"0x71,1",  60:"0x71,1",  61:"0x71,1",  62:"0x71,1",  63:"0x71,1",
+ 64:"0x71,2",  65:"0x71,2",  66:"0x71,2",  67:"0x71,2",  68:"0x71,2",  69:"0x71,2",  70:"0x71,2",  71:"0x71,2",
+ 72:"0x71,3",  73:"0x71,3",  74:"0x71,3",  75:"0x71,3",  76:"0x71,3",  77:"0x71,3",  78:"0x71,3",  79:"0x71,3",
+ 80:"0x74,4",  81:"0x74,5" }
+
+sfputil_profiles = {
+ "FALCON16X25G":profile_16x25G,
+ "FC16x25GIXIA":profile_16x25G_ixia,
+ "FALCON16x400G":profile_16x400G,
+ "FALCON128x50G":profile_16x400G,
+ "FALCON64x100G":profile_16x400G,
+ "FC16x100G8x400G":profile_16x400G,
+ "FC24x100G4x400G":profile_16x400G,
+ "FC32x100G8x400G":profile_16x400G,
+ "FALCON64x25G":profile_64x25G,
+ "FALCON32x25G64":profile_32x25G,
+ "FC24x254x200G64":profile_24x25G_4x200G,
+ "FC24x258x100G64":profile_24x25G_8x200G,
+ "FC48x10G8x100G":profile_48x25G_8x100G,
+ "FC48x25G8x100G":profile_48x25G_8x100G
+}
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+XCVR_INTFACE_BULK_WIDTH_QSFP = 20
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+XCVR_CABLE_LENGTH_WIDTH_QSFP = 5
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+XCVR_HW_REV_WIDTH_OSFP = 2
+XCVR_HW_REV_WIDTH_QSFP = 2
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+QSFP_DOM_BULK_DATA_START = 22
+QSFP_DOM_BULK_DATA_SIZE = 36
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+# definitions of the offset for values in OSFP info eeprom
+OSFP_TYPE_OFFSET = 0
+OSFP_VENDOR_NAME_OFFSET = 129
+OSFP_VENDOR_PN_OFFSET = 148
+OSFP_HW_REV_OFFSET = 164
+OSFP_VENDOR_SN_OFFSET = 166
+
+# Offset for values in QSFP eeprom
+QSFP_DOM_REV_OFFSET = 1
+QSFP_DOM_REV_WIDTH = 1
+QSFP_TEMPE_OFFSET = 22
+QSFP_TEMPE_WIDTH = 2
+QSFP_VOLT_OFFSET = 26
+QSFP_VOLT_WIDTH = 2
+QSFP_VERSION_COMPLIANCE_OFFSET = 1
+QSFP_VERSION_COMPLIANCE_WIDTH = 2
+QSFP_CHANNL_MON_OFFSET = 34
+QSFP_CHANNL_MON_WIDTH = 16
+QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH = 24
+QSFP_CHANNL_DISABLE_STATUS_OFFSET = 86
+QSFP_CHANNL_DISABLE_STATUS_WIDTH = 1
+QSFP_CHANNL_RX_LOS_STATUS_OFFSET = 3
+QSFP_CHANNL_RX_LOS_STATUS_WIDTH = 1
+QSFP_CHANNL_TX_FAULT_STATUS_OFFSET = 4
+QSFP_CHANNL_TX_FAULT_STATUS_WIDTH = 1
+QSFP_CONTROL_OFFSET = 86
+QSFP_CONTROL_WIDTH = 8
+QSFP_MODULE_MONITOR_OFFSET = 0
+QSFP_MODULE_MONITOR_WIDTH = 9
+QSFP_POWEROVERRIDE_OFFSET = 93
+QSFP_POWEROVERRIDE_WIDTH = 1
+QSFP_POWEROVERRIDE_BIT = 0
+QSFP_POWERSET_BIT = 1
+QSFP_OPTION_VALUE_OFFSET = 192
+QSFP_OPTION_VALUE_WIDTH = 4
+QSFP_MODULE_UPPER_PAGE3_START = 384
+QSFP_MODULE_THRESHOLD_OFFSET = 128
+QSFP_MODULE_THRESHOLD_WIDTH = 24
+QSFP_CHANNL_THRESHOLD_OFFSET = 176
+QSFP_CHANNL_THRESHOLD_WIDTH = 24
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+
+qsfp_cable_length_tup = ('Length(km)', 'Length OM3(2m)',
+                         'Length OM2(m)', 'Length OM1(m)',
+                         'Length Cable Assembly(m)')
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+qsfp_compliance_code_tup = ('10/40G Ethernet Compliance Code', 'SONET Compliance codes',
+                            'SAS/SATA compliance codes', 'Gigabit Ethernet Compliant codes',
+                            'Fibre Channel link length/Transmitter Technology',
+                            'Fibre Channel transmission media', 'Fibre Channel Speed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+QSFP_TYPE = "QSFP"
+OSFP_TYPE = "OSFP"
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class Sfp(SfpBase):
+    HWSKU = "db98cx8540_16cd"
+    _port_start = 1
+    _port_end = 132
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+        self.port_to_eeprom_mapping[index] = eeprom_path
+        sai_profile_path = self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path  + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+        self._dom_capability_detect()
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+                cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+                os.system(cmd)
+        else:
+                bus = smbus.SMBus(2)
+                bus.write_byte_data(device_addr, offset, value)
+
+    def __get_path_to_port_config_file(self):
+        """
+        Retrieve port_config.ini path.
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns port_config.ini path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "port_config.ini"])
+
+    def __get_path_to_sai_profile_file(self):
+        """
+        Retrieve sai.profile path.
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == COPPER_TYPE:
+            return
+
+        if self.sfp_type == "QSFP":
+            self.calibration = 1
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                self.dom_supported = False
+            offset = 128
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                (offset + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qsfp_version_compliance_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_VERSION_COMPLIANCE_OFFSET, QSFP_VERSION_COMPLIANCE_WIDTH)
+                qsfp_version_compliance = int(
+                    qsfp_version_compliance_raw[0], 16)
+                dom_capability = sfpi_obj.parse_dom_capability(
+                    qsfp_dom_capability_raw, 0)
+                if qsfp_version_compliance >= 0x08:
+                    self.dom_temp_supported = dom_capability['data']['Temp_support']['value'] == 'On'
+                    self.dom_volt_supported = dom_capability['data']['Voltage_support']['value'] == 'On'
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = dom_capability['data']['Tx_power_support']['value'] == 'On'
+                else:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = True
+
+                self.dom_supported = True
+                self.calibration = 1
+                sfpd_obj = sff8436Dom()
+                if sfpd_obj is None:
+                    return None
+                qsfp_option_value_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_OPTION_VALUE_OFFSET, QSFP_OPTION_VALUE_WIDTH)
+                if qsfp_option_value_raw is not None:
+                    optional_capability = sfpd_obj.parse_option_params(
+                        qsfp_option_value_raw, 0)
+                    self.dom_tx_disable_supported = optional_capability[
+                        'data']['TxDisable']['value'] == 'On'
+                dom_status_indicator = sfpd_obj.parse_dom_status_indicator(
+                    qsfp_version_compliance_raw, 1)
+                self.qsfp_page3_available = dom_status_indicator['data']['FlatMem']['value'] == 'Off'
+            else:
+                self.dom_supported = False
+                self.dom_temp_supported = False
+                self.dom_volt_supported = False
+                self.dom_rx_power_supported = False
+                self.dom_tx_power_supported = False
+                self.calibration = 0
+                self.qsfp_page3_available = False
+
+        elif self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if self.sfp_type == OSFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            sfp_type_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                    sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                    sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                    sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                    sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if self.sfp_type == QSFP_TYPE:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+            if self.sfp_type == QSFP_TYPE:
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 0
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_DOM_BULK_DATA_START), QSFP_DOM_BULK_DATA_SIZE)
+
+            if dom_data_raw is None:
+                return transceiver_dom_info_dict
+
+            if self.dom_temp_supported:
+                start = QSFP_TEMPE_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_TEMPE_WIDTH
+                dom_temperature_data = sfpd_obj.parse_temperature(
+                    dom_data_raw[start: end], 0)
+                temp = self.__convert_string_to_num(
+                    dom_temperature_data['data']['Temperature']['value'])
+                if temp is not None:
+                    transceiver_dom_info_dict['temperature'] = temp
+
+            if self.dom_volt_supported:
+                start = QSFP_VOLT_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_VOLT_WIDTH
+                dom_voltage_data = sfpd_obj.parse_voltage(
+                    dom_data_raw[start: end], 0)
+                volt = self.__convert_string_to_num(
+                    dom_voltage_data['data']['Vcc']['value'])
+                if volt is not None:
+                    transceiver_dom_info_dict['voltage'] = volt
+
+            start = QSFP_CHANNL_MON_OFFSET - QSFP_DOM_BULK_DATA_START
+            end = start + QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                dom_data_raw[start: end], 0)
+
+            if self.dom_tx_power_supported:
+                transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX1Power']['value'])
+                transceiver_dom_info_dict['tx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX2Power']['value'])
+                transceiver_dom_info_dict['tx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX3Power']['value'])
+                transceiver_dom_info_dict['tx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX4Power']['value'])
+
+            if self.dom_rx_power_supported:
+                transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX1Power']['value'])
+                transceiver_dom_info_dict['rx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX2Power']['value'])
+                transceiver_dom_info_dict['rx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX3Power']['value'])
+                transceiver_dom_info_dict['rx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX4Power']['value'])
+
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported or not self.qsfp_page3_available:
+                return transceiver_dom_threshold_info_dict
+
+            # Dom Threshold data starts from offset 384
+            # Revert offset back to 0 once data is retrieved
+            offset = QSFP_MODULE_UPPER_PAGE3_START
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_THRESHOLD_OFFSET), QSFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_data = sfpd_obj.parse_module_threshold_values(
+                dom_module_threshold_raw, 0)
+
+            dom_channel_threshold_raw = self.__read_eeprom_specific_bytes((offset + QSFP_CHANNL_THRESHOLD_OFFSET),
+                                                                          QSFP_CHANNL_THRESHOLD_WIDTH)
+            if dom_channel_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+            dom_channel_threshold_data = sfpd_obj.parse_channel_threshold_values(
+                dom_channel_threshold_raw, 0)
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VccHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VccHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VccLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VccLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_channel_threshold_data['data']['RxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_channel_threshold_data['data']['RxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_channel_threshold_data['data']['RxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_channel_threshold_data['data']['RxPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_channel_threshold_data['data']['TxBiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_channel_threshold_data['data']['TxBiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_channel_threshold_data['data']['TxBiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_channel_threshold_data['data']['TxBiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_channel_threshold_data['data']['TxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_channel_threshold_data['data']['TxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_channel_threshold_data['data']['TxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_channel_threshold_data['data']['TxPowerLowWarning']['value']
+
+        else:
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == OSFP_TYPE:
+            return False
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+            dom_module_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_MONITOR_OFFSET), QSFP_MODULE_MONITOR_WIDTH)
+
+            if dom_module_monitor_raw is not None:
+                return True
+            else:
+                return False
+        elif self.sfp_type == SFP_TYPE:
+            offset = 0
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        return False
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        return False
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+        return False
+ 
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == QSFP_TYPE:
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return False
+
+            dom_control_raw = self.__read_eeprom_specific_bytes(
+                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None
+            if dom_control_raw is not None:
+                dom_control_data = sfpd_obj.parse_control_bytes(
+                    dom_control_raw, 0)
+                return ('On' == dom_control_data['data']['PowerOverride']['value'])
+        else:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+            A list of four integer numbers, representing TX bias in mA
+            for channel 0 to channel 4.
+            Ex. ['110.09', '111.12', '108.21', '112.09']
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx1_bs = transceiver_bulk_status.get("tx1bias", "N/A")
+        tx2_bs = transceiver_bulk_status.get("tx2bias", "N/A")
+        tx3_bs = transceiver_bulk_status.get("tx3bias", "N/A")
+        tx4_bs = transceiver_bulk_status.get("tx4bias", "N/A")
+        tx_bias_list = [tx1_bs, tx2_bs, tx3_bs, tx4_bs]
+        return tx_bias_list
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_rx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX1Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX2Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX3Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_tx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX1Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX2Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX3Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP and return all user module settings to their default srate.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        # Check for invalid port_num
+        if self.port_num < self._port_start or self.port_num > self._port_end:
+            return False
+        port_ps = "/sys/bus/i2c/devices/2-0050/sfp_port_reset"
+        try:
+            reg_file = open(port_ps, 'w')
+        except IOError as e:
+            print(e)
+            return False
+
+        #toggle reset
+        reg_file.seek(0)
+        reg_file.write('1')
+        time.sleep(1)
+        reg_file.seek(0)
+        reg_file.write('0')
+        reg_file.close()
+        return True
+
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX for all channels
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                tx_disable_ctl = 0xf if tx_disable else 0x0
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                channel_state = self.get_tx_disable_channel()
+                tx_enable_mask = [0xe, 0xd, 0xb, 0x7]
+                tx_disable_mask = [0x1, 0x3, 0x7, 0xf]
+                tx_disable_ctl = channel_state | tx_disable_mask[
+                    channel] if disable else channel_state & tx_enable_mask[channel]
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            try:
+                power_override_bit = 0
+                if power_override:
+                    power_override_bit |= 1 << 0
+
+                power_set_bit = 0
+                if power_set:
+                    power_set_bit |= 1 << 1
+
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(power_override_bit | power_set_bit)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_POWEROVERRIDE_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+        self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        port_index = self.port_num-1
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+        profile = sfputil_profiles[self._port_profile]
+        if  port_index not in profile:
+            return False
+        else:
+            offset = int(profile[port_index].split(",")[1])
+            bin_offset = 1<<offset
+            device_reg = int(profile[port_index].split(",")[0],16)
+            self.i2c_set(device_reg, 0, bin_offset)
+            try:
+                reg_file = open(sysfs_sfp_i2c_client_eeprom_path, 'rb')
+                reg_file.seek(1)
+                reg_file.read(2)
+            except IOError as e:
+                return False
+
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..604eaf49e
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py
@@ -0,0 +1,259 @@
+#!/usr/bin/env python
+'''
+listen to the SDK for the SFP change event and return to chassis.
+'''
+
+from __future__ import print_function
+import os
+import time
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_16x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_64x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x74,4",  65:"0x74,5" }
+
+profile_32x25G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,1",  27:"0x71,1",  28:"0x71,2",  29:"0x71,2",  30:"0x71,3",  31:"0x71,3",
+ 32:"0x74,4",  33:"0x74,5" }
+
+profile_16x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_16x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x74,4",  17:"0x74,5" }
+
+profile_24x25G_4x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,1",  29:"0x71,1",  30:"0x71,1",  31:"0x71,1",
+ 32:"0x71,2",  33:"0x71,2",  34:"0x71,2",  35:"0x71,2",  36:"0x71,3",  37:"0x71,3",  38:"0x71,3",  39:"0x71,3",
+ 40:"0x74,4",  41:"0x74,5" }
+
+profile_24x25G_8x200G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,5",   3:"0x70,5",   4:"0x70,6",   5:"0x70,6",   6:"0x70,7",   7:"0x70,7",
+  8:"0x70,0",   9:"0x70,0",  10:"0x70,1",  11:"0x70,1",  12:"0x70,2",  13:"0x70,2",  14:"0x70,3",  15:"0x70,3",
+ 16:"0x71,4",  17:"0x71,4",  18:"0x71,5",  19:"0x71,5",  20:"0x71,6",  21:"0x71,6",  22:"0x71,7",  23:"0x71,7",
+ 24:"0x71,0",  25:"0x71,0",  26:"0x71,0",  27:"0x71,0",  28:"0x71,0",  29:"0x71,0",  30:"0x71,0",  31:"0x71,0",
+ 32:"0x71,1",  33:"0x71,1",  34:"0x71,1",  35:"0x71,1",  36:"0x71,1",  37:"0x71,1",  38:"0x71,1",  39:"0x71,1",
+ 40:"0x71,2",  41:"0x71,2",  42:"0x71,2",  43:"0x71,2",  44:"0x71,2",  45:"0x71,2",  46:"0x71,2",  47:"0x71,2",
+ 48:"0x71,3",  49:"0x71,3",  50:"0x71,3",  51:"0x71,3",  52:"0x71,3",  53:"0x71,3",  54:"0x71,3",  55:"0x71,3",
+ 56:"0x74,4",  57:"0x74,5" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,0",  53:"0x71,0",  54:"0x71,0",  55:"0x71,0",
+ 56:"0x71,1",  57:"0x71,1",  58:"0x71,1",  59:"0x71,1",  60:"0x71,1",  61:"0x71,1",  62:"0x71,1",  63:"0x71,1",
+ 64:"0x71,2",  65:"0x71,2",  66:"0x71,2",  67:"0x71,2",  68:"0x71,2",  69:"0x71,2",  70:"0x71,2",  71:"0x71,2",
+ 72:"0x71,3",  73:"0x71,3",  74:"0x71,3",  75:"0x71,3",  76:"0x71,3",  77:"0x71,3",  78:"0x71,3",  79:"0x71,3",
+ 80:"0x74,4",  81:"0x74,5" }
+
+sfputil_profiles = {
+ "FALCON16X25G":profile_16x25G,
+ "FC16x25GIXIA":profile_16x25G_ixia,
+ "FALCON16x400G":profile_16x400G,
+ "FALCON128x50G":profile_16x400G,
+ "FALCON64x100G":profile_16x400G,
+ "FC16x100G8x400G":profile_16x400G,
+ "FC24x100G4x400G":profile_16x400G,
+ "FC32x100G8x400G":profile_16x400G,
+ "FALCON64x25G":profile_64x25G,
+ "FALCON32x25G64":profile_32x25G,
+ "FC24x254x200G64":profile_24x25G_4x200G,
+ "FC24x258x100G64":profile_24x25G_8x200G,
+ "FC48x10G8x100G":profile_48x25G_8x100G,
+ "FC48x25G8x100G":profile_48x25G_8x100G
+}
+
+
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+
+# SFP PORT numbers
+SFP_PORT_START = 1
+SFP_PORT_END = 132
+
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    HWSKU = "db98cx8540_16cd"
+    def __init__(self):
+        
+        self.handle = None
+        self.port_to_eeprom_mapping = {}
+        self.SFP_PORT_START=SFP_PORT_START
+        self.SFP_PORT_END=SFP_PORT_END
+        eeprom_path="/sys/bus/i2c/devices/2-0050/eeprom"
+
+        x = self.SFP_PORT_START
+        while(x<self.SFP_PORT_END+1):
+            self.port_to_eeprom_mapping[x] = eeprom_path
+            x = x + 1
+        path=self.__get_path_to_sai_file()
+        cmd = "cat " + path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+ 
+    def initialize(self):       
+        self.modprs_register = 0 
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+            cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+            os.system(cmd)
+        else:
+            bus = smbus.SMBus(2)
+            bus.write_byte_data(device_addr, offset, value)
+      
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+        sfp_status = 0
+        x = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+                port_index = index-1
+                profile = sfputil_profiles[self._port_profile]
+                if  port_index in profile:
+                        offset = int(profile[port_index].split(",")[1])
+                        bin_offset = 1<<offset
+                        device_reg = int(profile[port_index].split(",")[0],16)
+                        self.i2c_set(device_reg, 0, bin_offset)
+                        path = "/sys/bus/i2c/devices/2-0050/eeprom"
+                        try:
+                                reg_file = open(path, 'rb')
+                                reg_file.seek(1)
+                                reg_file.read(2)
+                                sfp_status=( x | (1<<index-self.SFP_PORT_START)) + sfp_status
+                        except IOError as e:
+                                sfp_status=( x & ~(1<<index-self.SFP_PORT_START)) + sfp_status
+
+        sfp_status = ~sfp_status
+        return sfp_status
+
+    def __get_path_to_sai_file(self):
+        """
+        Retrieve sai.profile path
+        Returns:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host.
+             Returns sai.proile path.
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+         check_sfp_status called from get_change_event,
+            this will return correct status of all 4 SFP ports if there is a change in any of them 
+        """
+    
+        start_time = time.time()
+        port = self.SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000) # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {} # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= self.SFP_PORT_START and port <=self.SFP_PORT_END):
+                    profile = sfputil_profiles[self._port_profile]
+                    port_index = port - 1 
+                    if  port_index in profile:
+                        # Mask off the bit corresponding to our port
+                        mask = (1 << port-SFP_PORT_START)
+                        if (changed_ports & mask):
+                                # ModPrsL is active high
+                                if reg_value & mask == 0:
+                                     port_change[port] = '1'
+                                else:
+                                     port_change[port] = '0'
+                    port += 1
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1) # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py
new file mode 100644
index 000000000..8c8541ea0
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py
@@ -0,0 +1,133 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/changelog b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/changelog
new file mode 100644
index 000000000..7ce3ed2d1
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/changelog
@@ -0,0 +1,4 @@
+sonic-platform-db98cx8540-16cd-db98cx8540 (1.0) unstable; urgency=low
+
+  * Add support for sonic-platform-db98cx8540-16cd
+ -- Marvell  Wed, 15 Apr 2020 09:35:58 +0800
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/compat b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/control b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/control
new file mode 100644
index 000000000..2deaceb05
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-db98cx8540-16cd-db98cx8540
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-db98cx8540-16cd-db98cx8540
+Architecture: amd64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/files b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/files
new file mode 100644
index 000000000..b086c81d8
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/files
@@ -0,0 +1,2 @@
+sonic-platform-db98cx8540-16cd-db98cx8540_1.0_amd64.buildinfo unknown optional
+sonic-platform-db98cx8540-16cd-db98cx8540_1.0_amd64.deb unknown optional
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/rules b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/rules
new file mode 100644
index 000000000..d86c27795
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/rules
@@ -0,0 +1,66 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-db98cx8540-16cd
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= db98cx8540
+UTILS_DIR := utils
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python2,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		python2 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		python2 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install
new file mode 100644
index 000000000..46be26fbb
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install
@@ -0,0 +1,5 @@
+db98cx8540/scripts/db98cx8540-16cd-init.sh  usr/local/bin
+db98cx8540/service/db98cx8540-16cd-init.service etc/systemd/system
+db98cx8540/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/x86_64-marvell_db98cx8540_16cd-r0
+
+
diff --git a/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst
new file mode 100644
index 000000000..1ae6cdcf2
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst
@@ -0,0 +1,10 @@
+#!/bin/sh
+# postinst script for sonic-platform-db98cx8540-16cd
+#
+# see: dh_installdeb(1)
+
+chmod a+x /usr/local/bin/db98cx8540-16cd-init.sh
+systemctl enable db98cx8540-16cd-init.service
+systemctl start db98cx8540-16cd-init.service
+exit 0
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh
new file mode 100644
index 000000000..2851b2e57
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+# Platform init script for db98cx8580-32cd 
+
+
+# - Main entry
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-2/new_device
+
+exit 0
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service
new file mode 100644
index 000000000..f4a194eba
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Platform db98cx8580-32cd Service
+Before=pmon.service
+After=sysinit.target
+DefaultDependencies=no
+
+[Service]
+ExecStart=/usr/local/bin/db98cx8580-32cd-init.sh
+KillSignal=SIGKILL
+SuccessExitStatus=SIGKILL
+#StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py
new file mode 100644
index 000000000..e48d2e160
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'db98cx8580/sonic_platform'},
+)
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py
new file mode 100644
index 000000000..f90f8cdb4
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py
@@ -0,0 +1,382 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_platform.component import Component
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_COMPONENT=2
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 0
+COPPER_PORT_END = 0
+SFP_PORT_START = 1
+SFP_PORT_END = 257
+PORT_END = 257
+
+
+
+
+
+profile_32x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x72,4", 129:"0x72,4", 130:"0x72,4", 131:"0x72,4", 132:"0x72,4", 133:"0x72,4", 134:"0x72,4", 135:"0x72,4",
+136:"0x72,5", 137:"0x72,5", 138:"0x72,5", 139:"0x72,5", 140:"0x72,5", 141:"0x72,5", 142:"0x72,5", 143:"0x72,5",
+144:"0x72,6", 145:"0x72,6", 146:"0x72,6", 147:"0x72,6", 148:"0x72,6", 149:"0x72,6", 150:"0x72,6", 151:"0x72,6",
+152:"0x72,7", 153:"0x72,7", 154:"0x72,7", 155:"0x72,7", 156:"0x72,7", 157:"0x72,7", 158:"0x72,7", 159:"0x72,7",
+160:"0x72,0", 161:"0x72,0", 162:"0x72,0", 163:"0x72,0", 164:"0x72,0", 165:"0x72,0", 166:"0x72,0", 167:"0x72,0",
+168:"0x72,1", 169:"0x72,1", 170:"0x72,1", 171:"0x72,1", 172:"0x72,1", 173:"0x72,1", 174:"0x72,1", 175:"0x72,1",
+176:"0x72,2", 177:"0x72,2", 178:"0x72,2", 179:"0x72,2", 180:"0x72,2", 181:"0x72,2", 182:"0x72,2", 183:"0x72,2",
+184:"0x72,3", 185:"0x72,3", 186:"0x72,3", 187:"0x72,3", 188:"0x72,3", 189:"0x72,3", 190:"0x72,3", 191:"0x72,3",
+192:"0x73,4", 193:"0x73,4", 194:"0x73,4", 195:"0x73,4", 196:"0x73,4", 197:"0x73,4", 198:"0x73,4", 199:"0x73,4",
+200:"0x73,5", 201:"0x73,5", 202:"0x73,5", 203:"0x73,5", 204:"0x73,5", 205:"0x73,5", 206:"0x73,5", 207:"0x73,5",
+208:"0x73,6", 209:"0x73,6", 210:"0x73,6", 211:"0x73,6", 212:"0x73,6", 213:"0x73,6", 214:"0x73,6", 215:"0x73,6",
+216:"0x73,7", 217:"0x73,7", 218:"0x73,7", 219:"0x73,7", 220:"0x73,7", 221:"0x73,7", 222:"0x73,7", 223:"0x73,7",
+224:"0x73,0", 225:"0x73,0", 226:"0x73,0", 227:"0x73,0", 228:"0x73,0", 229:"0x73,0", 230:"0x73,0", 231:"0x73,0",
+232:"0x73,1", 233:"0x73,1", 234:"0x73,1", 235:"0x73,1", 236:"0x73,1", 237:"0x73,1", 238:"0x73,1", 239:"0x73,1",
+240:"0x73,2", 241:"0x73,2", 242:"0x73,2", 243:"0x73,2", 244:"0x73,2", 245:"0x73,2", 246:"0x73,2", 247:"0x73,2",
+248:"0x73,3", 249:"0x73,3", 250:"0x73,3", 251:"0x73,3", 252:"0x73,3", 253:"0x73,3", 254:"0x73,3", 255:"0x73,3",
+256:"0x74,4" }
+
+
+profile_128x10G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x72,4",  65:"0x72,4",  66:"0x72,4",  67:"0x72,4",  68:"0x72,5",  69:"0x72,5",  70:"0x72,5",  71:"0x72,5",
+ 72:"0x72,6",  73:"0x72,6",  74:"0x72,6",  75:"0x72,6",  76:"0x72,7",  77:"0x72,7",  78:"0x72,7",  79:"0x72,7",
+ 80:"0x72,0",  81:"0x72,0",  82:"0x72,0",  83:"0x72,0",  84:"0x72,1",  85:"0x72,1",  86:"0x72,1",  87:"0x72,1",
+ 88:"0x72,2",  89:"0x72,2",  90:"0x72,2",  91:"0x72,2",  92:"0x72,3",  93:"0x72,3",  94:"0x72,3",  95:"0x72,3",
+ 96:"0x73,4",  97:"0x73,4",  98:"0x73,4",  99:"0x73,4", 100:"0x73,5", 101:"0x73,5", 102:"0x73,5", 103:"0x73,5",
+104:"0x73,6", 105:"0x73,6", 106:"0x73,6", 107:"0x73,6", 108:"0x73,7", 109:"0x73,7", 110:"0x73,7", 111:"0x73,7",
+112:"0x73,0", 113:"0x73,0", 114:"0x73,0", 115:"0x73,0", 116:"0x73,1", 117:"0x73,1", 118:"0x73,1", 119:"0x73,1",
+120:"0x73,2", 121:"0x73,2", 122:"0x73,2", 123:"0x73,2", 124:"0x73,3", 125:"0x73,3", 126:"0x73,3", 127:"0x73,3",
+128:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_32x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+32:"0x74,4" }
+
+profile_24x25G_8x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x73,0",  41:"0x73,0",  42:"0x73,0",  43:"0x73,0",  44:"0x73,1",  45:"0x73,1",  46:"0x73,1",  47:"0x73,1",
+48:"0x73,2",  49:"0x73,2",  50:"0x73,2",  51:"0x73,2",  52:"0x73,3",  53:"0x73,3",  54:"0x73,3",  55:"0x73,3",
+56:"0x74,4" }
+
+profile_24x25G_4x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x74,4" }
+
+sfputil_profiles = {
+ "FALCON32X25G":profile_32x25G,
+ "FC32x25GIXIA":profile_32x25G_ixia,
+ "FALCON32x400G":profile_32x400G,
+ "FALCON128x100G":profile_32x400G,
+ "FALCON64x100GR4":profile_32x400G,
+ "FC32x10016x400G":profile_32x400G,
+ "FC48x100G8x400G":profile_32x400G,
+ "FC96x100G8x400G":profile_32x400G,
+ "FALCON128x10G":profile_128x10G,
+ "FALCON128x25G":profile_128x10G,
+ "FC64x25G64x10G":profile_128x10G,
+ "FC24x25G4x200G":profile_24x25G_4x200G,
+ "FC24x25G8x200G":profile_24x25G_8x200G,
+ "FALCONEBOF":profile_24x25G_8x200G
+}
+
+
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    HWSKU = "db98cx8580_32cd"
+
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        # Port numbers for Initialize SFP list
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        sai_profile_path=self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+        eeprom_path = '/sys/bus/i2c/devices/2-0050/eeprom'
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            profile = sfputil_profiles[self._port_profile]
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            if port in profile:
+                sfp_node = Sfp(index, 'QSFP', port_eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+
+    def __get_path_to_sai_profile_file(self):
+
+        """
+        Retrieve sai.profile path.
+        Return:
+            get_path_to_platform_dir() : get platform path, whether we're running on container or on the host
+            Return path to  sai.profile
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        #lrr = self._get_cpld_register('mb_reboot_cause')
+        #if (lrr != 'ERR'):
+        #    reset_reason = lrr
+        #    if (reset_reason in self.reset_reason_dict):
+        #        return (self.reset_reason_dict[reset_reason], None)
+        #
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py
new file mode 100644
index 000000000..ae0a76411
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py
@@ -0,0 +1,91 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["BIOS", "BIOS - Basic Input/Output System"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+        if self.index == 0:
+            cmdstatus, bios_version = cmd.getstatusoutput('dmidecode -s bios-version')
+            return bios_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py
new file mode 100644
index 000000000..a6f6bea17
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py
@@ -0,0 +1,237 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Serial number, Part number, Service Tag,
+#                PSU type, Revision.
+# - Fan EEPROM : Contains Serial number, Part number, Service Tag,
+#                Fan type, Number of Fans in Fantray, Revision.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = "/etc/sonic/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 6
+                #self.eeprom_path = self.I2C_DIR \
+                #    + "i2c-3{0}/3{0}-0056/eeprom".format(self.index - 1)
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(2 - self.index)
+                self.format = psu_eeprom_format
+            else:
+                self.index = fan_index
+                self.start_offset = 13
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-4{0}/4{0}-0050/eeprom".format(self.index - 1)
+                self.format = fan_eeprom_format
+            EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                   self.start_offset, '', True)
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and retrieves the serial number and
+        model number of the device.
+        """
+        try:
+            # Read Fan/PSU EEPROM as per the specified format.
+            self.eeprom_data = EepromDecoder.read_eeprom(self)
+        except Exception as e:
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+        else:
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data
+            else:
+                self.model_str = 'NA'
+
+            (valid, data) = self._get_eeprom_field("Serial Number")
+            if valid:
+                self.serial_number = data
+            else:
+                self.serial_number = 'NA'
+
+            if self.is_psu_eeprom:
+                (valid, data) = self._get_eeprom_field("PSU Type")
+                if valid:
+                    self.psu_type = data
+                else:
+                    self.psu_type = 'NA'
+            else:
+                (valid, data) = self._get_eeprom_field("Fan Type")
+                if valid:
+                    self.fan_type = data
+                else:
+                    self.fan_type = 'NA'
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py
new file mode 100644
index 000000000..588158b41
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py
@@ -0,0 +1,1445 @@
+#!/usr/bin/env python
+import os
+import time
+from ctypes import create_string_buffer
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom
+    from sonic_platform_base.sonic_sfp.inf8628 import inf8628InterfaceId
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+
+profile_32x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x72,4", 129:"0x72,4", 130:"0x72,4", 131:"0x72,4", 132:"0x72,4", 133:"0x72,4", 134:"0x72,4", 135:"0x72,4",
+136:"0x72,5", 137:"0x72,5", 138:"0x72,5", 139:"0x72,5", 140:"0x72,5", 141:"0x72,5", 142:"0x72,5", 143:"0x72,5",
+144:"0x72,6", 145:"0x72,6", 146:"0x72,6", 147:"0x72,6", 148:"0x72,6", 149:"0x72,6", 150:"0x72,6", 151:"0x72,6",
+152:"0x72,7", 153:"0x72,7", 154:"0x72,7", 155:"0x72,7", 156:"0x72,7", 157:"0x72,7", 158:"0x72,7", 159:"0x72,7",
+160:"0x72,0", 161:"0x72,0", 162:"0x72,0", 163:"0x72,0", 164:"0x72,0", 165:"0x72,0", 166:"0x72,0", 167:"0x72,0",
+168:"0x72,1", 169:"0x72,1", 170:"0x72,1", 171:"0x72,1", 172:"0x72,1", 173:"0x72,1", 174:"0x72,1", 175:"0x72,1",
+176:"0x72,2", 177:"0x72,2", 178:"0x72,2", 179:"0x72,2", 180:"0x72,2", 181:"0x72,2", 182:"0x72,2", 183:"0x72,2",
+184:"0x72,3", 185:"0x72,3", 186:"0x72,3", 187:"0x72,3", 188:"0x72,3", 189:"0x72,3", 190:"0x72,3", 191:"0x72,3",
+192:"0x73,4", 193:"0x73,4", 194:"0x73,4", 195:"0x73,4", 196:"0x73,4", 197:"0x73,4", 198:"0x73,4", 199:"0x73,4",
+200:"0x73,5", 201:"0x73,5", 202:"0x73,5", 203:"0x73,5", 204:"0x73,5", 205:"0x73,5", 206:"0x73,5", 207:"0x73,5",
+208:"0x73,6", 209:"0x73,6", 210:"0x73,6", 211:"0x73,6", 212:"0x73,6", 213:"0x73,6", 214:"0x73,6", 215:"0x73,6",
+216:"0x73,7", 217:"0x73,7", 218:"0x73,7", 219:"0x73,7", 220:"0x73,7", 221:"0x73,7", 222:"0x73,7", 223:"0x73,7",
+224:"0x73,0", 225:"0x73,0", 226:"0x73,0", 227:"0x73,0", 228:"0x73,0", 229:"0x73,0", 230:"0x73,0", 231:"0x73,0",
+232:"0x73,1", 233:"0x73,1", 234:"0x73,1", 235:"0x73,1", 236:"0x73,1", 237:"0x73,1", 238:"0x73,1", 239:"0x73,1",
+240:"0x73,2", 241:"0x73,2", 242:"0x73,2", 243:"0x73,2", 244:"0x73,2", 245:"0x73,2", 246:"0x73,2", 247:"0x73,2",
+248:"0x73,3", 249:"0x73,3", 250:"0x73,3", 251:"0x73,3", 252:"0x73,3", 253:"0x73,3", 254:"0x73,3", 255:"0x73,3",
+256:"0x74,4" }
+
+
+profile_128x10G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x72,4",  65:"0x72,4",  66:"0x72,4",  67:"0x72,4",  68:"0x72,5",  69:"0x72,5",  70:"0x72,5",  71:"0x72,5",
+ 72:"0x72,6",  73:"0x72,6",  74:"0x72,6",  75:"0x72,6",  76:"0x72,7",  77:"0x72,7",  78:"0x72,7",  79:"0x72,7",
+ 80:"0x72,0",  81:"0x72,0",  82:"0x72,0",  83:"0x72,0",  84:"0x72,1",  85:"0x72,1",  86:"0x72,1",  87:"0x72,1",
+ 88:"0x72,2",  89:"0x72,2",  90:"0x72,2",  91:"0x72,2",  92:"0x72,3",  93:"0x72,3",  94:"0x72,3",  95:"0x72,3",
+ 96:"0x73,4",  97:"0x73,4",  98:"0x73,4",  99:"0x73,4", 100:"0x73,5", 101:"0x73,5", 102:"0x73,5", 103:"0x73,5",
+104:"0x73,6", 105:"0x73,6", 106:"0x73,6", 107:"0x73,6", 108:"0x73,7", 109:"0x73,7", 110:"0x73,7", 111:"0x73,7",
+112:"0x73,0", 113:"0x73,0", 114:"0x73,0", 115:"0x73,0", 116:"0x73,1", 117:"0x73,1", 118:"0x73,1", 119:"0x73,1",
+120:"0x73,2", 121:"0x73,2", 122:"0x73,2", 123:"0x73,2", 124:"0x73,3", 125:"0x73,3", 126:"0x73,3", 127:"0x73,3",
+128:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_32x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+32:"0x74,4" }
+
+profile_24x25G_8x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x73,0",  41:"0x73,0",  42:"0x73,0",  43:"0x73,0",  44:"0x73,1",  45:"0x73,1",  46:"0x73,1",  47:"0x73,1",
+48:"0x73,2",  49:"0x73,2",  50:"0x73,2",  51:"0x73,2",  52:"0x73,3",  53:"0x73,3",  54:"0x73,3",  55:"0x73,3",
+56:"0x74,4" }
+
+profile_24x25G_4x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x74,4" }
+
+sfputil_profiles = {
+ "FALCON32X25G":profile_32x25G,
+ "FC32x25GIXIA":profile_32x25G_ixia,
+ "FALCON32x400G":profile_32x400G,
+ "FALCON128x100G":profile_32x400G,
+ "FALCON64x100GR4":profile_32x400G,
+ "FC32x10016x400G":profile_32x400G,
+ "FC48x100G8x400G":profile_32x400G,
+ "FC96x100G8x400G":profile_32x400G,
+ "FALCON128x10G":profile_128x10G,
+ "FALCON128x25G":profile_128x10G,
+ "FC64x25G64x10G":profile_128x10G,
+ "FC24x25G4x200G":profile_24x25G_4x200G,
+ "FC24x25G8x200G":profile_24x25G_8x200G,
+ "FALCONEBOF":profile_24x25G_8x200G
+}
+
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+XCVR_INTFACE_BULK_WIDTH_QSFP = 20
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+XCVR_CABLE_LENGTH_WIDTH_QSFP = 5
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+XCVR_HW_REV_WIDTH_OSFP = 2
+XCVR_HW_REV_WIDTH_QSFP = 2
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+QSFP_DOM_BULK_DATA_START = 22
+QSFP_DOM_BULK_DATA_SIZE = 36
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+# definitions of the offset for values in OSFP info eeprom
+OSFP_TYPE_OFFSET = 0
+OSFP_VENDOR_NAME_OFFSET = 129
+OSFP_VENDOR_PN_OFFSET = 148
+OSFP_HW_REV_OFFSET = 164
+OSFP_VENDOR_SN_OFFSET = 166
+
+# Offset for values in QSFP eeprom
+QSFP_DOM_REV_OFFSET = 1
+QSFP_DOM_REV_WIDTH = 1
+QSFP_TEMPE_OFFSET = 22
+QSFP_TEMPE_WIDTH = 2
+QSFP_VOLT_OFFSET = 26
+QSFP_VOLT_WIDTH = 2
+QSFP_VERSION_COMPLIANCE_OFFSET = 1
+QSFP_VERSION_COMPLIANCE_WIDTH = 2
+QSFP_CHANNL_MON_OFFSET = 34
+QSFP_CHANNL_MON_WIDTH = 16
+QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH = 24
+QSFP_CHANNL_DISABLE_STATUS_OFFSET = 86
+QSFP_CHANNL_DISABLE_STATUS_WIDTH = 1
+QSFP_CHANNL_RX_LOS_STATUS_OFFSET = 3
+QSFP_CHANNL_RX_LOS_STATUS_WIDTH = 1
+QSFP_CHANNL_TX_FAULT_STATUS_OFFSET = 4
+QSFP_CHANNL_TX_FAULT_STATUS_WIDTH = 1
+QSFP_CONTROL_OFFSET = 86
+QSFP_CONTROL_WIDTH = 8
+QSFP_MODULE_MONITOR_OFFSET = 0
+QSFP_MODULE_MONITOR_WIDTH = 9
+QSFP_POWEROVERRIDE_OFFSET = 93
+QSFP_POWEROVERRIDE_WIDTH = 1
+QSFP_POWEROVERRIDE_BIT = 0
+QSFP_POWERSET_BIT = 1
+QSFP_OPTION_VALUE_OFFSET = 192
+QSFP_OPTION_VALUE_WIDTH = 4
+QSFP_MODULE_UPPER_PAGE3_START = 384
+QSFP_MODULE_THRESHOLD_OFFSET = 128
+QSFP_MODULE_THRESHOLD_WIDTH = 24
+QSFP_CHANNL_THRESHOLD_OFFSET = 176
+QSFP_CHANNL_THRESHOLD_WIDTH = 24
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+
+qsfp_cable_length_tup = ('Length(km)', 'Length OM3(2m)',
+                         'Length OM2(m)', 'Length OM1(m)',
+                         'Length Cable Assembly(m)')
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+qsfp_compliance_code_tup = ('10/40G Ethernet Compliance Code', 'SONET Compliance codes',
+                            'SAS/SATA compliance codes', 'Gigabit Ethernet Compliant codes',
+                            'Fibre Channel link length/Transmitter Technology',
+                            'Fibre Channel transmission media', 'Fibre Channel Speed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+QSFP_TYPE = "QSFP"
+OSFP_TYPE = "OSFP"
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class Sfp(SfpBase):
+    HWSKU = "db98cx8580_32cd"
+    _port_start = 1
+    _port_end = 257
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+        self.port_to_eeprom_mapping[index] = eeprom_path
+        sai_profile_path = self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path  + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+        self._dom_capability_detect()
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+                cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+                os.system(cmd)
+        else:
+                bus = smbus.SMBus(2)
+                bus.write_byte_data(device_addr, offset, value)
+
+    def __get_path_to_port_config_file(self):
+        """
+        Retrieve port_config.ini
+        Return:
+             get_path_to_platform_dir() : get platform path, whether we're running on container or on the host
+             Return path to port_config.ini
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "port_config.ini"])
+
+    def __get_path_to_sai_profile_file(self):
+        """
+        Retrieve Platform path to read sai.profile
+        Return:
+             get_path_to_platform_dir() : get platform path, whether we're running on container or on the host
+             Return path to  sai.profile
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == COPPER_TYPE:
+            return
+
+        if self.sfp_type == "QSFP":
+            self.calibration = 1
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                self.dom_supported = False
+            offset = 128
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                (offset + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qsfp_version_compliance_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_VERSION_COMPLIANCE_OFFSET, QSFP_VERSION_COMPLIANCE_WIDTH)
+                qsfp_version_compliance = int(
+                    qsfp_version_compliance_raw[0], 16)
+                dom_capability = sfpi_obj.parse_dom_capability(
+                    qsfp_dom_capability_raw, 0)
+                if qsfp_version_compliance >= 0x08:
+                    self.dom_temp_supported = dom_capability['data']['Temp_support']['value'] == 'On'
+                    self.dom_volt_supported = dom_capability['data']['Voltage_support']['value'] == 'On'
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = dom_capability['data']['Tx_power_support']['value'] == 'On'
+                else:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = True
+
+                self.dom_supported = True
+                self.calibration = 1
+                sfpd_obj = sff8436Dom()
+                if sfpd_obj is None:
+                    return None
+                qsfp_option_value_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_OPTION_VALUE_OFFSET, QSFP_OPTION_VALUE_WIDTH)
+                if qsfp_option_value_raw is not None:
+                    optional_capability = sfpd_obj.parse_option_params(
+                        qsfp_option_value_raw, 0)
+                    self.dom_tx_disable_supported = optional_capability[
+                        'data']['TxDisable']['value'] == 'On'
+                dom_status_indicator = sfpd_obj.parse_dom_status_indicator(
+                    qsfp_version_compliance_raw, 1)
+                self.qsfp_page3_available = dom_status_indicator['data']['FlatMem']['value'] == 'Off'
+            else:
+                self.dom_supported = False
+                self.dom_temp_supported = False
+                self.dom_volt_supported = False
+                self.dom_rx_power_supported = False
+                self.dom_tx_power_supported = False
+                self.calibration = 0
+                self.qsfp_page3_available = False
+
+        elif self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if self.sfp_type == OSFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            sfp_type_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                    sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                    sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                    sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                    sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if self.sfp_type == QSFP_TYPE:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+            if self.sfp_type == QSFP_TYPE:
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 0
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_DOM_BULK_DATA_START), QSFP_DOM_BULK_DATA_SIZE)
+
+            if dom_data_raw is None:
+                return transceiver_dom_info_dict
+
+            if self.dom_temp_supported:
+                start = QSFP_TEMPE_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_TEMPE_WIDTH
+                dom_temperature_data = sfpd_obj.parse_temperature(
+                    dom_data_raw[start: end], 0)
+                temp = self.__convert_string_to_num(
+                    dom_temperature_data['data']['Temperature']['value'])
+                if temp is not None:
+                    transceiver_dom_info_dict['temperature'] = temp
+
+            if self.dom_volt_supported:
+                start = QSFP_VOLT_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_VOLT_WIDTH
+                dom_voltage_data = sfpd_obj.parse_voltage(
+                    dom_data_raw[start: end], 0)
+                volt = self.__convert_string_to_num(
+                    dom_voltage_data['data']['Vcc']['value'])
+                if volt is not None:
+                    transceiver_dom_info_dict['voltage'] = volt
+
+            start = QSFP_CHANNL_MON_OFFSET - QSFP_DOM_BULK_DATA_START
+            end = start + QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                dom_data_raw[start: end], 0)
+
+            if self.dom_tx_power_supported:
+                transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX1Power']['value'])
+                transceiver_dom_info_dict['tx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX2Power']['value'])
+                transceiver_dom_info_dict['tx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX3Power']['value'])
+                transceiver_dom_info_dict['tx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX4Power']['value'])
+
+            if self.dom_rx_power_supported:
+                transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX1Power']['value'])
+                transceiver_dom_info_dict['rx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX2Power']['value'])
+                transceiver_dom_info_dict['rx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX3Power']['value'])
+                transceiver_dom_info_dict['rx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX4Power']['value'])
+
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported or not self.qsfp_page3_available:
+                return transceiver_dom_threshold_info_dict
+
+            # Dom Threshold data starts from offset 384
+            # Revert offset back to 0 once data is retrieved
+            offset = QSFP_MODULE_UPPER_PAGE3_START
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_THRESHOLD_OFFSET), QSFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_data = sfpd_obj.parse_module_threshold_values(
+                dom_module_threshold_raw, 0)
+
+            dom_channel_threshold_raw = self.__read_eeprom_specific_bytes((offset + QSFP_CHANNL_THRESHOLD_OFFSET),
+                                                                          QSFP_CHANNL_THRESHOLD_WIDTH)
+            if dom_channel_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+            dom_channel_threshold_data = sfpd_obj.parse_channel_threshold_values(
+                dom_channel_threshold_raw, 0)
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VccHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VccHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VccLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VccLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_channel_threshold_data['data']['RxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_channel_threshold_data['data']['RxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_channel_threshold_data['data']['RxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_channel_threshold_data['data']['RxPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_channel_threshold_data['data']['TxBiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_channel_threshold_data['data']['TxBiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_channel_threshold_data['data']['TxBiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_channel_threshold_data['data']['TxBiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_channel_threshold_data['data']['TxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_channel_threshold_data['data']['TxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_channel_threshold_data['data']['TxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_channel_threshold_data['data']['TxPowerLowWarning']['value']
+
+        else:
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == OSFP_TYPE:
+            return False
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+            dom_module_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_MONITOR_OFFSET), QSFP_MODULE_MONITOR_WIDTH)
+
+            if dom_module_monitor_raw is not None:
+                return True
+            else:
+                return False
+        elif self.sfp_type == SFP_TYPE:
+            offset = 0
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        return False
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        return False
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+        return False
+ 
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == QSFP_TYPE:
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return False
+
+            dom_control_raw = self.__read_eeprom_specific_bytes(
+                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None
+            if dom_control_raw is not None:
+                dom_control_data = sfpd_obj.parse_control_bytes(
+                    dom_control_raw, 0)
+                return ('On' == dom_control_data['data']['PowerOverride']['value'])
+        else:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+            A list of four integer numbers, representing TX bias in mA
+            for channel 0 to channel 4.
+            Ex. ['110.09', '111.12', '108.21', '112.09']
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx1_bs = transceiver_bulk_status.get("tx1bias", "N/A")
+        tx2_bs = transceiver_bulk_status.get("tx2bias", "N/A")
+        tx3_bs = transceiver_bulk_status.get("tx3bias", "N/A")
+        tx4_bs = transceiver_bulk_status.get("tx4bias", "N/A")
+        tx_bias_list = [tx1_bs, tx2_bs, tx3_bs, tx4_bs]
+        return tx_bias_list
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_rx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX1Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX2Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX3Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_tx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX1Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX2Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX3Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP and return all user module settings to their default srate.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        # Check for invalid port_num
+        if self.port_num < self._port_start or self.port_num > self._port_end:
+            return False
+        port_ps = "/sys/bus/i2c/devices/2-0050/sfp_port_reset"
+        try:
+            reg_file = open(port_ps, 'w')
+        except IOError as e:
+            print(e)
+            return False
+
+        #toggle reset
+        reg_file.seek(0)
+        reg_file.write('1')
+        time.sleep(1)
+        reg_file.seek(0)
+        reg_file.write('0')
+        reg_file.close()
+        return True
+
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX for all channels
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                tx_disable_ctl = 0xf if tx_disable else 0x0
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                channel_state = self.get_tx_disable_channel()
+                tx_enable_mask = [0xe, 0xd, 0xb, 0x7]
+                tx_disable_mask = [0x1, 0x3, 0x7, 0xf]
+                tx_disable_ctl = channel_state | tx_disable_mask[
+                    channel] if disable else channel_state & tx_enable_mask[channel]
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            try:
+                power_override_bit = 0
+                if power_override:
+                    power_override_bit |= 1 << 0
+
+                power_set_bit = 0
+                if power_set:
+                    power_set_bit |= 1 << 1
+
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(power_override_bit | power_set_bit)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_POWEROVERRIDE_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+        self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        port_index = self.port_num-1
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+        profile = sfputil_profiles[self._port_profile]
+        if  port_index not in profile:
+            return False
+        else:
+            offset = int(profile[port_index].split(",")[1])
+            bin_offset = 1<<offset
+            device_reg = int(profile[port_index].split(",")[0],16)
+            self.i2c_set(device_reg, 0, bin_offset)
+            try:
+                reg_file = open(sysfs_sfp_i2c_client_eeprom_path, 'rb')
+                reg_file.seek(1)
+                reg_file.read(2)
+            except IOError as e:
+                return False
+
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..598cbe632
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py
@@ -0,0 +1,269 @@
+#!/usr/bin/env python
+'''
+listen to the SDK for the SFP change event and return to chassis.
+'''
+
+from __future__ import print_function
+import os
+import time
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+
+profile_32x400G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x72,4", 129:"0x72,4", 130:"0x72,4", 131:"0x72,4", 132:"0x72,4", 133:"0x72,4", 134:"0x72,4", 135:"0x72,4",
+136:"0x72,5", 137:"0x72,5", 138:"0x72,5", 139:"0x72,5", 140:"0x72,5", 141:"0x72,5", 142:"0x72,5", 143:"0x72,5",
+144:"0x72,6", 145:"0x72,6", 146:"0x72,6", 147:"0x72,6", 148:"0x72,6", 149:"0x72,6", 150:"0x72,6", 151:"0x72,6",
+152:"0x72,7", 153:"0x72,7", 154:"0x72,7", 155:"0x72,7", 156:"0x72,7", 157:"0x72,7", 158:"0x72,7", 159:"0x72,7",
+160:"0x72,0", 161:"0x72,0", 162:"0x72,0", 163:"0x72,0", 164:"0x72,0", 165:"0x72,0", 166:"0x72,0", 167:"0x72,0",
+168:"0x72,1", 169:"0x72,1", 170:"0x72,1", 171:"0x72,1", 172:"0x72,1", 173:"0x72,1", 174:"0x72,1", 175:"0x72,1",
+176:"0x72,2", 177:"0x72,2", 178:"0x72,2", 179:"0x72,2", 180:"0x72,2", 181:"0x72,2", 182:"0x72,2", 183:"0x72,2",
+184:"0x72,3", 185:"0x72,3", 186:"0x72,3", 187:"0x72,3", 188:"0x72,3", 189:"0x72,3", 190:"0x72,3", 191:"0x72,3",
+192:"0x73,4", 193:"0x73,4", 194:"0x73,4", 195:"0x73,4", 196:"0x73,4", 197:"0x73,4", 198:"0x73,4", 199:"0x73,4",
+200:"0x73,5", 201:"0x73,5", 202:"0x73,5", 203:"0x73,5", 204:"0x73,5", 205:"0x73,5", 206:"0x73,5", 207:"0x73,5",
+208:"0x73,6", 209:"0x73,6", 210:"0x73,6", 211:"0x73,6", 212:"0x73,6", 213:"0x73,6", 214:"0x73,6", 215:"0x73,6",
+216:"0x73,7", 217:"0x73,7", 218:"0x73,7", 219:"0x73,7", 220:"0x73,7", 221:"0x73,7", 222:"0x73,7", 223:"0x73,7",
+224:"0x73,0", 225:"0x73,0", 226:"0x73,0", 227:"0x73,0", 228:"0x73,0", 229:"0x73,0", 230:"0x73,0", 231:"0x73,0",
+232:"0x73,1", 233:"0x73,1", 234:"0x73,1", 235:"0x73,1", 236:"0x73,1", 237:"0x73,1", 238:"0x73,1", 239:"0x73,1",
+240:"0x73,2", 241:"0x73,2", 242:"0x73,2", 243:"0x73,2", 244:"0x73,2", 245:"0x73,2", 246:"0x73,2", 247:"0x73,2",
+248:"0x73,3", 249:"0x73,3", 250:"0x73,3", 251:"0x73,3", 252:"0x73,3", 253:"0x73,3", 254:"0x73,3", 255:"0x73,3",
+256:"0x74,4" }
+
+
+profile_128x10G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,0",  50:"0x71,0",  51:"0x71,0",  52:"0x71,1",  53:"0x71,1",  54:"0x71,1",  55:"0x71,1",
+ 56:"0x71,2",  57:"0x71,2",  58:"0x71,2",  59:"0x71,2",  60:"0x71,3",  61:"0x71,3",  62:"0x71,3",  63:"0x71,3",
+ 64:"0x72,4",  65:"0x72,4",  66:"0x72,4",  67:"0x72,4",  68:"0x72,5",  69:"0x72,5",  70:"0x72,5",  71:"0x72,5",
+ 72:"0x72,6",  73:"0x72,6",  74:"0x72,6",  75:"0x72,6",  76:"0x72,7",  77:"0x72,7",  78:"0x72,7",  79:"0x72,7",
+ 80:"0x72,0",  81:"0x72,0",  82:"0x72,0",  83:"0x72,0",  84:"0x72,1",  85:"0x72,1",  86:"0x72,1",  87:"0x72,1",
+ 88:"0x72,2",  89:"0x72,2",  90:"0x72,2",  91:"0x72,2",  92:"0x72,3",  93:"0x72,3",  94:"0x72,3",  95:"0x72,3",
+ 96:"0x73,4",  97:"0x73,4",  98:"0x73,4",  99:"0x73,4", 100:"0x73,5", 101:"0x73,5", 102:"0x73,5", 103:"0x73,5",
+104:"0x73,6", 105:"0x73,6", 106:"0x73,6", 107:"0x73,6", 108:"0x73,7", 109:"0x73,7", 110:"0x73,7", 111:"0x73,7",
+112:"0x73,0", 113:"0x73,0", 114:"0x73,0", 115:"0x73,0", 116:"0x73,1", 117:"0x73,1", 118:"0x73,1", 119:"0x73,1",
+120:"0x73,2", 121:"0x73,2", 122:"0x73,2", 123:"0x73,2", 124:"0x73,3", 125:"0x73,3", 126:"0x73,3", 127:"0x73,3",
+128:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_32x25G_ixia = {
+ 0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+ 8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+32:"0x74,4" }
+
+profile_24x25G_8x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x73,0",  41:"0x73,0",  42:"0x73,0",  43:"0x73,0",  44:"0x73,1",  45:"0x73,1",  46:"0x73,1",  47:"0x73,1",
+48:"0x73,2",  49:"0x73,2",  50:"0x73,2",  51:"0x73,2",  52:"0x73,3",  53:"0x73,3",  54:"0x73,3",  55:"0x73,3",
+56:"0x74,4" }
+
+profile_24x25G_4x200G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,4",  26:"0x73,4",  27:"0x73,4",  28:"0x73,5",  29:"0x73,5",  30:"0x73,5",  31:"0x73,5",
+32:"0x73,6",  33:"0x73,6",  34:"0x73,6",  35:"0x73,6",  36:"0x73,7",  37:"0x73,7",  38:"0x73,7",  39:"0x73,7",
+40:"0x74,4" }
+
+sfputil_profiles = {
+ "FALCON32X25G":profile_32x25G,
+ "FC32x25GIXIA":profile_32x25G_ixia,
+ "FALCON32x400G":profile_32x400G,
+ "FALCON128x100G":profile_32x400G,
+ "FALCON64x100GR4":profile_32x400G,
+ "FC32x10016x400G":profile_32x400G,
+ "FC48x100G8x400G":profile_32x400G,
+ "FC96x100G8x400G":profile_32x400G,
+ "FALCON128x10G":profile_128x10G,
+ "FALCON128x25G":profile_128x10G,
+ "FC64x25G64x10G":profile_128x10G,
+ "FC24x25G4x200G":profile_24x25G_4x200G,
+ "FC24x25G8x200G":profile_24x25G_8x200G,
+ "FALCONEBOF":profile_24x25G_8x200G
+}
+
+
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+
+# SFP PORT numbers
+SFP_PORT_START = 1
+SFP_PORT_END = 257
+
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+    HWSKU = "db98cx8580_32cd"
+    def __init__(self):
+        
+        self.handle = None
+        self.port_to_eeprom_mapping = {}
+        self.SFP_PORT_START=SFP_PORT_START
+        self.SFP_PORT_END=SFP_PORT_END
+
+        eeprom_path="/sys/bus/i2c/devices/2-0050/eeprom"
+
+        x = self.SFP_PORT_START
+        while(x<self.SFP_PORT_END+1):
+            self.port_to_eeprom_mapping[x] = eeprom_path
+            x = x + 1
+        path=self.__get_path_to_sai_file()
+        cmd = "cat " + path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+ 
+    def initialize(self):       
+        self.modprs_register = 0 
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+            cmd = "i2cset -y 2 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+            os.system(cmd)
+        else:
+            bus = smbus.SMBus(2)
+            bus.write_byte_data(device_addr, offset, value)
+      
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+        sfp_status = 0
+        x = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+                port_index = index-1
+                profile = sfputil_profiles[self._port_profile]
+                if  port_index in profile:
+                        offset = int(profile[port_index].split(",")[1])
+                        bin_offset = 1<<offset
+                        device_reg = int(profile[port_index].split(",")[0],16)
+                        self.i2c_set(device_reg, 0, bin_offset)
+                        path = "/sys/bus/i2c/devices/2-0050/eeprom"
+                        try:
+                                reg_file = open(path, 'rb')
+                                reg_file.seek(1)
+                                reg_file.read(2)
+                                sfp_status=( x | (1<<index-self.SFP_PORT_START)) + sfp_status
+                        except IOError as e:
+                                sfp_status=( x & ~(1<<index-self.SFP_PORT_START)) + sfp_status
+
+        sfp_status = ~sfp_status
+        return sfp_status
+
+    def __get_path_to_sai_file(self):
+        """
+        Retrieve sai.profile path
+        Return:
+             get_path_to_platform_dir() : get platform path depend on, whether we're running on container or on the host
+             Return path to  sai.profile
+        """
+        from sonic_py_common import device_info
+        platform_path = device_info.get_path_to_platform_dir()
+        hwsku_path = "/".join([platform_path, self.HWSKU])
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+         check_sfp_status called from get_change_event,
+            this will return correct status of all 4 SFP ports if there is a change in any of them 
+        """
+    
+        start_time = time.time()
+        port = self.SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000) # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {} # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= self.SFP_PORT_START and port <=self.SFP_PORT_END):
+                    profile = sfputil_profiles[self._port_profile]
+                    port_index = port - 1 
+                    if  port_index in profile:
+                        # Mask off the bit corresponding to our port
+                        mask = (1 << port-SFP_PORT_START)
+                        if (changed_ports & mask):
+                                # ModPrsL is active high
+                                if reg_value & mask == 0:
+                                     port_change[port] = '1'
+                                else:
+                                     port_change[port] = '0'
+                    port += 1
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1) # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py
new file mode 100644
index 000000000..8c8541ea0
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py
@@ -0,0 +1,133 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/changelog b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/changelog
new file mode 100644
index 000000000..fecd769ea
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/changelog
@@ -0,0 +1,4 @@
+sonic-platform-db98cx8580-32cd-db98cx8580 (1.0) unstable; urgency=low
+
+  * Add support for sonic-platform-db98cx8580-32cd
+ -- Marvell  Wed, 15 Apr 2020 09:35:58 +0800
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/compat b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/control b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/control
new file mode 100644
index 000000000..2110b65e6
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-db98cx8580-32cd-db98cx8580
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-db98cx8580-32cd-db98cx8580
+Architecture: amd64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/files b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/files
new file mode 100644
index 000000000..bb5244514
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/files
@@ -0,0 +1,2 @@
+sonic-platform-db98cx8580-32cd-db98cx8580_1.0_amd64.buildinfo unknown optional
+sonic-platform-db98cx8580-32cd-db98cx8580_1.0_amd64.deb unknown optional
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/rules b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/rules
new file mode 100644
index 000000000..390808f3c
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/rules
@@ -0,0 +1,66 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-db98cx8580-32cd
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= db98cx8580
+UTILS_DIR := utils
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python2,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		python2 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		python2 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install
new file mode 100644
index 000000000..d8ba75860
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install
@@ -0,0 +1,5 @@
+db98cx8580/scripts/db98cx8580-32cd-init.sh  usr/local/bin
+db98cx8580/service/db98cx8580-32cd-init.service etc/systemd/system
+db98cx8580/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/x86_64-marvell_db98cx8580_32cd-r0
+
+
diff --git a/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst
new file mode 100644
index 000000000..ebabe733e
--- /dev/null
+++ b/platform/marvell/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst
@@ -0,0 +1,10 @@
+#!/bin/sh
+# postinst script for sonic-platform-db98cx8580-32cd
+#
+# see: dh_installdeb(1)
+
+chmod a+x /usr/local/bin/db98cx8580-32cd-init.sh
+systemctl enable db98cx8580-32cd-init.service
+systemctl start db98cx8580-32cd-init.service
+exit 0
+
