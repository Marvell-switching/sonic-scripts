From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Wed, 15 Mar 2023 10:55:59 +0530
Subject: [PATCH 1/3] Add patches for marvell-arm64 support

These are set of patches for supporting Marvells 98DX35xx series of
switching products.

Patches 0001 to 0012 are backport of upstream patches.

0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch
 - https://github.com/torvalds/linux/commit/d6c1b95d3df237d24394594b363809c01fc48330

0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch
 - https://github.com/torvalds/linux/commit/270a95966881f25c17590e9702860fd1101cfb66

0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch
 - https://github.com/torvalds/linux/commit/b795fadfc46bc497257435d4d9e57f487f521fd1

0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch
 - https://github.com/torvalds/linux/commit/31be791e26cf928695dba1477d62bbf55854931f

0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch
 - https://github.com/torvalds/linux/commit/2b14d382ec97ca5b420239ee6e16da390fab476c

0006-arm64-dts-Update-cache-properties-for-marvell.patch
 - https://github.com/torvalds/linux/commit/b5d971cf170e09fffc25b58b0de3cfdb0a1c342d

0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch
 - https://github.com/torvalds/linux/commit/80502ffab2fa92ba9777e381efea2efddc348d13

0008-mtd-rawnand-marvell-Add-missing-layouts.patch
 - https://github.com/torvalds/linux/commit/68c18dae68881054ed5426c00f0ed351b1db9bc0

0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch
 - https://github.com/torvalds/linux/commit/f8970fdc73173649d7615df50d73fd2117ea00ca

0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch
 - https://github.com/torvalds/linux/commit/8225663e0cd47a049267b9ef627d0b10f6bfc056

0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch
 - https://github.com/torvalds/linux/commit/2d2a514c1d61d8cbe00f22f27ff51623d3be89e6

0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch
 - https://github.com/torvalds/linux/commit/66bbf1441d218316948877f7ec6b477c9a49d554

0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch
 - Patch adds documentation for mmc and usb device tree properties.

0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch
 - Patch adds dts nodes for prestera switching, emmc and watchdog support.

0015-ac5-marvell-Add-watchdog-support.patch
 - Patch adds support for WD driver for ac5.
   WD registers are located in protected CPU area, which gets locked after
   bootrom runs. Therefore need to access them by using SMC, which was
   added in this driver.

0016-ac5-marvell-Add-support-for-emmc.patch
 - Patch adds eMMC support by adding compatible string.

0017-usb-ehci-Add-support-for-ac5.patch
 - Patch adds usb support by adding compatible string.

0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch
 - Patch fixes i2c bus lock issue due to lost arbitration from some i2c
   slaves, mainly SFPs.

Change-Id: I9eb90d25c91c62e9ff7eee54f403411caeccd43f
Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 ...ell-Document-the-AC5-AC5X-compatible.patch |  80 +++
 ...t-mvneta-Add-marvell-armada-ac5-neta.patch |  30 +
 ...l-Add-Armada-98DX2530-SoC-and-RD-AC5.patch | 467 ++++++++++++++++
 ...dts-marvell-Add-UART1-3-for-AC5-AC5X.patch |  57 ++
 ...vell-98dx25xx-Fix-i2c-gpios-property.patch |  43 ++
 ...-Update-cache-properties-for-marvell.patch |  88 +++
 ...rvell-AC5-AC5X-Fix-address-for-UART1.patch |  29 +
 ...-rawnand-marvell-Add-missing-layouts.patch |  44 ++
 ...rl-mvebu-Add-driver-for-98DX2530-SoC.patch | 313 +++++++++++
 ...l-Enable-the-98DX2530-pinctrl-driver.patch |  36 ++
 ...d-support-for-98DX2530-Ethernet-port.patch |  69 +++
 ...rt-big-endianness-for-AC5-SPI-driver.patch |  41 ++
 ...dings-ac5-Add-mmc-and-usb-properties.patch |  72 +++
 ...vell-Add-switching-mmc-watchdog-node.patch | 124 +++++
 ...015-ac5-marvell-Add-watchdog-support.patch | 524 ++++++++++++++++++
 ...016-ac5-marvell-Add-support-for-emmc.patch |  61 ++
 patch/0017-usb-ehci-Add-support-for-ac5.patch |  38 ++
 ...-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch | 169 ++++++
 patch/series                                  |  21 +-
 19 files changed, 2305 insertions(+), 1 deletion(-)
 create mode 100644 patch/0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch
 create mode 100644 patch/0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch
 create mode 100644 patch/0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch
 create mode 100644 patch/0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch
 create mode 100644 patch/0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch
 create mode 100644 patch/0006-arm64-dts-Update-cache-properties-for-marvell.patch
 create mode 100644 patch/0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch
 create mode 100644 patch/0008-mtd-rawnand-marvell-Add-missing-layouts.patch
 create mode 100644 patch/0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch
 create mode 100644 patch/0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch
 create mode 100644 patch/0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch
 create mode 100644 patch/0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch
 create mode 100644 patch/0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch
 create mode 100644 patch/0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch
 create mode 100644 patch/0015-ac5-marvell-Add-watchdog-support.patch
 create mode 100644 patch/0016-ac5-marvell-Add-support-for-emmc.patch
 create mode 100644 patch/0017-usb-ehci-Add-support-for-ac5.patch
 create mode 100644 patch/0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch

diff --git a/patch/0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch b/patch/0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch
new file mode 100644
index 000000000..879f3f76c
--- /dev/null
+++ b/patch/0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch
@@ -0,0 +1,80 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Tue, 5 Jul 2022 22:09:19 +0300
+dt-bindings: marvell: Document the AC5/AC5X compatibles
+
+Describe the compatible properties for the Marvell Alleycat5/5X switches
+with integrated CPUs.
+
+Alleycat5:
+* 98DX2538: 24x1G + 2x10G + 2x10G Stack
+* 98DX2535: 24x1G + 4x1G Stack
+* 98DX2532: 8x1G + 2x10G + 2x1G Stack
+* 98DX2531: 8x1G + 4x1G Stack
+* 98DX2528: 24x1G + 2x10G + 2x10G Stack
+* 98DX2525: 24x1G + 4x1G Stack
+* 98DX2522: 8x1G + 2x10G + 2x1G Stack
+* 98DX2521: 8x1G + 4x1G Stack
+* 98DX2518: 24x1G + 2x10G + 2x10G Stack
+* 98DX2515: 24x1G + 4x1G Stack
+* 98DX2512: 8x1G + 2x10G + 2x1G Stack
+* 98DX2511: 8x1G + 4x1G Stack
+
+Alleycat5X:
+* 98DX3500: 24x1G + 6x25G
+* 98DX3501: 16x1G + 6x10G
+* 98DX3510: 48x1G + 6x25G
+* 98DX3520: 24x2.5G + 6x25G
+* 98DX3530: 48x2.5G + 6x25G
+* 98DX3540: 12x5G/6x10G + 6x25G
+* 98DX3550: 24x5G/12x10G + 6x25G
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Vadym Kochan <vadym.kochan@plvision.eu>
+Reviewed-by: Krzysztof Kozlowski <krzysztof.kozlowski@linaro.org>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ .../bindings/arm/marvell/marvell,ac5.yaml     | 32 +++++++++++++++++++
+ 1 file changed, 32 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/arm/marvell/marvell,ac5.yaml
+
+diff --git a/Documentation/devicetree/bindings/arm/marvell/marvell,ac5.yaml b/Documentation/devicetree/bindings/arm/marvell/marvell,ac5.yaml
+new file mode 100644
+index 000000000..8960fb8b2
+--- /dev/null
++++ b/Documentation/devicetree/bindings/arm/marvell/marvell,ac5.yaml
+@@ -0,0 +1,32 @@
++# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/arm/marvell/marvell,ac5.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Marvell Alleycat5/5X Platforms
++
++maintainers:
++  - Chris Packham <chris.packham@alliedtelesis.co.nz>
++
++properties:
++  $nodename:
++    const: '/'
++  compatible:
++    oneOf:
++      - description: Alleycat5 (98DX25xx) Reference Design
++        items:
++          - enum:
++              - marvell,rd-ac5
++          - const: marvell,ac5
++
++      - description: Alleycat5X (98DX35xx) Reference Design
++        items:
++          - enum:
++              - marvell,rd-ac5x
++          - const: marvell,ac5x
++          - const: marvell,ac5
++
++additionalProperties: true
++
++...
+-- 
+2.25.1
+
diff --git a/patch/0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch b/patch/0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch
new file mode 100644
index 000000000..0a9c47f84
--- /dev/null
+++ b/patch/0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch
@@ -0,0 +1,30 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Wed, 16 Mar 2022 10:52:06 +1300
+dt-bindings: net: mvneta: Add marvell,armada-ac5-neta
+
+The out of band port on the 98DX2530 SoC is similar to the armada-3700
+except it requires a slightly different MBUS window configuration. Add a
+new compatible string so this difference can be accounted for.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ .../devicetree/bindings/net/marvell-armada-370-neta.txt          | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt
+index 691f886cf..2bf31572b 100644
+--- a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt
++++ b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt
+@@ -5,6 +5,7 @@ Required properties:
+ 	"marvell,armada-370-neta"
+ 	"marvell,armada-xp-neta"
+ 	"marvell,armada-3700-neta"
++	"marvell,armada-ac5-neta"
+ - reg: address and length of the register set for the device.
+ - interrupts: interrupt for the device
+ - phy: See ethernet.txt file in the same directory.
+-- 
+2.25.1
+
diff --git a/patch/0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch b/patch/0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch
new file mode 100644
index 000000000..bb6e11f22
--- /dev/null
+++ b/patch/0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch
@@ -0,0 +1,467 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Tue, 5 Jul 2022 22:09:20 +0300
+arm64: dts: marvell: Add Armada 98DX2530 SoC and RD-AC5X board
+
+The 98DX2530 SoC is the Control and Management CPU integrated into
+the Marvell 98DX25xx and 98DX35xx series of switch chip (internally
+referred to as AlleyCat5 and AlleyCat5X).
+
+These files have been taken from the Marvell SDK and lightly cleaned
+up with the License and copyright retained.
+
+gregory.clement: use specific cpu type: cortex-a55 instead of armv8 in
+cpu nodes, armv8 being reserved for the arm virtual models that are
+not meant to implement a particular CPU type.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Vadym Kochan <vadym.kochan@plvision.eu>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/Makefile          |   1 +
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi | 291 ++++++++++++++++++
+ .../boot/dts/marvell/ac5-98dx35xx-rd.dts      | 101 ++++++
+ arch/arm64/boot/dts/marvell/ac5-98dx35xx.dtsi |  17 +
+ 4 files changed, 410 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+ create mode 100644 arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
+ create mode 100644 arch/arm64/boot/dts/marvell/ac5-98dx35xx.dtsi
+
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 3e5f2e7a0..5e9c34d1e 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -16,3 +16,4 @@ dtb-$(CONFIG_ARCH_MVEBU) += armada-8080-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += cn9130-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += cn9131-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += cn9132-db.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += ac5-98dx35xx-rd.dtb
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+new file mode 100644
+index 000000000..80b44c7df
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -0,0 +1,291 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Device Tree For AC5.
++ *
++ * Copyright (C) 2021 Marvell
++ * Copyright (C) 2022 Allied Telesis Labs
++ */
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/interrupt-controller/arm-gic.h>
++
++/ {
++	model = "Marvell AC5 SoC";
++	compatible = "marvell,ac5";
++	interrupt-parent = <&gic>;
++	#address-cells = <2>;
++	#size-cells = <2>;
++
++	cpus {
++		#address-cells = <2>;
++		#size-cells = <0>;
++
++		cpu-map {
++			cluster0 {
++				core0 {
++					cpu = <&cpu0>;
++				};
++				core1 {
++					cpu = <&cpu1>;
++				};
++			};
++		};
++
++		cpu0: cpu@0 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a55";
++			reg = <0x0 0x0>;
++			enable-method = "psci";
++			next-level-cache = <&l2>;
++		};
++
++		cpu1: cpu@1 {
++			device_type = "cpu";
++			compatible = "arm,cortex-a55";
++			reg = <0x0 0x100>;
++			enable-method = "psci";
++			next-level-cache = <&l2>;
++		};
++
++		l2: l2-cache {
++			compatible = "cache";
++		};
++	};
++
++	psci {
++		compatible = "arm,psci-0.2";
++		method = "smc";
++	};
++
++	timer {
++		compatible = "arm,armv8-timer";
++		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>,
++			     <GIC_PPI 8 IRQ_TYPE_LEVEL_HIGH>,
++			     <GIC_PPI 10 IRQ_TYPE_LEVEL_HIGH>,
++			     <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH>;
++	};
++
++	pmu {
++		compatible = "arm,armv8-pmuv3";
++		interrupts = <GIC_PPI 12 IRQ_TYPE_LEVEL_HIGH>;
++	};
++
++	soc {
++		compatible = "simple-bus";
++		#address-cells = <2>;
++		#size-cells = <2>;
++		ranges;
++		dma-ranges;
++
++		internal-regs@7f000000 {
++			#address-cells = <1>;
++			#size-cells = <1>;
++			compatible = "simple-bus";
++			/* 16M internal register @ 0x7f00_0000 */
++			ranges = <0x0 0x0 0x7f000000 0x1000000>;
++			dma-coherent;
++
++			uart0: serial@12000 {
++				compatible = "snps,dw-apb-uart";
++				reg = <0x12000 0x100>;
++				reg-shift = <2>;
++				interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
++				reg-io-width = <1>;
++				clocks = <&cnm_clock>;
++				status = "okay";
++			};
++
++			mdio: mdio@22004 {
++				#address-cells = <1>;
++				#size-cells = <0>;
++				compatible = "marvell,orion-mdio";
++				reg = <0x22004 0x4>;
++				clocks = <&cnm_clock>;
++			};
++
++			i2c0: i2c@11000{
++				compatible = "marvell,mv78230-i2c";
++				reg = <0x11000 0x20>;
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				clocks = <&cnm_clock>;
++				clock-names = "core";
++				interrupts = <GIC_SPI 87 IRQ_TYPE_LEVEL_HIGH>;
++				clock-frequency=<100000>;
++
++				pinctrl-names = "default", "gpio";
++				pinctrl-0 = <&i2c0_pins>;
++				pinctrl-1 = <&i2c0_gpio>;
++				scl_gpio = <&gpio0 26 GPIO_ACTIVE_HIGH>;
++				sda_gpio = <&gpio0 27 GPIO_ACTIVE_HIGH>;
++				status = "disabled";
++			};
++
++			i2c1: i2c@11100{
++				compatible = "marvell,mv78230-i2c";
++				reg = <0x11100 0x20>;
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				clocks = <&cnm_clock>;
++				clock-names = "core";
++				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
++				clock-frequency=<100000>;
++
++				pinctrl-names = "default", "gpio";
++				pinctrl-0 = <&i2c1_pins>;
++				pinctrl-1 = <&i2c1_gpio>;
++				scl_gpio = <&gpio0 20 GPIO_ACTIVE_HIGH>;
++				sda_gpio = <&gpio0 21 GPIO_ACTIVE_HIGH>;
++				status = "disabled";
++			};
++
++			gpio0: gpio@18100 {
++				compatible = "marvell,orion-gpio";
++				reg = <0x18100 0x40>;
++				ngpios = <32>;
++				gpio-controller;
++				#gpio-cells = <2>;
++				gpio-ranges = <&pinctrl0 0 0 32>;
++				marvell,pwm-offset = <0x1f0>;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
++			};
++
++			gpio1: gpio@18140 {
++				reg = <0x18140 0x40>;
++				compatible = "marvell,orion-gpio";
++				ngpios = <14>;
++				gpio-controller;
++				#gpio-cells = <2>;
++				gpio-ranges = <&pinctrl0 0 32 14>;
++				marvell,pwm-offset = <0x1f0>;
++				interrupt-controller;
++				#interrupt-cells = <2>;
++				interrupts = <GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
++			};
++		};
++
++		/*
++		 * Dedicated section for devices behind 32bit controllers so we
++		 * can configure specific DMA mapping for them
++		 */
++		behind-32bit-controller@7f000000 {
++			compatible = "simple-bus";
++			#address-cells = <0x2>;
++			#size-cells = <0x2>;
++			ranges = <0x0 0x0 0x0 0x7f000000 0x0 0x1000000>;
++			/* Host phy ram starts at 0x200M */
++			dma-ranges = <0x0 0x0 0x2 0x0 0x1 0x0>;
++			dma-coherent;
++
++			eth0: ethernet@20000 {
++				compatible = "marvell,armada-ac5-neta";
++				reg = <0x0 0x20000 0x0 0x4000>;
++				interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
++				clocks = <&cnm_clock>;
++				phy-mode = "sgmii";
++				status = "disabled";
++			};
++
++			eth1: ethernet@24000 {
++				compatible = "marvell,armada-ac5-neta";
++				reg = <0x0 0x24000 0x0 0x4000>;
++				interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>;
++				clocks = <&cnm_clock>;
++				phy-mode = "sgmii";
++				status = "disabled";
++			};
++
++			usb0: usb@80000 {
++				compatible = "marvell,orion-ehci";
++				reg = <0x0 0x80000 0x0 0x500>;
++				interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++
++			usb1: usb@a0000 {
++				compatible = "marvell,orion-ehci";
++				reg = <0x0 0xa0000 0x0 0x500>;
++				interrupts = <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
++				status = "disabled";
++			};
++		};
++
++		pinctrl0: pinctrl@80020100 {
++			compatible = "marvell,ac5-pinctrl";
++			reg = <0 0x80020100 0 0x20>;
++
++			i2c0_pins: i2c0-pins {
++				marvell,pins = "mpp26", "mpp27";
++				marvell,function = "i2c0";
++			};
++
++			i2c0_gpio: i2c0-gpio-pins {
++				marvell,pins = "mpp26", "mpp27";
++				marvell,function = "gpio";
++			};
++
++			i2c1_pins: i2c1-pins {
++				marvell,pins = "mpp20", "mpp21";
++				marvell,function = "i2c1";
++			};
++
++			i2c1_gpio: i2c1-gpio-pins {
++				marvell,pins = "mpp20", "mpp21";
++				marvell,function = "i2c1";
++			};
++		};
++
++		spi0: spi@805a0000 {
++			compatible = "marvell,armada-3700-spi";
++			reg = <0x0 0x805a0000 0x0 0x50>;
++			#address-cells = <0x1>;
++			#size-cells = <0x0>;
++			clocks = <&spi_clock>;
++			interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
++			num-cs = <1>;
++			status = "disabled";
++		};
++
++		spi1: spi@805a8000 {
++			compatible = "marvell,armada-3700-spi";
++			reg = <0x0 0x805a8000 0x0 0x50>;
++			#address-cells = <0x1>;
++			#size-cells = <0x0>;
++			clocks = <&spi_clock>;
++			interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
++			num-cs = <1>;
++			status = "disabled";
++		};
++
++		gic: interrupt-controller@80600000 {
++			compatible = "arm,gic-v3";
++			#interrupt-cells = <3>;
++			interrupt-controller;
++			reg = <0x0 0x80600000 0x0 0x10000>, /* GICD */
++			      <0x0 0x80660000 0x0 0x40000>; /* GICR */
++			interrupts = <GIC_PPI 6 IRQ_TYPE_LEVEL_HIGH>;
++		};
++	};
++
++	clocks {
++		cnm_clock: cnm-clock {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++			clock-frequency = <328000000>;
++		};
++
++		spi_clock: spi-clock {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++			clock-frequency = <200000000>;
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts b/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
+new file mode 100644
+index 000000000..f0ebdb84e
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
+@@ -0,0 +1,101 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Device Tree For RD-AC5X.
++ *
++ * Copyright (C) 2021 Marvell
++ * Copyright (C) 2022 Allied Telesis Labs
++ */
++/*
++ * Device Tree file for Marvell Alleycat 5X development board
++ * This board file supports the B configuration of the board
++ */
++
++/dts-v1/;
++
++#include "ac5-98dx35xx.dtsi"
++
++/ {
++	model = "Marvell RD-AC5X Board";
++	compatible = "marvell,rd-ac5x", "marvell,ac5x", "marvell,ac5";
++
++	aliases {
++		serial0 = &uart0;
++		spiflash0 = &spiflash0;
++		gpio0 = &gpio0;
++		gpio1 = &gpio1;
++		ethernet0 = &eth0;
++		ethernet1 = &eth1;
++	};
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x2 0x00000000 0x0 0x40000000>;
++	};
++
++	usb1phy: usb-phy {
++		compatible = "usb-nop-xceiv";
++		#phy-cells = <0>;
++	};
++};
++
++&mdio {
++	phy0: ethernet-phy@0 {
++		reg = <0>;
++	};
++};
++
++&i2c0 {
++	status = "okay";
++};
++
++&i2c1 {
++	status = "okay";
++};
++
++&eth0 {
++	status = "okay";
++	phy-handle = <&phy0>;
++};
++
++/* USB0 is a host USB */
++&usb0 {
++	status = "okay";
++};
++
++/* USB1 is a peripheral USB */
++&usb1 {
++	status = "okay";
++	phys = <&usb1phy>;
++	phy-names = "usb-phy";
++	dr_mode = "peripheral";
++};
++
++&spi0 {
++	status = "okay";
++
++	spiflash0: flash@0 {
++		compatible = "jedec,spi-nor";
++		spi-max-frequency = <50000000>;
++		spi-tx-bus-width = <1>; /* 1-single, 2-dual, 4-quad */
++		spi-rx-bus-width = <1>; /* 1-single, 2-dual, 4-quad */
++		reg = <0>;
++
++		#address-cells = <1>;
++		#size-cells = <1>;
++
++		partition@0 {
++			label = "spi_flash_part0";
++			reg = <0x0 0x800000>;
++		};
++
++		parition@1 {
++			label = "spi_flash_part1";
++			reg = <0x800000 0x700000>;
++		};
++
++		parition@2 {
++			label = "spi_flash_part2";
++			reg = <0xF00000 0x100000>;
++		};
++	};
++};
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx35xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx35xx.dtsi
+new file mode 100644
+index 000000000..2ab72f854
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx35xx.dtsi
+@@ -0,0 +1,17 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Device Tree For AC5X.
++ *
++ * Copyright (C) 2022 Allied Telesis Labs
++ */
++
++#include "ac5-98dx25xx.dtsi"
++
++/ {
++	model = "Marvell AC5X SoC";
++	compatible = "marvell,ac5x", "marvell,ac5";
++};
++
++&cnm_clock {
++	clock-frequency = <325000000>;
++};
+-- 
+2.25.1
+
diff --git a/patch/0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch b/patch/0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch
new file mode 100644
index 000000000..6e24a86c8
--- /dev/null
+++ b/patch/0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch
@@ -0,0 +1,57 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Wed, 3 Aug 2022 13:16:23 +1200
+arm64: dts: marvell: Add UART1-3 for AC5/AC5X
+
+The AC5/AC5X SoC has 4 UART blocks. Add the additional UART1-3 blocks to
+the base dtsi file.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi | 30 +++++++++++++++++++
+ 1 file changed, 30 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+index 80b44c7df..914fcf9e2 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -95,6 +95,36 @@ uart0: serial@12000 {
+ 				status = "okay";
+ 			};
+ 
++			uart1: serial@12100 {
++				compatible = "snps,dw-apb-uart";
++				reg = <0x11000 0x100>;
++				reg-shift = <2>;
++				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
++				reg-io-width = <1>;
++				clocks = <&cnm_clock>;
++				status = "disabled";
++			};
++
++			uart2: serial@12200 {
++				compatible = "snps,dw-apb-uart";
++				reg = <0x12200 0x100>;
++				reg-shift = <2>;
++				interrupts = <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>;
++				reg-io-width = <1>;
++				clocks = <&cnm_clock>;
++				status = "disabled";
++			};
++
++			uart3: serial@12300 {
++				compatible = "snps,dw-apb-uart";
++				reg = <0x12300 0x100>;
++				reg-shift = <2>;
++				interrupts = <GIC_SPI 86 IRQ_TYPE_LEVEL_HIGH>;
++				reg-io-width = <1>;
++				clocks = <&cnm_clock>;
++				status = "disabled";
++			};
++
+ 			mdio: mdio@22004 {
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
+-- 
+2.25.1
+
diff --git a/patch/0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch b/patch/0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch
new file mode 100644
index 000000000..fc5cf48ab
--- /dev/null
+++ b/patch/0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch
@@ -0,0 +1,43 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Thu, 1 Sep 2022 14:28:08 +1200
+arm64: dts: marvell: 98dx25xx: Fix i2c gpios property
+
+Use the correct names for scl-gpios and sda-gpios so that the generic
+i2c recovery code will find them. While we're here set the
+GPIO_OPEN_DRAIN flag on the gpios.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+index 914fcf9e2..44ed6f963 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -147,8 +147,8 @@ i2c0: i2c@11000{
+ 				pinctrl-names = "default", "gpio";
+ 				pinctrl-0 = <&i2c0_pins>;
+ 				pinctrl-1 = <&i2c0_gpio>;
+-				scl_gpio = <&gpio0 26 GPIO_ACTIVE_HIGH>;
+-				sda_gpio = <&gpio0 27 GPIO_ACTIVE_HIGH>;
++				scl-gpios = <&gpio0 26 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
++				sda-gpios = <&gpio0 27 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+ 				status = "disabled";
+ 			};
+ 
+@@ -166,8 +166,8 @@ i2c1: i2c@11100{
+ 				pinctrl-names = "default", "gpio";
+ 				pinctrl-0 = <&i2c1_pins>;
+ 				pinctrl-1 = <&i2c1_gpio>;
+-				scl_gpio = <&gpio0 20 GPIO_ACTIVE_HIGH>;
+-				sda_gpio = <&gpio0 21 GPIO_ACTIVE_HIGH>;
++				scl-gpios = <&gpio0 20 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
++				sda-gpios = <&gpio0 21 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+ 				status = "disabled";
+ 			};
+ 
+-- 
+2.25.1
+
diff --git a/patch/0006-arm64-dts-Update-cache-properties-for-marvell.patch b/patch/0006-arm64-dts-Update-cache-properties-for-marvell.patch
new file mode 100644
index 000000000..4d6c1bb20
--- /dev/null
+++ b/patch/0006-arm64-dts-Update-cache-properties-for-marvell.patch
@@ -0,0 +1,88 @@
+From: Pierre Gondois <pierre.gondois@arm.com>
+Date: Mon, 31 Oct 2022 10:20:16 +0100
+arm64: dts: Update cache properties for marvell
+
+The DeviceTree Specification v0.3 specifies that the cache node
+'compatible' and 'cache-level' properties are 'required'. Cf.
+s3.8 Multi-level and Shared Cache Nodes
+
+The recently added init_of_cache_level() function checks
+these properties. Add them if missing.
+
+Signed-off-by: Pierre Gondois <pierre.gondois@arm.com>
+Reviewed-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi      | 1 +
+ arch/arm64/boot/dts/marvell/armada-ap806-dual.dtsi | 1 +
+ arch/arm64/boot/dts/marvell/armada-ap806-quad.dtsi | 2 ++
+ arch/arm64/boot/dts/marvell/armada-ap807-quad.dtsi | 2 ++
+ 4 files changed, 6 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+index 44ed6f963..7308f7b6b 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -49,6 +49,7 @@ cpu1: cpu@1 {
+ 
+ 		l2: l2-cache {
+ 			compatible = "cache";
++			cache-level = <2>;
+ 		};
+ 	};
+ 
+diff --git a/arch/arm64/boot/dts/marvell/armada-ap806-dual.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806-dual.dtsi
+index fcab5173f..990f70303 100644
+--- a/arch/arm64/boot/dts/marvell/armada-ap806-dual.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-ap806-dual.dtsi
+@@ -51,6 +51,7 @@ l2: l2-cache {
+ 			cache-size = <0x80000>;
+ 			cache-line-size = <64>;
+ 			cache-sets = <512>;
++			cache-level = <2>;
+ 		};
+ 	};
+ 
+diff --git a/arch/arm64/boot/dts/marvell/armada-ap806-quad.dtsi b/arch/arm64/boot/dts/marvell/armada-ap806-quad.dtsi
+index 3db427122..a7b8e001c 100644
+--- a/arch/arm64/boot/dts/marvell/armada-ap806-quad.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-ap806-quad.dtsi
+@@ -81,6 +81,7 @@ l2_0: l2-cache0 {
+ 			cache-size = <0x80000>;
+ 			cache-line-size = <64>;
+ 			cache-sets = <512>;
++			cache-level = <2>;
+ 		};
+ 
+ 		l2_1: l2-cache1 {
+@@ -88,6 +89,7 @@ l2_1: l2-cache1 {
+ 			cache-size = <0x80000>;
+ 			cache-line-size = <64>;
+ 			cache-sets = <512>;
++			cache-level = <2>;
+ 		};
+ 	};
+ };
+diff --git a/arch/arm64/boot/dts/marvell/armada-ap807-quad.dtsi b/arch/arm64/boot/dts/marvell/armada-ap807-quad.dtsi
+index 68782f161..7740098fd 100644
+--- a/arch/arm64/boot/dts/marvell/armada-ap807-quad.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-ap807-quad.dtsi
+@@ -81,6 +81,7 @@ l2_0: l2-cache0 {
+ 			cache-size = <0x80000>;
+ 			cache-line-size = <64>;
+ 			cache-sets = <512>;
++			cache-level = <2>;
+ 		};
+ 
+ 		l2_1: l2-cache1 {
+@@ -88,6 +89,7 @@ l2_1: l2-cache1 {
+ 			cache-size = <0x80000>;
+ 			cache-line-size = <64>;
+ 			cache-sets = <512>;
++			cache-level = <2>;
+ 		};
+ 	};
+ };
+-- 
+2.25.1
+
diff --git a/patch/0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch b/patch/0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch
new file mode 100644
index 000000000..5981a009c
--- /dev/null
+++ b/patch/0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch
@@ -0,0 +1,29 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Thu, 15 Dec 2022 15:54:02 +1300
+arm64: dts: marvell: AC5/AC5X: Fix address for UART1
+
+The correct address offset is 0x12100.
+
+Fixes: 31be791e26cf ("arm64: dts: marvell: Add UART1-3 for AC5/AC5X")
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+index 7308f7b6b..8bce64069 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -98,7 +98,7 @@ uart0: serial@12000 {
+ 
+ 			uart1: serial@12100 {
+ 				compatible = "snps,dw-apb-uart";
+-				reg = <0x11000 0x100>;
++				reg = <0x12100 0x100>;
+ 				reg-shift = <2>;
+ 				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+ 				reg-io-width = <1>;
+-- 
+2.25.1
+
diff --git a/patch/0008-mtd-rawnand-marvell-Add-missing-layouts.patch b/patch/0008-mtd-rawnand-marvell-Add-missing-layouts.patch
new file mode 100644
index 000000000..8c46523d8
--- /dev/null
+++ b/patch/0008-mtd-rawnand-marvell-Add-missing-layouts.patch
@@ -0,0 +1,44 @@
+From: Aviram Dali <aviramd@marvell.com>
+Date: Fri, 16 Dec 2022 18:27:15 +0200
+mtd: rawnand: marvell: Add missing layouts
+
+Missing layouts were added to the driver to support NAND flashes
+with ECC layouts of 12 or 16 with page sized of 2048, 4096 or 8192.
+
+Usually theses are rare layouts, but in Marvell AC5 driver, the ECC
+level is set according to the spare area, so we may use these layouts
+more frequently.
+
+Signed-off-by: Aviram Dali <aviramd@marvell.com>
+Signed-off-by: Vadym Kochan <vadym.kochan@plvision.eu>
+Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
+Link: https://lore.kernel.org/linux-mtd/20221216162715.3230766-1-vadym.kochan@plvision.eu
+---
+ drivers/mtd/nand/raw/marvell_nand.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/mtd/nand/raw/marvell_nand.c b/drivers/mtd/nand/raw/marvell_nand.c
+index d00c916f1..241de3912 100644
+--- a/drivers/mtd/nand/raw/marvell_nand.c
++++ b/drivers/mtd/nand/raw/marvell_nand.c
+@@ -287,10 +287,17 @@ static const struct marvell_hw_ecc_layout marvell_nfc_layouts[] = {
+ 	MARVELL_LAYOUT( 2048,   512,  1,  1,  1, 2048, 40, 24,  0,  0,  0),
+ 	MARVELL_LAYOUT( 2048,   512,  4,  1,  1, 2048, 32, 30,  0,  0,  0),
+ 	MARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,1024,32, 30),
++	MARVELL_LAYOUT( 2048,   512,  8,  2,  1, 1024,  0, 30,1024,64, 30),
++	MARVELL_LAYOUT( 2048,   512,  12, 3,  2, 704,   0, 30,640,  0, 30),
++	MARVELL_LAYOUT( 2048,   512,  16, 5,  4, 512,   0, 30,  0, 32, 30),
+ 	MARVELL_LAYOUT( 4096,   512,  4,  2,  2, 2048, 32, 30,  0,  0,  0),
+ 	MARVELL_LAYOUT( 4096,   512,  8,  5,  4, 1024,  0, 30,  0, 64, 30),
++	MARVELL_LAYOUT( 4096,   512,  12, 6,  5, 704,   0, 30,576, 32, 30),
++	MARVELL_LAYOUT( 4096,   512,  16, 9,  8, 512,   0, 30,  0, 32, 30),
+ 	MARVELL_LAYOUT( 8192,   512,  4,  4,  4, 2048,  0, 30,  0,  0,  0),
+ 	MARVELL_LAYOUT( 8192,   512,  8,  9,  8, 1024,  0, 30,  0, 160, 30),
++	MARVELL_LAYOUT( 8192,   512,  12, 12, 11, 704,  0, 30,448,  64, 30),
++	MARVELL_LAYOUT( 8192,   512,  16, 17, 16, 512,  0, 30,  0,  32, 30),
+ };
+ 
+ /**
+-- 
+2.25.1
+
diff --git a/patch/0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch b/patch/0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch
new file mode 100644
index 000000000..454b45880
--- /dev/null
+++ b/patch/0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch
@@ -0,0 +1,313 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Fri, 15 Apr 2022 11:30:53 +1200
+pinctrl: mvebu: Add driver for 98DX2530 SoC
+
+This pinctrl driver supports the 98DX25xx and 98DX35xx family of chips
+from Marvell. It is based on the Marvell SDK with additions for various
+(non-gpio) pin configurations based on the datasheet.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Link: https://lore.kernel.org/r/20220414233055.586962-3-chris.packham@alliedtelesis.co.nz
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/Kconfig       |   4 +
+ drivers/pinctrl/mvebu/Makefile      |   1 +
+ drivers/pinctrl/mvebu/pinctrl-ac5.c | 261 ++++++++++++++++++++++++++++
+ 3 files changed, 266 insertions(+)
+ create mode 100644 drivers/pinctrl/mvebu/pinctrl-ac5.c
+
+diff --git a/drivers/pinctrl/mvebu/Kconfig b/drivers/pinctrl/mvebu/Kconfig
+index 0d12894d3..aa5883f09 100644
+--- a/drivers/pinctrl/mvebu/Kconfig
++++ b/drivers/pinctrl/mvebu/Kconfig
+@@ -45,6 +45,10 @@ config PINCTRL_ORION
+ 	bool
+ 	select PINCTRL_MVEBU
+ 
++config PINCTRL_AC5
++	bool
++	select PINCTRL_MVEBU
++
+ config PINCTRL_ARMADA_37XX
+ 	bool
+ 	select GENERIC_PINCONF
+diff --git a/drivers/pinctrl/mvebu/Makefile b/drivers/pinctrl/mvebu/Makefile
+index cd082dca4..23458ab17 100644
+--- a/drivers/pinctrl/mvebu/Makefile
++++ b/drivers/pinctrl/mvebu/Makefile
+@@ -11,3 +11,4 @@ obj-$(CONFIG_PINCTRL_ARMADA_CP110) += pinctrl-armada-cp110.o
+ obj-$(CONFIG_PINCTRL_ARMADA_XP)  += pinctrl-armada-xp.o
+ obj-$(CONFIG_PINCTRL_ARMADA_37XX)  += pinctrl-armada-37xx.o
+ obj-$(CONFIG_PINCTRL_ORION)  += pinctrl-orion.o
++obj-$(CONFIG_PINCTRL_AC5) += pinctrl-ac5.o
+diff --git a/drivers/pinctrl/mvebu/pinctrl-ac5.c b/drivers/pinctrl/mvebu/pinctrl-ac5.c
+new file mode 100644
+index 000000000..292633e61
+--- /dev/null
++++ b/drivers/pinctrl/mvebu/pinctrl-ac5.c
+@@ -0,0 +1,261 @@
++// SPDX-License-Identifier: GPL-2.0-or-later
++/*
++ * Marvell ac5 pinctrl driver based on mvebu pinctrl core
++ *
++ * Copyright (C) 2021 Marvell
++ *
++ * Noam Liron <lnoam@marvell.com>
++ */
++
++#include <linux/err.h>
++#include <linux/init.h>
++#include <linux/io.h>
++#include <linux/platform_device.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/pinctrl/pinctrl.h>
++
++#include "pinctrl-mvebu.h"
++
++static struct mvebu_mpp_mode ac5_mpp_modes[] = {
++	MPP_MODE(0,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d0"),
++		 MPP_FUNCTION(2, "nand",  "io4")),
++	MPP_MODE(1,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d1"),
++		 MPP_FUNCTION(2, "nand",  "io3")),
++	MPP_MODE(2,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d2"),
++		 MPP_FUNCTION(2, "nand",  "io2")),
++	MPP_MODE(3,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d3"),
++		 MPP_FUNCTION(2, "nand",  "io7")),
++	MPP_MODE(4,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d4"),
++		 MPP_FUNCTION(2, "nand",  "io6"),
++		 MPP_FUNCTION(3, "uart3", "txd"),
++		 MPP_FUNCTION(4, "uart2", "txd")),
++	MPP_MODE(5,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d5"),
++		 MPP_FUNCTION(2, "nand",  "io5"),
++		 MPP_FUNCTION(3, "uart3", "rxd"),
++		 MPP_FUNCTION(4, "uart2", "rxd")),
++	MPP_MODE(6,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d6"),
++		 MPP_FUNCTION(2, "nand",  "io0"),
++		 MPP_FUNCTION(3, "i2c1",  "sck")),
++	MPP_MODE(7,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "d7"),
++		 MPP_FUNCTION(2, "nand",  "io1"),
++		 MPP_FUNCTION(3, "i2c1",  "sda")),
++	MPP_MODE(8,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "clk"),
++		 MPP_FUNCTION(2, "nand",  "wen")),
++	MPP_MODE(9,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "cmd"),
++		 MPP_FUNCTION(2, "nand",  "ale")),
++	MPP_MODE(10,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "ds"),
++		 MPP_FUNCTION(2, "nand",  "cle")),
++	MPP_MODE(11,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "sdio",  "rst"),
++		 MPP_FUNCTION(2, "nand",  "cen")),
++	MPP_MODE(12,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "clk")),
++	MPP_MODE(13,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "csn")),
++	MPP_MODE(14,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "mosi")),
++	MPP_MODE(15,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "miso")),
++	MPP_MODE(16,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "wpn"),
++		 MPP_FUNCTION(2, "nand",  "ren"),
++		 MPP_FUNCTION(3, "uart1", "txd")),
++	MPP_MODE(17,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "spi0",  "hold"),
++		 MPP_FUNCTION(2, "nand",  "rb"),
++		 MPP_FUNCTION(3, "uart1", "rxd")),
++	MPP_MODE(18,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "tsen_int", NULL),
++		 MPP_FUNCTION(2, "uart2", "rxd"),
++		 MPP_FUNCTION(3, "wd_int", NULL)),
++	MPP_MODE(19,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "dev_init_done", NULL),
++		 MPP_FUNCTION(2, "uart2", "txd")),
++	MPP_MODE(20,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(2, "i2c1",  "sck"),
++		 MPP_FUNCTION(3, "spi1",  "clk"),
++		 MPP_FUNCTION(4, "uart3", "txd")),
++	MPP_MODE(21,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(2, "i2c1",  "sda"),
++		 MPP_FUNCTION(3, "spi1",  "csn"),
++		 MPP_FUNCTION(4, "uart3", "rxd")),
++	MPP_MODE(22,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(3, "spi1",  "mosi")),
++	MPP_MODE(23,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(3, "spi1",  "miso")),
++	MPP_MODE(24,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "wd_int", NULL),
++		 MPP_FUNCTION(2, "uart2", "txd"),
++		 MPP_FUNCTION(3, "uartsd", "txd")),
++	MPP_MODE(25,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "int_out", NULL),
++		 MPP_FUNCTION(2, "uart2", "rxd"),
++		 MPP_FUNCTION(3, "uartsd", "rxd")),
++	MPP_MODE(26,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "i2c0",  "sck"),
++		 MPP_FUNCTION(2, "ptp", "clk1"),
++		 MPP_FUNCTION(3, "uart3", "txd")),
++	MPP_MODE(27,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "i2c0",  "sda"),
++		 MPP_FUNCTION(2, "ptp", "pulse"),
++		 MPP_FUNCTION(3, "uart3", "rxd")),
++	MPP_MODE(28,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "xg", "mdio"),
++		 MPP_FUNCTION(2, "ge", "mdio"),
++		 MPP_FUNCTION(3, "uart3", "txd")),
++	MPP_MODE(29,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "xg", "mdio"),
++		 MPP_FUNCTION(2, "ge", "mdio"),
++		 MPP_FUNCTION(3, "uart3", "rxd")),
++	MPP_MODE(30,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "xg", "mdio"),
++		 MPP_FUNCTION(2, "ge", "mdio"),
++		 MPP_FUNCTION(3, "ge", "mdio")),
++	MPP_MODE(31,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "xg", "mdio"),
++		 MPP_FUNCTION(2, "ge", "mdio"),
++		 MPP_FUNCTION(3, "ge", "mdio")),
++	MPP_MODE(32,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "uart0", "txd")),
++	MPP_MODE(33,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "uart0", "rxd"),
++		 MPP_FUNCTION(2, "ptp", "clk1"),
++		 MPP_FUNCTION(3, "ptp", "pulse")),
++	MPP_MODE(34,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ge", "mdio"),
++		 MPP_FUNCTION(2, "uart3", "rxd")),
++	MPP_MODE(35,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ge", "mdio"),
++		 MPP_FUNCTION(2, "uart3", "txd"),
++		 MPP_FUNCTION(3, "pcie", "rstoutn")),
++	MPP_MODE(36,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ptp", "clk0_tp"),
++		 MPP_FUNCTION(2, "ptp", "clk1_tp")),
++	MPP_MODE(37,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ptp", "pulse_tp"),
++		 MPP_FUNCTION(2, "wd_int", NULL)),
++	MPP_MODE(38,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "synce", "clk_out0")),
++	MPP_MODE(39,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "synce", "clk_out1")),
++	MPP_MODE(40,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ptp", "pclk_out0"),
++		 MPP_FUNCTION(2, "ptp", "pclk_out1")),
++	MPP_MODE(41,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ptp", "ref_clk"),
++		 MPP_FUNCTION(2, "ptp", "clk1"),
++		 MPP_FUNCTION(3, "ptp", "pulse"),
++		 MPP_FUNCTION(4, "uart2", "txd"),
++		 MPP_FUNCTION(5, "i2c1",  "sck")),
++	MPP_MODE(42,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "ptp", "clk0"),
++		 MPP_FUNCTION(2, "ptp", "clk1"),
++		 MPP_FUNCTION(3, "ptp", "pulse"),
++		 MPP_FUNCTION(4, "uart2", "rxd"),
++		 MPP_FUNCTION(5, "i2c1",  "sda")),
++	MPP_MODE(43,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "led", "clk")),
++	MPP_MODE(44,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "led", "stb")),
++	MPP_MODE(45,
++		 MPP_FUNCTION(0, "gpio",  NULL),
++		 MPP_FUNCTION(1, "led", "data")),
++};
++
++static struct mvebu_pinctrl_soc_info ac5_pinctrl_info;
++
++static const struct of_device_id ac5_pinctrl_of_match[] = {
++	{
++		.compatible = "marvell,ac5-pinctrl",
++	},
++	{ },
++};
++
++static const struct mvebu_mpp_ctrl ac5_mpp_controls[] = {
++	MPP_FUNC_CTRL(0, 45, NULL, mvebu_mmio_mpp_ctrl), };
++
++static struct pinctrl_gpio_range ac5_mpp_gpio_ranges[] = {
++	MPP_GPIO_RANGE(0,   0,  0, 46), };
++
++static int ac5_pinctrl_probe(struct platform_device *pdev)
++{
++	struct mvebu_pinctrl_soc_info *soc = &ac5_pinctrl_info;
++
++	soc->variant = 0; /* no variants for ac5 */
++	soc->controls = ac5_mpp_controls;
++	soc->ncontrols = ARRAY_SIZE(ac5_mpp_controls);
++	soc->gpioranges = ac5_mpp_gpio_ranges;
++	soc->ngpioranges = ARRAY_SIZE(ac5_mpp_gpio_ranges);
++	soc->modes = ac5_mpp_modes;
++	soc->nmodes = ac5_mpp_controls[0].npins;
++
++	pdev->dev.platform_data = soc;
++
++	return mvebu_pinctrl_simple_mmio_probe(pdev);
++}
++
++static struct platform_driver ac5_pinctrl_driver = {
++	.driver = {
++		.name = "ac5-pinctrl",
++		.of_match_table = of_match_ptr(ac5_pinctrl_of_match),
++	},
++	.probe = ac5_pinctrl_probe,
++};
++builtin_platform_driver(ac5_pinctrl_driver);
+-- 
+2.25.1
+
diff --git a/patch/0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch b/patch/0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch
new file mode 100644
index 000000000..872b843de
--- /dev/null
+++ b/patch/0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch
@@ -0,0 +1,36 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Tue, 5 Jul 2022 22:09:21 +0300
+arm64: marvell: Enable the 98DX2530 pinctrl driver
+
+This commit makes sure the drivers for the 98DX2530 pin controller is
+enabled.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Vadym Kochan <vadym.kochan@plvision.eu>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/Kconfig.platforms | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
+index 889e78f40..02e197936 100644
+--- a/arch/arm64/Kconfig.platforms
++++ b/arch/arm64/Kconfig.platforms
+@@ -179,11 +179,13 @@ config ARCH_MVEBU
+ 	select PINCTRL_ARMADA_37XX
+ 	select PINCTRL_ARMADA_AP806
+ 	select PINCTRL_ARMADA_CP110
++	select PINCTRL_AC5
+ 	help
+ 	  This enables support for Marvell EBU familly, including:
+ 	   - Armada 3700 SoC Family
+ 	   - Armada 7K SoC Family
+ 	   - Armada 8K SoC Family
++	   - 98DX2530 SoC Family
+ 
+ config ARCH_MXC
+ 	bool "ARMv8 based NXP i.MX SoC family"
+-- 
+2.25.1
+
diff --git a/patch/0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch b/patch/0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch
new file mode 100644
index 000000000..16675a0fd
--- /dev/null
+++ b/patch/0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch
@@ -0,0 +1,69 @@
+From: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Date: Wed, 16 Mar 2022 10:52:07 +1300
+net: mvneta: Add support for 98DX2530 Ethernet port
+
+The 98DX2530 SoC is similar to the Armada 3700 except it needs a
+different MBUS window configuration. Add a new compatible string to
+identify this device and the required MBUS window configuration.
+
+Signed-off-by: Chris Packham <chris.packham@alliedtelesis.co.nz>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Paolo Abeni <pabeni@redhat.com>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 74e266c0b..81f42ae08 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -75,6 +75,8 @@
+ #define MVNETA_WIN_SIZE(w)                      (0x2204 + ((w) << 3))
+ #define MVNETA_WIN_REMAP(w)                     (0x2280 + ((w) << 2))
+ #define MVNETA_BASE_ADDR_ENABLE                 0x2290
++#define      MVNETA_AC5_CNM_DDR_TARGET		0x2
++#define      MVNETA_AC5_CNM_DDR_ATTR		0xb
+ #define MVNETA_ACCESS_PROTECT_ENABLE            0x2294
+ #define MVNETA_PORT_CONFIG                      0x2400
+ #define      MVNETA_UNI_PROMISC_MODE            BIT(0)
+@@ -513,6 +515,7 @@ struct mvneta_port {
+ 
+ 	/* Flags for special SoC configurations */
+ 	bool neta_armada3700;
++	bool neta_ac5;
+ 	u16 rx_offset_correction;
+ 	const struct mbus_dram_target_info *dram_target_info;
+ };
+@@ -5025,6 +5028,10 @@ static void mvneta_conf_mbus_windows(struct mvneta_port *pp,
+ 			win_protect |= 3 << (2 * i);
+ 		}
+ 	} else {
++		if (pp->neta_ac5)
++			mvreg_write(pp, MVNETA_WIN_BASE(0),
++				    (MVNETA_AC5_CNM_DDR_ATTR << 8) |
++				    MVNETA_AC5_CNM_DDR_TARGET);
+ 		/* For Armada3700 open default 4GB Mbus window, leaving
+ 		 * arbitration of target/attribute to a different layer
+ 		 * of configuration.
+@@ -5123,6 +5130,10 @@ static int mvneta_probe(struct platform_device *pdev)
+ 	/* Get special SoC configurations */
+ 	if (of_device_is_compatible(dn, "marvell,armada-3700-neta"))
+ 		pp->neta_armada3700 = true;
++	if (of_device_is_compatible(dn, "marvell,armada-ac5-neta")) {
++		pp->neta_armada3700 = true;
++		pp->neta_ac5 = true;
++	}
+ 
+ 	pp->clk = devm_clk_get(&pdev->dev, "core");
+ 	if (IS_ERR(pp->clk))
+@@ -5444,6 +5455,7 @@ static const struct of_device_id mvneta_match[] = {
+ 	{ .compatible = "marvell,armada-370-neta" },
+ 	{ .compatible = "marvell,armada-xp-neta" },
+ 	{ .compatible = "marvell,armada-3700-neta" },
++	{ .compatible = "marvell,armada-ac5-neta" },
+ 	{ }
+ };
+ MODULE_DEVICE_TABLE(of, mvneta_match);
+-- 
+2.25.1
+
diff --git a/patch/0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch b/patch/0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch
new file mode 100644
index 000000000..b53e5ac2e
--- /dev/null
+++ b/patch/0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch
@@ -0,0 +1,41 @@
+From: Noam <lnoam@marvell.com>
+Date: Tue, 26 Jul 2022 16:00:37 +0300
+spi: a3700: Support big endianness for AC5 SPI driver
+
+Fix wrong endianness in a3700_spi_fifo_read() and a3700_spi_fifo_write().
+
+Signed-off-by: Noam <lnoam@marvell.com>
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+Signed-off-by: Vadym Kochan <vadym.kochan@plvision.eu>
+Link: https://lore.kernel.org/r/20220726130038.20995-1-vadym.kochan@plvision.eu
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index d8cc4b270..9df9fc40b 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -497,7 +497,7 @@ static int a3700_spi_fifo_write(struct a3700_spi *a3700_spi)
+ 
+ 	while (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {
+ 		val = *(u32 *)a3700_spi->tx_buf;
+-		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, cpu_to_le32(val));
+ 		a3700_spi->buf_len -= 4;
+ 		a3700_spi->tx_buf += 4;
+ 	}
+@@ -519,7 +519,7 @@ static int a3700_spi_fifo_read(struct a3700_spi *a3700_spi)
+ 	while (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {
+ 		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 		if (a3700_spi->buf_len >= 4) {
+-
++			val = le32_to_cpu(val);
+ 			memcpy(a3700_spi->rx_buf, &val, 4);
+ 
+ 			a3700_spi->buf_len -= 4;
+-- 
+2.25.1
+
diff --git a/patch/0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch b/patch/0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch
new file mode 100644
index 000000000..cbd535907
--- /dev/null
+++ b/patch/0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch
@@ -0,0 +1,72 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Tue, 14 Mar 2023 06:10:59 +0000
+dt-bindings: ac5: Add mmc and usb properties
+
+Describe compatible string in Marvell Xenon SDHCI Controller for mmc.
+Also documents compatible string for ac5 in ehci-orion.
+
+Signed-off-by: Noam Liron <lnoam@marvell.com>
+---
+ .../bindings/mmc/marvell,xenon-sdhci.txt      | 22 +++++++++++++++++++
+ .../devicetree/bindings/usb/ehci-orion.txt    |  1 +
+ 2 files changed, 23 insertions(+)
+
+diff --git a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
+index ed1456f5c..c5a4aebcd 100644
+--- a/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
++++ b/Documentation/devicetree/bindings/mmc/marvell,xenon-sdhci.txt
+@@ -13,6 +13,7 @@ Required Properties:
+   Must provide a second register area and marvell,pad-type.
+   - "marvell,armada-ap806-sdhci": For controllers on Armada AP806.
+   - "marvell,armada-cp110-sdhci": For controllers on Armada CP110.
++  - "marvell,ac5-sdhci": For CnM on AC5, AC5X and derived.
+ 
+ - clocks:
+   Array of clocks required for SDHC.
+@@ -32,6 +33,9 @@ Required Properties:
+     in below.
+     Please also check property marvell,pad-type in below.
+ 
++  * For "marvell,ac5-sdhci", one register area.
++    (reg-names "ctrl").
++
+   * For other compatible strings, one register area for Xenon IP.
+ 
+ Optional Properties:
+@@ -170,3 +174,21 @@ Example:
+ 
+ 		marvell,pad-type = "sd";
+ 	};
++
++
++- For eMMC with compatible "marvell,ac5-sdhci":
++	sdhci0: sdhci@805c0000 {
++		compatible = "marvell,ac5-sdhci";
++		reg = <0x0 0x805c0000>;
++		reg-names = "ctrl";
++		interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
++		clocks = <&core_clock>;
++		clock-names = "core";
++		status = "okay";
++		bus-width = <8>;
++		/*marvell,xenon-phy-slow-mode;*/
++		non-removable;
++		mmc-ddr-1_8v;
++		mmc-hs200-1_8v;
++		mmc-hs400-1_8v;
++	};
+diff --git a/Documentation/devicetree/bindings/usb/ehci-orion.txt b/Documentation/devicetree/bindings/usb/ehci-orion.txt
+index 2855bae79..83e4d8992 100644
+--- a/Documentation/devicetree/bindings/usb/ehci-orion.txt
++++ b/Documentation/devicetree/bindings/usb/ehci-orion.txt
+@@ -4,6 +4,7 @@ Required properties:
+ - compatible: must be one of the following
+ 	"marvell,orion-ehci"
+ 	"marvell,armada-3700-ehci"
++	"marvell,ac5-ehci"
+ - reg: physical base address of the controller and length of memory mapped
+   region.
+ - interrupts: The EHCI interrupt
+-- 
+2.25.1
+
diff --git a/patch/0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch b/patch/0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch
new file mode 100644
index 000000000..f31207860
--- /dev/null
+++ b/patch/0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch
@@ -0,0 +1,124 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Mon, 13 Mar 2023 09:58:10 +0000
+dts: ac5: marvell: Add switching/mmc/watchdog node
+
+This patch adds following changes to 98DX25xx and 98DX35xx SoC,
+	- SDMA(Subsystem DMA engine) node for control path Rx/Tx.
+	- prestera node for interupt handing from switching ASIC.
+	- mmc node using Xenon SDHCI Controller.
+	- watchdog node.
+	- clock-frequency in timer node.
+	- ac5-ehci compatible string in usb.
+
+Signed-off-by: Yuval Shaia <yshaia@marvell.com>
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+---
+ arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi | 47 ++++++++++++++++++-
+ .../boot/dts/marvell/ac5-98dx35xx-rd.dts      |  8 ++++
+ 2 files changed, 54 insertions(+), 1 deletion(-)
+
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+index 8bce64069..f1f96799b 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx25xx.dtsi
+@@ -64,6 +64,7 @@ timer {
+ 			     <GIC_PPI 8 IRQ_TYPE_LEVEL_HIGH>,
+ 			     <GIC_PPI 10 IRQ_TYPE_LEVEL_HIGH>,
+ 			     <GIC_PPI 7 IRQ_TYPE_LEVEL_HIGH>;
++		clock-frequency = <25000000>;
+ 	};
+ 
+ 	pmu {
+@@ -203,6 +204,30 @@ gpio1: gpio@18140 {
+ 			};
+ 		};
+ 
++		mmc_dma: mmc-dma-peripherals@80500000 {
++			compatible = "simple-bus";
++			#address-cells = <0x2>;
++			#size-cells = <0x2>;
++			ranges;
++			dma-coherent;
++
++			sdhci0: sdhci@805c0000 {
++				compatible = "marvell,ac5-sdhci", "marvell,armada-ap806-sdhci";
++				reg = <0x0 0x805c0000 0x0 0x300>;
++				reg-names = "ctrl";
++				interrupts = <GIC_SPI 92 IRQ_TYPE_LEVEL_HIGH>;
++				clocks = <&emmc_clock>;
++				clock-names = "core";
++				status = "okay";
++				bus-width = <8>;
++				/*marvell,xenon-phy-slow-mode;*/
++				non-removable;
++				mmc-ddr-1_8v;
++				mmc-hs200-1_8v;
++				mmc-hs400-1_8v;
++			};
++		};
++
+ 		/*
+ 		 * Dedicated section for devices behind 32bit controllers so we
+ 		 * can configure specific DMA mapping for them
+@@ -235,7 +260,7 @@ eth1: ethernet@24000 {
+ 			};
+ 
+ 			usb0: usb@80000 {
+-				compatible = "marvell,orion-ehci";
++				compatible = "marvell,ac5-ehci", "marvell,orion-ehci";
+ 				reg = <0x0 0x80000 0x0 0x500>;
+ 				interrupts = <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+ 				status = "disabled";
+@@ -296,6 +321,20 @@ spi1: spi@805a8000 {
+ 			status = "disabled";
+ 		};
+ 
++		prestera {
++			compatible = "marvell,armada-ac5-switch";
++			interrupts = <GIC_SPI 0x23 IRQ_TYPE_LEVEL_HIGH>;
++			status = "okay";
++		};
++
++		watchdog@80216000 {
++			compatible = "marvell,ac5-wd";
++			reg = <0x0 0x80216000 0 0x1000>,
++			      <0x0 0x80215000 0 0x1000>;
++			interrupts = <GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>;
++			timeout-sec = <30>;
++		};
++
+ 		gic: interrupt-controller@80600000 {
+ 			compatible = "arm,gic-v3";
+ 			#interrupt-cells = <3>;
+@@ -318,5 +357,11 @@ spi_clock: spi-clock {
+ 			#clock-cells = <0>;
+ 			clock-frequency = <200000000>;
+ 		};
++
++		emmc_clock: emmc_clock@0 {
++			compatible = "fixed-clock";
++			#clock-cells = <0>;
++			clock-frequency = <400000000>;
++		};
+ 	};
+ };
+diff --git a/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts b/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
+index f0ebdb84e..45c305d46 100644
+--- a/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
++++ b/arch/arm64/boot/dts/marvell/ac5-98dx35xx-rd.dts
+@@ -99,3 +99,11 @@ parition@2 {
+ 		};
+ 	};
+ };
++
++/{
++	sdma_drv {
++		compatible = "marvell,mvppnd";
++		interrupts = <GIC_SPI 0x23 IRQ_TYPE_LEVEL_HIGH>;
++		status = "okay";
++	};
++};
+-- 
+2.25.1
+
diff --git a/patch/0015-ac5-marvell-Add-watchdog-support.patch b/patch/0015-ac5-marvell-Add-watchdog-support.patch
new file mode 100644
index 000000000..85c2ba657
--- /dev/null
+++ b/patch/0015-ac5-marvell-Add-watchdog-support.patch
@@ -0,0 +1,524 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Fri, 10 Mar 2023 00:43:32 +0000
+ac5: marvell: Add watchdog support
+
+WD registers are located in protected CPU area, which gets locked
+after bootrom runs. Therefore need to access them by using SMC, which
+was added in this driver.
+
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+Signed-off-by: Noam Liron <lnoam@marvell.com>
+---
+ drivers/watchdog/Kconfig   |  16 ++
+ drivers/watchdog/Makefile  |   1 +
+ drivers/watchdog/ac5_gwd.c | 458 +++++++++++++++++++++++++++++++++++++
+ 3 files changed, 475 insertions(+)
+ create mode 100644 drivers/watchdog/ac5_gwd.c
+
+diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
+index 01ce3f41c..a68a1a3b7 100644
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -395,6 +395,22 @@ config ARMADA_37XX_WATCHDOG
+ 	   To compile this driver as a module, choose M here: the
+ 	   module will be called armada_37xx_wdt.
+ 
++config MARVELL_AC5_WATCHDOG
++	tristate "Marvell AlleyCat 5 Watchdog"
++	depends on ARM64
++	depends on ARM_ARCH_TIMER
++	select WATCHDOG_CORE
++	help
++	  AC5 Watchdog has two stage timeouts:
++	  the first signal (WS0) is for alerting the system by interrupt,
++	  the second one (WS1) is a real hardware reset.
++
++	  This driver can operate as a single stage or a two stages watchdog,
++	  depends on the module parameter "action" (moudle name is ac5-gwd).
++
++	  Note: the maximum timeout in the two stages mode is half of that in
++	  the single stage mode.
++
+ config ASM9260_WATCHDOG
+ 	tristate "Alphascale ASM9260 watchdog"
+ 	depends on MACH_ASM9260 || COMPILE_TEST
+diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
+index 071a2e50b..acf3df558 100644
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -39,6 +39,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
+ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
+ obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
+ obj-$(CONFIG_ARMADA_37XX_WATCHDOG) += armada_37xx_wdt.o
++obj-$(CONFIG_MARVELL_AC5_WATCHDOG) += ac5_gwd.o
+ obj-$(CONFIG_ASM9260_WATCHDOG) += asm9260_wdt.o
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+diff --git a/drivers/watchdog/ac5_gwd.c b/drivers/watchdog/ac5_gwd.c
+new file mode 100644
+index 000000000..5ba877b9b
+--- /dev/null
++++ b/drivers/watchdog/ac5_gwd.c
+@@ -0,0 +1,458 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * AC5 Watchdog driver
++ *
++ * Copyright (c) 2015, Linaro Ltd.
++ * Author: Fu Wei <fu.wei@linaro.org>
++ *         Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>
++ *         Al Stone <al.stone@linaro.org>
++ *         Timur Tabi <timur@codeaurora.org>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License 2 as published
++ * by the Free Software Foundation.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * AC5 Watchdog has two stage timeouts:
++ * the first signal (WS0) is for alerting the system by interrupt,
++ * the second one (WS1) is a real hardware reset.
++ * More details about the hardware specification of this device:
++ * ARM DEN0029B - Server Base System Architecture (SBSA)
++ *
++ * This driver can operate as a single stage watchdog
++ * or a two stages watchdog, it's set up by the module parameter "action".
++ * In the single stage mode, when the timeout is reached, your system
++ * will be reset by WS1. The first signal (WS0) is ignored.
++ * In the two stages mode, when the timeout is reached, the first signal (WS0)
++ * will trigger panic. If the system is getting into trouble and cannot be reset
++ * by panic or restart properly by the kdump kernel(if supported), then the
++ * second stage (as long as the first stage) will be reached, system will be
++ * reset by WS1. This function can help administrator to backup the system
++ * context info by panic console output or kdump.
++ *
++ * SBSA GWDT:
++ * if action is 1 (the two stages mode):
++ * |--------WOR-------WS0--------WOR-------WS1
++ * |----timeout-----(panic)----timeout-----reset
++ *
++ * if action is 0 (the single stage mode):
++ * |------WOR-----WS0(ignored)-----WOR------WS1
++ * |--------------timeout-------------------reset
++ *
++ * Note: Since this watchdog timer has two stages, and each stage is determined
++ * by WOR, in the single stage mode, the timeout is (WOR * 2); in the two
++ * stages mode, the timeout is WOR. The maximum timeout in the two stages mode
++ * is half of that in the single stage mode.
++ *
++ */
++
++#include <linux/io.h>
++#include <linux/io-64-nonatomic-lo-hi.h>
++#include <linux/interrupt.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/uaccess.h>
++#include <linux/watchdog.h>
++#include <asm/arch_timer.h>
++#include <linux/arm-smccc.h>
++
++/* AC5 SMCs, taken from ATF include/services/arm_arch_svc.h */
++#define SMC_FID_READ_REG	0x80007FFE
++#define SMC_FID_WRITE_REG	0x80007FFD
++
++#define DRV_NAME		"ac5-gwd"
++#define WATCHDOG_NAME	"AC5 Watchdog"
++
++/* SBSA Generic Watchdog register definitions */
++/* refresh frame */
++#define SBSA_GWDT_WRR		0x000
++
++/* control frame */
++#define SBSA_GWDT_WCS		0x000
++#define SBSA_GWDT_WOR		0x008
++#define SBSA_GWDT_WCV		0x010
++
++/* refresh/control frame */
++#define SBSA_GWDT_W_IIDR	0xfcc
++#define SBSA_GWDT_IDR		0xfd0
++
++/* Watchdog Control and Status Register */
++#define SBSA_GWDT_WCS_EN	BIT(0)
++#define SBSA_GWDT_WCS_WS0	BIT(1)
++#define SBSA_GWDT_WCS_WS1	BIT(2)
++
++#define AC5_ID      0xB400
++#define AC5X_ID     0x9800
++#define IML_ID      0xA000
++#define IMM_ID      0xA200
++
++#define WRITE_MASK(addr, mask, val)     \
++	writel((readl(addr) & (~(mask))) | val, addr)
++
++/**
++ * struct sbsa_gwdt - Internal representation of the SBSA GWDT
++ * @wdd:		kernel watchdog_device structure
++ * @clk:		store the System Counter clock frequency, in Hz.
++ * @refresh_base:	Virtual address of the watchdog refresh frame
++ * @control_base:	Virtual address of the watchdog control frame
++ */
++struct sbsa_gwdt {
++	struct watchdog_device	wdd;
++	u32		clk;
++	u32		refresh_base;
++	u32		control_base;
++};
++
++#define DEFAULT_TIMEOUT		10 /* seconds */
++
++static unsigned int timeout;
++module_param(timeout, uint, 0);
++MODULE_PARM_DESC(timeout,
++		 "Watchdog timeout in seconds. (>=0, default="
++		 __MODULE_STRING(DEFAULT_TIMEOUT) ")");
++
++/*
++ * action refers to action taken when watchdog gets WS0
++ * 0 = skip
++ * 1 = panic
++ * defaults to skip (0)
++ */
++static int action;
++module_param(action, int, 0);
++MODULE_PARM_DESC(action, "after watchdog gets WS0 interrupt, do: 0 = skip(*)  1 = panic");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0444);
++MODULE_PARM_DESC(nowayout,
++		 "Watchdog cannot be stopped once started (default="
++		 __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++static inline u32 smc_readl(unsigned int addr)
++{
++	struct arm_smccc_res smc_res;
++
++	arm_smccc_smc(SMC_FID_READ_REG,  addr, 0,    0, 0, 0, 0, 0, &smc_res);
++	return (u32)smc_res.a0;
++}
++
++static inline void smc_writel(unsigned int val, unsigned int addr)
++{
++	struct arm_smccc_res smc_res;
++
++	arm_smccc_smc(SMC_FID_WRITE_REG, addr, val, 0, 0, 0, 0, 0, &smc_res);
++}
++
++/*
++ * watchdog operation functions
++ */
++static int sbsa_gwdt_set_timeout(struct watchdog_device *wdd,
++				 unsigned int timeout)
++{
++	struct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);
++
++	wdd->timeout = timeout;
++
++	if (action)
++		smc_writel(gwdt->clk * timeout,
++		       gwdt->control_base + SBSA_GWDT_WOR);
++	else
++		/*
++		 * In the single stage mode, The first signal (WS0) is ignored,
++		 * the timeout is (WOR * 2), so the WOR should be configured
++		 * to half value of timeout.
++		 */
++		smc_writel(gwdt->clk / 2 * timeout,
++		       gwdt->control_base + SBSA_GWDT_WOR);
++
++	return 0;
++}
++
++static inline u64 lo_hi_smc_readq(unsigned int addr)
++{
++	u32 low, high;
++
++	low = smc_readl(addr);
++	high = smc_readl(addr + 4);
++	low = smc_readl(addr); /* read twice, as a workaround to HW limitation */
++
++	return low + ((u64)high << 32);
++}
++
++
++static unsigned int sbsa_gwdt_get_timeleft(struct watchdog_device *wdd)
++{
++	struct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);
++	u64 timeleft = 0;
++
++	/*
++	 * In the single stage mode, if WS0 is deasserted
++	 * (watchdog is in the first stage),
++	 * timeleft = WOR + (WCV - system counter)
++	 */
++	if (!action &&
++	    !(smc_readl(gwdt->control_base + SBSA_GWDT_WCS) & SBSA_GWDT_WCS_WS0))
++		timeleft += smc_readl(gwdt->control_base + SBSA_GWDT_WOR);
++
++	timeleft += lo_hi_smc_readq(gwdt->control_base + SBSA_GWDT_WCV) -
++		    arch_timer_read_counter();
++
++	do_div(timeleft, gwdt->clk);
++
++	return timeleft;
++}
++
++static int sbsa_gwdt_keepalive(struct watchdog_device *wdd)
++{
++	struct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);
++
++	/*
++	 * Writing WRR for an explicit watchdog refresh.
++	 * You can write anyting (like 0).
++	 */
++	smc_writel(0, gwdt->refresh_base + SBSA_GWDT_WRR);
++
++	return 0;
++}
++
++static int sbsa_gwdt_start(struct watchdog_device *wdd)
++{
++	struct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);
++
++	/* writing WCS will cause an explicit watchdog refresh */
++	smc_writel(SBSA_GWDT_WCS_EN, gwdt->control_base + SBSA_GWDT_WCS);
++
++	return 0;
++}
++
++static int sbsa_gwdt_stop(struct watchdog_device *wdd)
++{
++	struct sbsa_gwdt *gwdt = watchdog_get_drvdata(wdd);
++
++	/* Simply write 0 to WCS to clean WCS_EN bit */
++	smc_writel(0, gwdt->control_base + SBSA_GWDT_WCS);
++
++	return 0;
++}
++
++static irqreturn_t sbsa_gwdt_interrupt(int irq, void *dev_id)
++{
++	panic(WATCHDOG_NAME " timeout");
++
++	return IRQ_HANDLED;
++}
++
++static const struct watchdog_info sbsa_gwdt_info = {
++	.identity	= WATCHDOG_NAME,
++	.options	= WDIOF_SETTIMEOUT |
++			  WDIOF_KEEPALIVEPING |
++			  WDIOF_MAGICCLOSE |
++			  WDIOF_CARDRESET,
++};
++
++static const struct watchdog_ops sbsa_gwdt_ops = {
++	.owner		= THIS_MODULE,
++	.start		= sbsa_gwdt_start,
++	.stop		= sbsa_gwdt_stop,
++	.ping		= sbsa_gwdt_keepalive,
++	.set_timeout	= sbsa_gwdt_set_timeout,
++	.get_timeleft	= sbsa_gwdt_get_timeleft,
++};
++
++static int sbsa_gwdt_probe(struct platform_device *pdev)
++{
++	u32 rf_base, cf_base;
++	struct device *dev = &pdev->dev;
++	struct watchdog_device *wdd;
++	struct sbsa_gwdt *gwdt;
++	struct resource *res;
++	void * __iomem reg;
++	int ret, irq;
++	u32 status;
++
++	gwdt = devm_kzalloc(dev, sizeof(*gwdt), GFP_KERNEL);
++	if (!gwdt)
++		return -ENOMEM;
++	platform_set_drvdata(pdev, gwdt);
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (IS_ERR(res))
++		return PTR_ERR(res);
++	cf_base = res->start;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
++	if (IS_ERR(res))
++		return PTR_ERR(res);
++	rf_base = res->start;
++
++	/*
++	 * Get the frequency of system counter from the cp15 interface of ARM
++	 * Generic timer. We don't need to check it, because if it returns "0",
++	 * system would panic in very early stage.
++	 */
++	gwdt->clk = arch_timer_get_cntfrq();
++	gwdt->refresh_base = rf_base;
++	gwdt->control_base = cf_base;
++
++	wdd = &gwdt->wdd;
++	wdd->parent = dev;
++	wdd->info = &sbsa_gwdt_info;
++	wdd->ops = &sbsa_gwdt_ops;
++	wdd->min_timeout = 1;
++	wdd->max_hw_heartbeat_ms = U32_MAX / gwdt->clk * 1000;
++	wdd->timeout = DEFAULT_TIMEOUT;
++	watchdog_set_drvdata(wdd, gwdt);
++	watchdog_set_nowayout(wdd, nowayout);
++
++	status = smc_readl(cf_base + SBSA_GWDT_WCS);
++	if (status & SBSA_GWDT_WCS_WS1) {
++		dev_warn(dev, "System reset by WDT.\n");
++		wdd->bootstatus |= WDIOF_CARDRESET;
++	}
++	if (status & SBSA_GWDT_WCS_EN)
++		set_bit(WDOG_HW_RUNNING, &wdd->status);
++
++	if (action) {
++		irq = platform_get_irq(pdev, 0);
++		if (irq < 0) {
++			action = 0;
++			dev_warn(dev, "unable to get ws0 interrupt.\n");
++		} else {
++			/*
++			 * In case there is a pending ws0 interrupt, just ping
++			 * the watchdog before registering the interrupt routine
++			 */
++			smc_writel(0, rf_base + SBSA_GWDT_WRR);
++			if (devm_request_irq(dev, irq, sbsa_gwdt_interrupt, 0,
++					     pdev->name, gwdt)) {
++				action = 0;
++				dev_warn(dev, "unable to request IRQ %d.\n",
++					 irq);
++			}
++		}
++		if (!action)
++			dev_warn(dev, "falling back to single stage mode.\n");
++	}
++	/*
++	 * In the single stage mode, The first signal (WS0) is ignored,
++	 * the timeout is (WOR * 2), so the maximum timeout should be doubled.
++	 */
++	if (!action)
++		wdd->max_hw_heartbeat_ms *= 2;
++
++	watchdog_init_timeout(wdd, timeout, dev);
++	/*
++	 * Update timeout to WOR.
++	 * Because of the explicit watchdog refresh mechanism,
++	 * it's also a ping, if watchdog is enabled.
++	 */
++	sbsa_gwdt_set_timeout(wdd, wdd->timeout);
++
++	watchdog_stop_on_reboot(wdd);
++	ret = devm_watchdog_register_device(dev, wdd);
++	if (ret)
++		return ret;
++
++	/* CPSS-14280: WD HW need to trigger reset on WS1.
++	 * Enable GWD reset out.
++	 */
++	smc_writel(0xFFFFFFBF, 0x80210030);
++
++	reg = devm_ioremap(dev, 0x7f90004c, 1);
++	if (IS_ERR(reg))
++		return PTR_ERR(reg);
++	switch ((readl(reg) >> 4) & 0xFF00) {
++	case AC5_ID:
++		reg = devm_ioremap(dev, 0x840F800C, 1);
++		if (IS_ERR(reg))
++			return PTR_ERR(reg);
++		WRITE_MASK(reg, BIT(6), 0);
++		break;
++	case AC5X_ID:
++		reg = devm_ioremap(dev, 0x944F800C, 1);
++		if (IS_ERR(reg))
++			return PTR_ERR(reg);
++		WRITE_MASK(reg, BIT(7), 0);
++		break;
++	case IML_ID:
++	case IMM_ID:
++		reg = devm_ioremap(dev, 0x840F800C, 1);
++		if (IS_ERR(reg))
++			return PTR_ERR(reg);
++		WRITE_MASK(reg, BIT(7), 0);
++		break;
++	default:
++		dev_warn(dev, "Failed to enable DFX reset path\n");
++	}
++
++	dev_info(dev, "Initialized with %ds timeout @ %u Hz, action=%d.%s\n",
++		 wdd->timeout, gwdt->clk, action,
++		 status & SBSA_GWDT_WCS_EN ? " [enabled]" : "");
++
++	return 0;
++}
++
++/* Disable watchdog if it is active during suspend */
++static int __maybe_unused sbsa_gwdt_suspend(struct device *dev)
++{
++	struct sbsa_gwdt *gwdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(&gwdt->wdd))
++		sbsa_gwdt_stop(&gwdt->wdd);
++
++	return 0;
++}
++
++/* Enable watchdog if necessary */
++static int __maybe_unused sbsa_gwdt_resume(struct device *dev)
++{
++	struct sbsa_gwdt *gwdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(&gwdt->wdd))
++		sbsa_gwdt_start(&gwdt->wdd);
++
++	return 0;
++}
++
++static const struct dev_pm_ops sbsa_gwdt_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(sbsa_gwdt_suspend, sbsa_gwdt_resume)
++};
++
++static const struct of_device_id sbsa_gwdt_of_match[] = {
++	{ .compatible = "marvell,ac5-wd", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, sbsa_gwdt_of_match);
++
++static const struct platform_device_id sbsa_gwdt_pdev_match[] = {
++	{ .name = DRV_NAME, },
++	{},
++};
++MODULE_DEVICE_TABLE(platform, sbsa_gwdt_pdev_match);
++
++static struct platform_driver ac5_gwdt_driver = {
++	.driver = {
++		.name = DRV_NAME,
++		.pm = &sbsa_gwdt_pm_ops,
++		.of_match_table = sbsa_gwdt_of_match,
++	},
++	.probe = sbsa_gwdt_probe,
++	.id_table = sbsa_gwdt_pdev_match,
++};
++
++module_platform_driver(ac5_gwdt_driver);
++
++MODULE_DESCRIPTION("AC5 Watchdog Driver");
++MODULE_AUTHOR("Noam Liron <lnoam@marvell.com>");
++MODULE_AUTHOR("Fu Wei <fu.wei@linaro.org>");
++MODULE_AUTHOR("Suravee Suthikulpanit <Suravee.Suthikulpanit@amd.com>");
++MODULE_AUTHOR("Al Stone <al.stone@linaro.org>");
++MODULE_AUTHOR("Timur Tabi <timur@codeaurora.org>");
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:" DRV_NAME);
+-- 
+2.25.1
+
diff --git a/patch/0016-ac5-marvell-Add-support-for-emmc.patch b/patch/0016-ac5-marvell-Add-support-for-emmc.patch
new file mode 100644
index 000000000..f82df8d5b
--- /dev/null
+++ b/patch/0016-ac5-marvell-Add-support-for-emmc.patch
@@ -0,0 +1,61 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Fri, 10 Mar 2023 00:45:47 +0000
+ac5: marvell: Add support for emmc
+
+This patch adds ac5-sdhci compatible checks in Marvell Xenon SDHCI
+Controller for emmc support in 98DX25xx SoC.
+
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+Signed-off-by: Noam Liron <lnoam@marvell.com>
+---
+ drivers/mmc/host/sdhci-xenon.c | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+diff --git a/drivers/mmc/host/sdhci-xenon.c b/drivers/mmc/host/sdhci-xenon.c
+index d509198c0..1ed5f3171 100644
+--- a/drivers/mmc/host/sdhci-xenon.c
++++ b/drivers/mmc/host/sdhci-xenon.c
+@@ -17,6 +17,7 @@
+ #include <linux/of.h>
+ #include <linux/pm.h>
+ #include <linux/pm_runtime.h>
++#include <linux/of_reserved_mem.h>
+ 
+ #include "sdhci-pltfm.h"
+ #include "sdhci-xenon.h"
+@@ -411,6 +412,7 @@ static int xenon_probe_dt(struct platform_device *pdev)
+ 	struct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);
+ 	u32 sdhc_id, nr_sdhc;
+ 	u32 tuning_count;
++	struct sysinfo si;
+ 
+ 	/* Disable HS200 on Armada AP806 */
+ 	if (of_device_is_compatible(np, "marvell,armada-ap806-sdhci"))
+@@ -439,6 +441,15 @@ static int xenon_probe_dt(struct platform_device *pdev)
+ 	}
+ 	priv->tuning_count = tuning_count;
+ 
++	si_meminfo(&si);
++
++	if (of_device_is_compatible(np, "marvell,ac5-sdhci") &&
++			((si.totalram * si.mem_unit) > 0x80000000 /*2G*/)) {
++		host->quirks |= SDHCI_QUIRK_BROKEN_DMA;
++		host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;
++		dev_info(mmc_dev(mmc), "Disabling DMA because of 2GB DMA access limit.\n");
++	}
++
+ 	return xenon_phy_parse_dt(np, host);
+ }
+ 
+@@ -665,6 +676,7 @@ static const struct of_device_id sdhci_xenon_dt_ids[] = {
+ 	{ .compatible = "marvell,armada-ap806-sdhci",},
+ 	{ .compatible = "marvell,armada-cp110-sdhci",},
+ 	{ .compatible = "marvell,armada-3700-sdhci",},
++	{ .compatible = "marvell,ac5-sdhci",},
+ 	{}
+ };
+ MODULE_DEVICE_TABLE(of, sdhci_xenon_dt_ids);
+-- 
+2.25.1
+
diff --git a/patch/0017-usb-ehci-Add-support-for-ac5.patch b/patch/0017-usb-ehci-Add-support-for-ac5.patch
new file mode 100644
index 000000000..48dfaf832
--- /dev/null
+++ b/patch/0017-usb-ehci-Add-support-for-ac5.patch
@@ -0,0 +1,38 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Mon, 13 Mar 2023 10:01:51 +0000
+usb: ehci: Add support for ac5
+
+Add a new compatible string for 98DX25xx SoCs.
+Change DMA bit mask to 64-bit addressing.
+
+Signed-off-by: Yuval Shaia <yshaia@marvell.com>
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+---
+ drivers/usb/host/ehci-orion.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
+index 3626758b3..488a2ba86 100644
+--- a/drivers/usb/host/ehci-orion.c
++++ b/drivers/usb/host/ehci-orion.c
+@@ -232,7 +232,7 @@ static int ehci_orion_drv_probe(struct platform_device *pdev)
+ 	 * set. Since shared usb code relies on it, set it here for
+ 	 * now. Once we have dma capability bindings this can go away.
+ 	 */
+-	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
++	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));
+ 	if (err)
+ 		goto err;
+ 
+@@ -341,6 +341,7 @@ static int ehci_orion_drv_remove(struct platform_device *pdev)
+ static const struct of_device_id ehci_orion_dt_ids[] = {
+ 	{ .compatible = "marvell,orion-ehci", },
+ 	{ .compatible = "marvell,armada-3700-ehci", },
++	{ .compatible = "marvell,ac5-ehci", },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, ehci_orion_dt_ids);
+-- 
+2.25.1
+
diff --git a/patch/0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch b/patch/0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch
new file mode 100644
index 000000000..51378bc87
--- /dev/null
+++ b/patch/0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch
@@ -0,0 +1,169 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Fri, 10 Mar 2023 00:41:54 +0000
+mv6xxx: Fix i2c lock due to arb-loss
+
+Some i2c slaves, mainly SFPs, might cause the bus to lost arbitration
+while slave is in the middle of responding.
+
+The solution is to change the I2C mpps to gpios, and toggle the i2c_scl
+gpio to emulate bus toggling, so slave will finish its transimission.
+
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+Signed-off-by: Noam Liron <lnoam@marvell.com>
+---
+ drivers/i2c/busses/i2c-mv64xxx.c | 82 ++++++++++++++++++++++++++++++++
+ 1 file changed, 82 insertions(+)
+
+diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
+index e0e45fc19..804cd227b 100644
+--- a/drivers/i2c/busses/i2c-mv64xxx.c
++++ b/drivers/i2c/busses/i2c-mv64xxx.c
+@@ -9,6 +9,8 @@
+  * is licensed "as is" without any warranty of any kind, whether express
+  * or implied.
+  */
++#undef UI_I2C_DEBUG
++
+ #include <linux/kernel.h>
+ #include <linux/slab.h>
+ #include <linux/module.h>
+@@ -25,6 +27,7 @@
+ #include <linux/clk.h>
+ #include <linux/err.h>
+ #include <linux/delay.h>
++#include <linux/of_gpio.h>
+ 
+ #define MV64XXX_I2C_ADDR_ADDR(val)			((val & 0x7f) << 1)
+ #define MV64XXX_I2C_BAUD_DIV_N(val)			(val & 0x7)
+@@ -103,6 +106,7 @@ enum {
+ 	MV64XXX_I2C_ACTION_RCV_DATA,
+ 	MV64XXX_I2C_ACTION_RCV_DATA_STOP,
+ 	MV64XXX_I2C_ACTION_SEND_STOP,
++	MV64XXX_I2C_ACTION_UNLOCK_BUS
+ };
+ 
+ struct mv64xxx_i2c_regs {
+@@ -147,6 +151,12 @@ struct mv64xxx_i2c_data {
+ 	bool			irq_clear_inverted;
+ 	/* Clk div is 2 to the power n, not 2 to the power n + 1 */
+ 	bool			clk_n_base_0;
++
++	/* I2C mpp states & gpios needed for ARB lost recovery */
++	int			scl_gpio, sda_gpio;
++	bool			arb_lost_reovery_ena;
++	struct pinctrl_state *i2c_mpp_state;
++	struct pinctrl_state *i2c_gpio_state;
+ };
+ 
+ static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {
+@@ -308,6 +318,11 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
+ 		drv_data->state = MV64XXX_I2C_STATE_IDLE;
+ 		break;
+ 
++	case MV64XXX_I2C_STATUS_MAST_LOST_ARB: /*0x38*/
++		drv_data->action = MV64XXX_I2C_ACTION_UNLOCK_BUS;
++		drv_data->state = MV64XXX_I2C_STATE_IDLE;
++		break;
++
+ 	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK: /* 0x20 */
+ 	case MV64XXX_I2C_STATUS_MAST_WR_NO_ACK: /* 30 */
+ 	case MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK: /* 48 */
+@@ -345,6 +360,9 @@ static void mv64xxx_i2c_send_start(struct mv64xxx_i2c_data *drv_data)
+ static void
+ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
+ {
++	struct pinctrl *pc;
++	int i, ret;
++
+ 	switch(drv_data->action) {
+ 	case MV64XXX_I2C_ACTION_SEND_RESTART:
+ 		/* We should only get here if we have further messages */
+@@ -398,6 +416,46 @@ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
+ 			drv_data->reg_base + drv_data->reg_offsets.control);
+ 		break;
+ 
++	case MV64XXX_I2C_ACTION_UNLOCK_BUS:
++
++		if (!drv_data->arb_lost_reovery_ena)
++			break;
++
++		pc = devm_pinctrl_get(drv_data->adapter.dev.parent);
++		if (IS_ERR(pc))
++			break;
++
++		/* Move i2c MPPs to GPIOs */
++		if (pinctrl_select_state(pc, drv_data->i2c_gpio_state) >= 0) {
++			ret = devm_gpio_request_one(drv_data->adapter.dev.parent,
++					 drv_data->scl_gpio, GPIOF_DIR_OUT, NULL);
++			ret |= devm_gpio_request_one(drv_data->adapter.dev.parent,
++					 drv_data->sda_gpio, GPIOF_DIR_OUT, NULL);
++			if (!ret) {
++				/* toggle i2c scl 10 times, for the slave that occupies
++				 * the bus Tx its remaining data, and release the bus
++				 */
++				for (i = 0; i < 10; i++) {
++					gpio_set_value(drv_data->scl_gpio, 1);
++					mdelay(1);
++					gpio_set_value(drv_data->scl_gpio, 0);
++				};
++
++				devm_gpio_free(drv_data->adapter.dev.parent,
++					drv_data->scl_gpio);
++				devm_gpio_free(drv_data->adapter.dev.parent,
++					drv_data->sda_gpio);
++			}
++
++			/* restore i2c MPPs */
++			pinctrl_select_state(pc, drv_data->i2c_mpp_state);
++		}
++
++		/* Trigger controller soft reset and restore MPPs */
++		writel(0x1, drv_data->reg_base + drv_data->reg_offsets.soft_reset);
++		mdelay(1);
++		fallthrough;
++
+ 	case MV64XXX_I2C_ACTION_RCV_DATA_STOP:
+ 		drv_data->msg->buf[drv_data->byte_posn++] =
+ 			readl(drv_data->reg_base + drv_data->reg_offsets.data);
+@@ -875,6 +933,7 @@ mv64xxx_i2c_probe(struct platform_device *pd)
+ {
+ 	struct mv64xxx_i2c_data		*drv_data;
+ 	struct mv64xxx_i2c_pdata	*pdata = dev_get_platdata(&pd->dev);
++	struct pinctrl *pc;
+ 	int	rc;
+ 
+ 	if ((!pdata && !pd->dev.of_node))
+@@ -926,6 +985,29 @@ mv64xxx_i2c_probe(struct platform_device *pd)
+ 		goto exit_reset;
+ 	}
+ 
++	drv_data->arb_lost_reovery_ena = false;
++	pc = devm_pinctrl_get(&pd->dev);
++	if (!IS_ERR(pc)) {
++		drv_data->i2c_mpp_state =
++			pinctrl_lookup_state(pc, "default");
++		drv_data->i2c_gpio_state =
++			pinctrl_lookup_state(pc, "gpio");
++		drv_data->scl_gpio =
++			of_get_named_gpio(pd->dev.of_node, "scl-gpios", 0);
++		drv_data->sda_gpio =
++			of_get_named_gpio(pd->dev.of_node, "sda-gpios", 0);
++
++		if (!IS_ERR(drv_data->i2c_gpio_state) &&
++			!IS_ERR(drv_data->i2c_mpp_state) &&
++			gpio_is_valid(drv_data->scl_gpio) &&
++			gpio_is_valid(drv_data->sda_gpio))
++			drv_data->arb_lost_reovery_ena = true;
++	}
++
++	if (!drv_data->arb_lost_reovery_ena)
++		dev_info(&pd->dev,
++			"mv64xxx: missing ARB-lost recovery defs in dts file\n");
++
+ 	drv_data->adapter.dev.parent = &pd->dev;
+ 	drv_data->adapter.algo = &mv64xxx_i2c_algo;
+ 	drv_data->adapter.owner = THIS_MODULE;
+-- 
+2.25.1
+
diff --git a/patch/series b/patch/series
index e86f8589f..57e1401cc 100755
--- a/patch/series
+++ b/patch/series
@@ -186,8 +186,27 @@ cisco-hwmon-pmbus_core-pec-support-check.patch
 0003-psample-define-the-macro-PSAMPLE_MD_EXTENDED_ATTR.patch
 
 #
-# Marvell platform patches for 4.19
+# Marvell platform patches for 5.10
 armhf_secondary_boot_online.patch
+0001-dt-bindings-marvell-Document-the-AC5-AC5X-compatible.patch
+0002-dt-bindings-net-mvneta-Add-marvell-armada-ac5-neta.patch
+0003-arm64-dts-marvell-Add-Armada-98DX2530-SoC-and-RD-AC5.patch
+0004-arm64-dts-marvell-Add-UART1-3-for-AC5-AC5X.patch
+0005-arm64-dts-marvell-98dx25xx-Fix-i2c-gpios-property.patch
+0006-arm64-dts-Update-cache-properties-for-marvell.patch
+0007-arm64-dts-marvell-AC5-AC5X-Fix-address-for-UART1.patch
+0008-mtd-rawnand-marvell-Add-missing-layouts.patch
+0009-pinctrl-mvebu-Add-driver-for-98DX2530-SoC.patch
+0010-arm64-marvell-Enable-the-98DX2530-pinctrl-driver.patch
+0011-net-mvneta-Add-support-for-98DX2530-Ethernet-port.patch
+0012-spi-a3700-Support-big-endianness-for-AC5-SPI-driver.patch
+0013-dt-bindings-ac5-Add-mmc-and-usb-properties.patch
+0014-dts-ac5-marvell-Add-switching-mmc-watchdog-node.patch
+0015-ac5-marvell-Add-watchdog-support.patch
+0016-ac5-marvell-Add-support-for-emmc.patch
+0017-usb-ehci-Add-support-for-ac5.patch
+0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch
+
 #
 #
 ############################################################

From 2251eab708a690b8b960dfa3bbeecd1b011352c8 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Wed, 15 Mar 2023 13:48:28 +0530
Subject: [PATCH 2/3] Add DTS support for 7020 ComExpress

These are set of patches for supporting Armada 7020 comexpress card
hosting integrated CPUs used in Marvells 98CX85xx switching products.

0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch
 - Patch adds documentation for 7020 comexpress.

0020-dts-marvell-Add-support-for-7020-comexpress.patch
 - Patch defines device tree for 7020 comexpress.

Change-Id: I56bc4d7a826201be0931fa109590723f98b74447
Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 ...ngs-marvell-Add-ARMADA-7K-properties.patch |  27 +++
 ...vell-Add-support-for-7020-comexpress.patch | 196 ++++++++++++++++++
 patch/series                                  |   2 +
 3 files changed, 225 insertions(+)
 create mode 100644 patch/0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch
 create mode 100644 patch/0020-dts-marvell-Add-support-for-7020-comexpress.patch

diff --git a/patch/0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch b/patch/0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch
new file mode 100644
index 000000000..61b39c7a4
--- /dev/null
+++ b/patch/0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch
@@ -0,0 +1,27 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Tue, 14 Mar 2023 05:57:34 +0000
+dt-bindings: marvell: Add ARMADA-7K properties
+
+This patch adds compatible properties for the Marvell Armada7020
+Comexpress in documentation.
+
+Signed-off-by: Eyal Oron <oeyal@marvell.com>
+---
+ Documentation/devicetree/bindings/arm/marvell/armada-7k-8k.yaml | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/Documentation/devicetree/bindings/arm/marvell/armada-7k-8k.yaml b/Documentation/devicetree/bindings/arm/marvell/armada-7k-8k.yaml
+index e9bf30545..26092dc11 100644
+--- a/Documentation/devicetree/bindings/arm/marvell/armada-7k-8k.yaml
++++ b/Documentation/devicetree/bindings/arm/marvell/armada-7k-8k.yaml
+@@ -20,6 +20,7 @@ properties:
+           - const: marvell,armada7020
+           - const: marvell,armada-ap806-dual
+           - const: marvell,armada-ap806
++          - const: marvell,armada7020-comexpress
+ 
+       - description: Armada 7040 SoC
+         items:
+-- 
+2.25.1
+
diff --git a/patch/0020-dts-marvell-Add-support-for-7020-comexpress.patch b/patch/0020-dts-marvell-Add-support-for-7020-comexpress.patch
new file mode 100644
index 000000000..31ed7f534
--- /dev/null
+++ b/patch/0020-dts-marvell-Add-support-for-7020-comexpress.patch
@@ -0,0 +1,196 @@
+From: Pavan Naregundi <pnaregundi@marvell.com>
+Date: Tue, 7 Mar 2023 15:18:44 +0000
+dts: marvell: Add support for 7020 comexpress
+
+This change adds device tree file for Marvell Armada 7020 ComExpress 
+development board.
+
+The Armada 7020(7K family) composed of:
+
+ - An AP806 block that contains the CPU core and a few basic peripherals.
+   The AP806 is available in dual core configurations.
+
+ - One CP110 blocks that contain all the high-speed interfaces
+   (SATA, PCIe, Ethernet, etc.).
+
+Also added SDIO mode pin control configuration for CP0.
+
+Signed-off-by: Eyal Oron <oeyal@marvell.com>
+Tested-by: Raz Adashi <raza@marvell.com>
+Reviewed-by: Raz Adashi <raza@marvell.com>
+---
+ arch/arm64/boot/dts/marvell/Makefile          |   1 +
+ .../dts/marvell/armada-7020-comexpress.dts    | 134 ++++++++++++++++++
+ arch/arm64/boot/dts/marvell/armada-70x0.dtsi  |   6 +
+ 3 files changed, 141 insertions(+)
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-7020-comexpress.dts
+
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 5e9c34d1e..6873ad448 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -17,3 +17,4 @@ dtb-$(CONFIG_ARCH_MVEBU) += cn9130-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += cn9131-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += cn9132-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += ac5-98dx35xx-rd.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-7020-comexpress.dtb
+diff --git a/arch/arm64/boot/dts/marvell/armada-7020-comexpress.dts b/arch/arm64/boot/dts/marvell/armada-7020-comexpress.dts
+new file mode 100644
+index 000000000..4f2020427
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-7020-comexpress.dts
+@@ -0,0 +1,134 @@
++// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
++/*
++ * Copyright (C) 2019 Marvell Technology Group Ltd.
++ *
++ * Device Tree file for Marvell Armada 7020 COMEXPRESS board.
++ */
++
++#include "armada-7020.dtsi"
++
++/ {
++	model = "Marvell Armada-7020 COMEXPRESS board setup";
++	compatible = "marvell,armada7020-comexpress", "marvell,armada7020",
++			"marvell,armada-ap806";
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x0 0x0 0x0 0x40000000>;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	aliases {
++		ethernet0 = &cp0_eth0;
++		ethernet1 = &cp0_eth1;
++	};
++};
++
++&i2c0 {
++	status = "okay";
++	clock-frequency = <100000>;
++};
++
++&spi0 {
++	status = "okay";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&cp0_mdio {
++	status = "okay";
++
++	phy0: ethernet-phy@10 {
++		reg = <0x10>;
++	};
++};
++
++&cp0_ethernet {
++	status = "okay";
++};
++
++&cp0_eth0 {
++	status = "disabled";
++	phy-mode = "10gbase-kr";
++	managed = "in-band-status";
++	/* Generic PHY, providing serdes lanes */
++	phys = <&cp0_comphy4 0>;
++};
++
++&cp0_eth1 {
++	status = "okay";
++	phy = <&phy0>;
++	phy-mode = "rgmii-id";
++};
++
++&cp0_i2c0 {
++	status = "okay";
++	clock-frequency = <100000>;
++};
++
++&cp0_nand_controller {
++	status = "okay";
++
++	nand@0 {
++		reg = <0>;
++		label = "pxa3xx_nand-0";
++		nand-rb = <0>;
++		nand-ecc-mode = "hw";
++		nand-on-flash-bbt;
++		nand-ecc-strength = <8>;
++		nand-ecc-step-size = <512>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "U-Boot";
++				reg = <0 0x400000>;
++			};
++			partition@200000 {
++				label = "Linux";
++				reg = <0x400000 0x100000>;
++			};
++			partition@1000000 {
++				label = "Filesystem";
++				reg = <0x500000 0x1e00000>;
++			};
++		};
++	};
++};
++
++&cp0_pcie0 {
++	status = "okay";
++	num-lanes = <4>;
++	num-viewport = <8>;
++
++	ranges = <0x81000000 0x0 0xfa000000 0x0 0xfa000000 0x0 0x00010000
++		  0x82000000 0x0 0x00000000 0x8 0x00000000 0x2 0x00000000>;
++};
++
++&cp0_sata0 {
++	/* CPM Lane 0 - U29 */
++	status = "okay";
++
++	sata-port@1 {
++		status = "okay";
++		/* Generic PHY, providing serdes lanes */
++		phys = <&cp0_comphy5 1>;
++	};
++};
++
++&cp0_sdhci0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdhci_pins>;
++	status = "okay";
++	bus-width = <4>;
++	no-1-8-v;
++	broken-cd;
++};
+diff --git a/arch/arm64/boot/dts/marvell/armada-70x0.dtsi b/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
+index 293403a1a..95199cd99 100644
+--- a/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-70x0.dtsi
+@@ -47,6 +47,12 @@ &cp0_syscon0 {
+ 	cp0_pinctrl: pinctrl {
+ 		compatible = "marvell,armada-7k-pinctrl";
+ 
++		sdhci_pins: sdhi-pins {
++			marvell,pins = "mpp56", "mpp57", "mpp58",
++						   "mpp59", "mpp60", "mpp61", "mpp62";
++			marvell,function = "sdio";
++		};
++
+ 		nand_pins: nand-pins {
+ 			marvell,pins =
+ 			"mpp15", "mpp16", "mpp17", "mpp18",
+-- 
+2.25.1
+
diff --git a/patch/series b/patch/series
index 57e1401cc..6e2e7a0bf 100755
--- a/patch/series
+++ b/patch/series
@@ -206,6 +206,8 @@ armhf_secondary_boot_online.patch
 0016-ac5-marvell-Add-support-for-emmc.patch
 0017-usb-ehci-Add-support-for-ac5.patch
 0018-mv6xxx-Fix-i2c-lock-due-to-arb-loss.patch
+0019-dt-bindings-marvell-Add-ARMADA-7K-properties.patch
+0020-dts-marvell-Add-support-for-7020-comexpress.patch
 
 #
 #

From 3ea55be69340e85b68487cb70c1073ebcd539670 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Wed, 15 Mar 2023 13:57:15 +0530
Subject: [PATCH 3/3] Update kernel configuration for Marvell platforms

Inclusions:
EEPROM support for SFPs and QSFP.
    CONFIG_EEPROM_SFF_8436=m
    CONFIG_EEPROM_OPTOE=m

Support I2C busses connected through a MUX.
    CONFIG_I2C_MUX_GPIO=m

NAND flash support, used for accessing uboot environment variables.
    CONFIG_MTD_RAW_NAND=m
    CONFIG_MTD_NAND_ECC_SW_BCH=y
    CONFIG_MTD_NAND_MARVELL=m

Enable fan controller driver.
    CONFIG_SENSORS_EMC2305=m

Enable watchdog for AC5X.
 - CONFIG_MARVELL_AC5_WATCHDOG=m`

Exclusions:
Overcome following dmesg error during boot.
    - UBIFS error: cannot initialize compressor zstd, error -2
        - CONFIG_UBIFS_FS_ZSTD

    - crypto-safexcel f2800000.crypto: HW init failed (-2)
        - CONFIG_CRYPTO_DEV_SAFEXCEL
        - EIP197 cryptographic engine is not used.

Change-Id: Iaf0aeb8c309c85644dc640a9144f4a7bc37d71a2
Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 patch/kconfig-exclusions |  4 ++++
 patch/kconfig-inclusions | 11 +++++++++++
 2 files changed, 15 insertions(+)

diff --git a/patch/kconfig-exclusions b/patch/kconfig-exclusions
index 6d4f0e622..91313abc0 100644
--- a/patch/kconfig-exclusions
+++ b/patch/kconfig-exclusions
@@ -15,6 +15,10 @@ CONFIG_THERMAL_STATISTICS
 
 [arm64]
 
+[marvell-arm64]
+CONFIG_UBIFS_FS_ZSTD
+CONFIG_CRYPTO_DEV_SAFEXCEL
+
 [armhf]
 
 [marvell-armhf]
diff --git a/patch/kconfig-inclusions b/patch/kconfig-inclusions
index a4dbe48d1..dd290dc25 100644
--- a/patch/kconfig-inclusions
+++ b/patch/kconfig-inclusions
@@ -114,6 +114,17 @@ CONFIG_SPI_INTEL_SPI_PLATFORM=m
 CONFIG_SPI_INTEL_SPI=m
 
 [arm64]
+# For Marvell
+CONFIG_EEPROM_SFF_8436=m
+CONFIG_EEPROM_OPTOE=m
+CONFIG_I2C_MUX_GPIO=m
+CONFIG_MTD_RAW_NAND=m
+CONFIG_MTD_NAND_ECC_SW_BCH=y
+CONFIG_MTD_NAND_MARVELL=m
+CONFIG_SENSORS_EMC2305=m
+
+[marvell-arm64]
+CONFIG_MARVELL_AC5_WATCHDOG=m
 
 [armhf]
 CONFIG_EEPROM_SFF_8436=m
