From 2f432274de1e1fca86bf86c0bc55c78d505e5018 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 05:34:51 +0000
Subject: [PATCH 01/10] Move mrvl-prestera and sonic-platform-marvell submodule

'mrvl-prestera' and 'sonic-platform-marvell' submodules are
moved from 'marvell-arm64'to 'marvell'.
Additionaly submodules are changed to support multi-architecture build.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 .gitmodules                             | 8 ++++----
 platform/marvell/mrvl-prestera          | 1 +
 platform/marvell/sonic-platform-marvell | 1 +
 3 files changed, 6 insertions(+), 4 deletions(-)
 create mode 160000 platform/marvell/mrvl-prestera
 create mode 160000 platform/marvell/sonic-platform-marvell

diff --git a/.gitmodules b/.gitmodules
index e9b57673b2d..71cfffa1b6c 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -115,9 +115,9 @@
 [submodule "src/sonic-dash-api"]
 	path = src/sonic-dash-api
 	url = https://github.com/sonic-net/sonic-dash-api.git
-[submodule "platform/marvell-arm64/mrvl-prestera"]
-	path = platform/marvell-arm64/mrvl-prestera
+[submodule "platform/marvell/mrvl-prestera"]
+	path = platform/marvell/mrvl-prestera
 	url = https://github.com/Marvell-switching/mrvl-prestera.git
-[submodule "platform/marvell-arm64/sonic-platform-marvell"]
-	path = platform/marvell-arm64/sonic-platform-marvell
+[submodule "platform/marvell/sonic-platform-marvell"]
+	path = platform/marvell/sonic-platform-marvell
 	url = https://github.com/Marvell-switching/sonic-platform-arm64.git
diff --git a/platform/marvell/mrvl-prestera b/platform/marvell/mrvl-prestera
new file mode 160000
index 00000000000..b7a14a93b21
--- /dev/null
+++ b/platform/marvell/mrvl-prestera
@@ -0,0 +1 @@
+Subproject commit b7a14a93b21c099fab6b53f5fc4917ca0eb9b6c9
diff --git a/platform/marvell/sonic-platform-marvell b/platform/marvell/sonic-platform-marvell
new file mode 160000
index 00000000000..078a6fff30f
--- /dev/null
+++ b/platform/marvell/sonic-platform-marvell
@@ -0,0 +1 @@
+Subproject commit 078a6fff30f3af786aae1208588030a3fcfe0876

From 8aa32625af71c791fdf8c05fc5f0ccd923f67b2c Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 05:43:23 +0000
Subject: [PATCH 02/10] Create sonic-platform-nokia from marvell-arm64/armhf

sonic-platform-nokia is created from merge of 'marvell-armhf'
and 'marvell-arm64' in 'marvell'.
Additionaly changes are done to support multi-arch build.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 .../7215-a1/modules/Makefile                  |   1 +
 .../modules/cn9130_cpu_thermal_sensor.c       | 242 +++++++
 .../7215-a1/modules/nokia_7215_ixs_a1_cpld.c  | 615 ++++++++++++++++++
 .../7215-a1/scripts/cpu_wdt.py                |  46 ++
 .../7215-a1/scripts/nokia-7215-init.sh        | 110 ++++
 .../7215-a1/service/cpu_wdt.service           |   8 +
 .../7215-a1/service/nokia-7215init.service    |  11 +
 .../sonic-platform-nokia/7215-a1/setup.py     |  15 +
 .../7215-a1/sonic_platform/__init__.py        |   3 +
 .../7215-a1/sonic_platform/chassis.py         | 440 +++++++++++++
 .../7215-a1/sonic_platform/component.py       | 219 +++++++
 .../7215-a1/sonic_platform/eeprom.py          | 174 +++++
 .../7215-a1/sonic_platform/fan.py             | 332 ++++++++++
 .../7215-a1/sonic_platform/fan_drawer.py      | 102 +++
 .../7215-a1/sonic_platform/platform.py        |  22 +
 .../7215-a1/sonic_platform/psu.py             | 321 +++++++++
 .../7215-a1/sonic_platform/sfp.py             | 214 ++++++
 .../7215-a1/sonic_platform/sfp_event.py       | 119 ++++
 .../7215-a1/sonic_platform/test/README        |   1 +
 .../sonic_platform/test/test-chassis.py       |  72 ++
 .../sonic_platform/test/test-component.py     |  22 +
 .../sonic_platform/test/test-eeprom.py        |  25 +
 .../7215-a1/sonic_platform/test/test-fan.py   |  32 +
 .../7215-a1/sonic_platform/test/test-psu.py   |  40 ++
 .../7215-a1/sonic_platform/test/test-sfp.py   |  56 ++
 .../sonic_platform/test/test-thermal.py       |  50 ++
 .../sonic_platform/test/test-watchdog.py      |  22 +
 .../7215-a1/sonic_platform/thermal.py         | 265 ++++++++
 .../7215-a1/sonic_platform/thermal_actions.py | 222 +++++++
 .../sonic_platform/thermal_conditions.py      |  81 +++
 .../7215-a1/sonic_platform/thermal_infos.py   | 270 ++++++++
 .../7215-a1/sonic_platform/thermal_manager.py |  49 ++
 .../7215-a1/sonic_platform/watchdog.py        | 231 +++++++
 .../7215-a1/utils/sonic_ssd.py                |  47 ++
 .../7215/scripts/cpu_wdt.py                   |  46 ++
 .../7215/scripts/inband_mgmt.sh               |  28 +
 .../7215/scripts/nokia-7215_plt_setup.sh      |  31 +
 .../7215/scripts/nokia-7215init.sh            |  68 ++
 .../7215/service/cpu_wdt.service              |   8 +
 .../service/fstrim.timer/timer-override.conf  |   5 +
 .../7215/service/nokia-7215init.service       |  14 +
 .../sonic-platform-nokia/7215/setup.py        |  15 +
 .../7215/sonic_platform/__init__.py           |   4 +
 .../7215/sonic_platform/chassis.py            | 415 ++++++++++++
 .../7215/sonic_platform/component.py          | 175 +++++
 .../7215/sonic_platform/eeprom.py             | 284 ++++++++
 .../7215/sonic_platform/fan.py                | 384 +++++++++++
 .../7215/sonic_platform/fan_drawer.py         | 102 +++
 .../7215/sonic_platform/platform.py           |  22 +
 .../7215/sonic_platform/psu.py                | 317 +++++++++
 .../7215/sonic_platform/sfp.py                | 216 ++++++
 .../7215/sonic_platform/sfp_event.py          | 112 ++++
 .../7215/sonic_platform/test/README           |   1 +
 .../7215/sonic_platform/test/test-chassis.py  |  72 ++
 .../sonic_platform/test/test-component.py     |  22 +
 .../7215/sonic_platform/test/test-eeprom.py   |  25 +
 .../7215/sonic_platform/test/test-fan.py      |  32 +
 .../7215/sonic_platform/test/test-psu.py      |  40 ++
 .../7215/sonic_platform/test/test-sfp.py      |  56 ++
 .../7215/sonic_platform/test/test-thermal.py  |  50 ++
 .../7215/sonic_platform/test/test-watchdog.py |  22 +
 .../7215/sonic_platform/thermal.py            | 259 ++++++++
 .../7215/sonic_platform/thermal_actions.py    | 192 ++++++
 .../7215/sonic_platform/thermal_conditions.py |  81 +++
 .../7215/sonic_platform/thermal_infos.py      | 210 ++++++
 .../7215/sonic_platform/thermal_manager.py    |  49 ++
 .../7215/sonic_platform/watchdog.py           | 209 ++++++
 .../sonic-platform-nokia/debian/changelog     |   5 +
 .../sonic-platform-nokia/debian/compat        |   1 +
 .../sonic-platform-nokia/debian/control       |  20 +
 .../marvell/sonic-platform-nokia/debian/rules | 106 +++
 .../sonic-platform-nokia-7215-a1.install      |   6 +
 .../sonic-platform-nokia-7215-a1.postinst     |  48 ++
 .../debian/sonic-platform-nokia-7215.install  |   8 +
 .../debian/sonic-platform-nokia-7215.postinst |  16 +
 75 files changed, 8255 insertions(+)
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/modules/Makefile
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/modules/cn9130_cpu_thermal_sensor.c
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/modules/nokia_7215_ixs_a1_cpld.c
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/scripts/cpu_wdt.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/scripts/nokia-7215-init.sh
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/service/cpu_wdt.service
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/service/nokia-7215init.service
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/setup.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/__init__.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/chassis.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/component.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/eeprom.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan_drawer.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/platform.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/psu.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp_event.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/README
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-chassis.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-component.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-eeprom.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-fan.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-psu.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-sfp.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-thermal.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-watchdog.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_actions.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_conditions.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_infos.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_manager.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/watchdog.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215-a1/utils/sonic_ssd.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/scripts/cpu_wdt.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/scripts/inband_mgmt.sh
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215_plt_setup.sh
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/service/cpu_wdt.service
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/service/nokia-7215init.service
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/setup.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/__init__.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/chassis.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/component.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/eeprom.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/platform.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/psu.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/README
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
 create mode 100755 platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
 create mode 100644 platform/marvell/sonic-platform-nokia/7215/sonic_platform/watchdog.py
 create mode 100755 platform/marvell/sonic-platform-nokia/debian/changelog
 create mode 100644 platform/marvell/sonic-platform-nokia/debian/compat
 create mode 100755 platform/marvell/sonic-platform-nokia/debian/control
 create mode 100755 platform/marvell/sonic-platform-nokia/debian/rules
 create mode 100644 platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.install
 create mode 100644 platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.postinst
 create mode 100644 platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
 create mode 100644 platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst

diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/modules/Makefile b/platform/marvell/sonic-platform-nokia/7215-a1/modules/Makefile
new file mode 100644
index 00000000000..d82a871c1cc
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/modules/Makefile
@@ -0,0 +1 @@
+obj-m:= nokia_7215_ixs_a1_cpld.o cn9130_cpu_thermal_sensor.o
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/modules/cn9130_cpu_thermal_sensor.c b/platform/marvell/sonic-platform-nokia/7215-a1/modules/cn9130_cpu_thermal_sensor.c
new file mode 100644
index 00000000000..e11e281579f
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/modules/cn9130_cpu_thermal_sensor.c
@@ -0,0 +1,242 @@
+/*
+ * HWMON Driver for CN9130 thermal sensor
+ *
+ * Author: Natarajan Subbiramani <nataraja.subbiramani.ext@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+
+#define CN9130_DEFAULT_TEMP_CRIT 100000
+#define CN9130_DEFAULT_TEMP_MAX  106000
+
+#define CN9130_TEMP_BASE_ADDR 0xF06F8080
+#define CN9130_TSEN_REG_CTRL_0_OFFSET 0x4
+#define CN9130_TSEN_REG_CTRL_1_OFFSET 0x8
+#define CN9130_TSEN_REG_STATUS_OFFSET 0xC
+#define CN9130_TSEN_SENSOR_MAX_ID 6
+static unsigned long thermal_base_addr=CN9130_TEMP_BASE_ADDR;
+module_param(thermal_base_addr, ulong, 0444);
+MODULE_PARM_DESC(thermal_base_addr,
+        "Initialize the base address of the thermal sensor");
+
+struct cn9130_thermal_data {
+    struct device *dev;
+    struct device *hwmon_dev;
+    uint8_t * __iomem temp_base;
+    int temp_input;
+    int temp_crit;
+    int temp_max;
+};
+
+static long cn9130_thermal_read_reg_in_mcelcius(struct device *dev, struct cn9130_thermal_data *data)
+{
+    volatile uint8_t * __iomem temp_base = data->temp_base;
+    uint32_t regval;
+    uint32_t status_regval=0;
+    uint32_t output=data->temp_max;
+
+    //STOP MEASUREMENT
+    regval = readl(temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+    regval &= ~( 1 << 0); //TSEN_STOP
+    writel(regval, temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+
+    //delay for 1ms
+    mdelay(1);
+
+    //Read thermal value
+    status_regval = readl(temp_base+CN9130_TSEN_REG_STATUS_OFFSET);
+    dev_dbg(dev, "%s: cn9130_thermal_read_reg_in_mcelcius: addr: 0x%lx value:0x%x\n", dev_name(data->hwmon_dev), temp_base+CN9130_TSEN_REG_STATUS_OFFSET, status_regval);
+
+    //START MEASUREMENT
+    regval = readl(temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+    regval |= 1 << 0; //TSEN_START
+    writel(regval, temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+
+    //Validate data
+    if(status_regval &= 0x3ff) {
+        //Convert it to milli-celcius
+        output = 150000 - (~(status_regval-1) & 0x3ff) * 423;
+    }
+
+    return output;
+}
+static int cn9130_thermal_read(struct device *dev, enum hwmon_sensor_types type,
+        u32 attr, int channel, long *val)
+{
+    struct cn9130_thermal_data *data = dev_get_drvdata(dev);
+
+    switch (type) {
+        case hwmon_temp:
+            switch (attr) {
+                case hwmon_temp_input:
+                    *val = cn9130_thermal_read_reg_in_mcelcius(dev, data);
+                    break;
+                case hwmon_temp_crit:
+                    *val = data->temp_crit;
+                    break;
+                case hwmon_temp_max:
+                    *val = data->temp_max;
+                    break;
+                default:
+                    return -EINVAL;
+            }
+            break;
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+static int cn9130_thermal_write(struct device *dev, enum hwmon_sensor_types type,
+        u32 attr, int channel, long val)
+{
+    struct cn9130_thermal_data *data = dev_get_drvdata(dev);
+    switch (type) {
+        case hwmon_temp:
+            switch (attr) {
+                case hwmon_temp_crit:
+                    data->temp_crit = val;
+                    break;
+                case hwmon_temp_max:
+                    data->temp_max = val;
+                    break;
+                default:
+                    return -EINVAL;
+            }
+            break;
+        default:
+            return -EINVAL;
+    }
+    return 0;
+}
+
+
+static umode_t cn9130_thermal_is_visible(const void *data, enum hwmon_sensor_types type,
+        u32 attr, int channel)
+{
+    switch (type) {
+        case hwmon_temp:
+            switch (attr) {
+                case hwmon_temp_input:
+                    return 0444;
+                case hwmon_temp_crit:
+                case hwmon_temp_max:
+                    return 0644;
+            }
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+
+static const struct hwmon_channel_info *cn9130_thermal_info[] = {
+    HWMON_CHANNEL_INFO(temp,
+            HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT),
+    NULL
+};
+
+static const struct hwmon_ops cn9130_thermal_hwmon_ops = {
+    .is_visible = cn9130_thermal_is_visible,
+    .read = cn9130_thermal_read,
+    .write = cn9130_thermal_write,
+};
+
+static const struct hwmon_chip_info cn9130_thermal_chip_info = {
+    .ops = &cn9130_thermal_hwmon_ops,
+    .info = cn9130_thermal_info,
+};
+
+static const struct file_operations fops = {
+    .owner          = THIS_MODULE,
+};
+
+struct miscdevice cn9130_thermal_device = {
+    .minor = TEMP_MINOR,
+    .name = "cn9130_thermal",
+    .fops = &fops,
+};
+
+static int __init cn9130_thermal_init_driver(void)
+{
+    struct device *dev;
+    struct cn9130_thermal_data *thermal_data;
+    int err;
+    void * __iomem reg;
+    uint32_t regval=0;
+
+    err = misc_register(&cn9130_thermal_device);
+    if (err) {
+        pr_err("cn9130_thermal misc_register failed!!!\n");
+        return err;
+    }
+
+    dev = cn9130_thermal_device.this_device;
+    thermal_data = devm_kzalloc(dev, sizeof(struct cn9130_thermal_data), GFP_KERNEL);
+    if (!thermal_data)
+        return -ENOMEM;
+
+    thermal_data->dev = dev;
+    thermal_data->temp_crit  = CN9130_DEFAULT_TEMP_CRIT;
+    thermal_data->temp_max   = CN9130_DEFAULT_TEMP_MAX;
+
+    thermal_data->hwmon_dev = devm_hwmon_device_register_with_info(dev, cn9130_thermal_device.name,
+            thermal_data, &cn9130_thermal_chip_info,
+            NULL);
+    if (IS_ERR(thermal_data->hwmon_dev)) {
+        dev_err(dev, "%s: hwmon registration failed.\n", cn9130_thermal_device.name);
+        return PTR_ERR(thermal_data->hwmon_dev);
+    }
+
+    reg = devm_ioremap(dev, thermal_base_addr, 16);
+    if (IS_ERR(reg)) {
+        dev_err(dev, "%s: base addr remap failed\n", cn9130_thermal_device.name);
+        return PTR_ERR(reg);
+    }
+    thermal_data->temp_base = reg;
+
+    /*Enable measurement*/
+    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+    regval |= 1 << 2; //TSEN_EN
+    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+    mdelay(10);
+
+    // Set temperature reading zone as max reading
+    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_1_OFFSET);
+    regval &= ~(0x7 << 21);
+    regval |= (CN9130_TSEN_SENSOR_MAX_ID & 0x7) << 21;
+    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_1_OFFSET);
+
+    //START MEASUREMENT
+    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+    regval |= 1 << 0; //TSEN_START
+    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
+
+    dev_info(dev, "%s: initialized. base_addr: 0x%lx virt_addr:0x%lx\n", dev_name(thermal_data->hwmon_dev), thermal_base_addr, thermal_data->temp_base);
+
+    return 0;
+}
+
+static void __exit cn9101_thermal_exit_driver(void)
+{
+    misc_deregister(&cn9130_thermal_device);
+}
+
+module_init(cn9130_thermal_init_driver);
+module_exit(cn9101_thermal_exit_driver);
+
+MODULE_AUTHOR("Natarajan Subbiramani <natarajan.subbiramani.ext@nokia.com>");
+MODULE_DESCRIPTION("CN9130 CPU Thermal sensor Driver");
+MODULE_LICENSE("GPL");
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/modules/nokia_7215_ixs_a1_cpld.c b/platform/marvell/sonic-platform-nokia/7215-a1/modules/nokia_7215_ixs_a1_cpld.c
new file mode 100644
index 00000000000..3c063977026
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/modules/nokia_7215_ixs_a1_cpld.c
@@ -0,0 +1,615 @@
+/*
+ * CPLD driver for Nokia-7215-IXS-A1 Router
+ *
+ * Copyright (C) 2023 Nokia Corporation.
+ * Natarajan Subbiramani <natarajan.subbiramani.ext@nokia.com>
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * see <http://www.gnu.org/licenses/>
+ *
+ * Based on ad7414.c
+ * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/mutex.h>
+
+#define DRIVER_NAME "nokia_7215_a1_cpld"
+
+// REG ADDRESS-MAP
+#define BOARD_ID_REG                  0x00
+#define RESET_CAUSE_REG               0x01
+#define CPLD_VERSION_REG              0x02
+#define SFP_PRESENCE_REG              0x03
+#define SFP_LOS_REG                   0x04
+#define SFP_TX_DISABLE_REG            0x05
+#define MAC_INIT_STATUS_REG           0x06
+#define SYSTEM_STATUS_LED_CONTROL_REG 0x07
+#define POWER_AND_FAN_LED_CONTROL_REG 0x08
+#define SFP_TX_FAULT_STATUS_REG       0x09
+#define TEMP_EVENT_STATUS_REG         0x0D
+#define TEMP_EVENT_MASK_REG           0x0E 
+#define SFP_LED_TEST_REG              0x0F
+#define RESET_REG                     0x10
+#define MISC_IRQ_LIVE_STATE_REG       0x12
+#define INTERRUPT_REG                 0x13
+#define INTERRUPT_MASK_REG            0x14
+#define MISC_INT_STATUS_REG           0x16
+#define MISC_INT_MASK_REG             0x18
+#define GPIO_DIRECTION_REG            0x19
+#define GPIO_DATA_IN_REG              0x1A
+#define GPIO_DATA_OUT_REG             0x1B
+#define SCRATCH_REG                   0xFE
+
+//REG BIT FIELD POSITIONS
+#define RESET_CAUSE_REG_COLD_RESET    0x1
+#define RESET_CAUSE_REG_WARM_RESET    0x2
+#define RESET_CAUSE_REG_WDOG_RESET    0x4
+#define RESET_CAUSE_REG_SYS_RESET     0x8
+#define RESET_CAUSE_REG_THERMAL_OL    0x10
+
+#define SFP_PRESENCE_REG_SFP49        0x0
+#define SFP_PRESENCE_REG_SFP50        0x1
+#define SFP_PRESENCE_REG_SFP51        0x2
+#define SFP_PRESENCE_REG_SFP52        0x3
+
+#define SFP_LOS_REG_SFP49             0x0
+#define SFP_LOS_REG_SFP50             0x1
+#define SFP_LOS_REG_SFP51             0x2
+#define SFP_LOS_REG_SFP52             0x3
+
+#define SFP_TX_DISABLE_REG_SFP49      0x0
+#define SFP_TX_DISABLE_REG_SFP50      0x1
+#define SFP_TX_DISABLE_REG_SFP51      0x2
+#define SFP_TX_DISABLE_REG_SFP52      0x3
+#define SFP_TX_DISABLE_REG_LED_MUX    0x4
+
+#define TS1_ALERT_EVENT               0x2
+#define TS2_ALERT_EVENT               0x4
+#define TS3_ALERT_EVENT               0x8
+#define CPU_TEMP_EVENT                0x10
+#define AC5X_HIGHTEMP_EVENT           0x20  
+#define DIMM_TEMP_EVENT               0x40     
+
+#define MAC_INIT_STATUS_REG_INIT_DONE 0x2
+
+enum system_status_led_mode {
+    SYSTEM_STATUS_LED_OFF,
+    SYSTEM_STATUS_LED_AMBER,
+    SYSTEM_STATUS_LED_GREEN,
+    SYSTEM_STATUS_LED_AMBERBLINK8,
+    SYSTEM_STATUS_LED_GREENBLINK4,
+    SYSTEM_STATUS_LED_AMBERBLINK4,
+    SYSTEM_STATUS_LED_GREENBLINK1,
+    SYSTEM_STATUS_LED_COLORTOGGLE,
+    SYSTEM_STATUS_LED_INVALID
+};
+
+char *system_status_led_mode_str[]={"off", "amber", "green", "blink8-amber", "blink4-green",
+                                    "blink4-amber", "blink1-green", "toggle", "invalid"};
+
+#define POWER_LED_OFFSET  6
+#define FAN_LED_OFFSET    4
+enum power_fan_led_mode {
+    POWER_FAN_LED_OFF,
+    POWER_FAN_LED_GREEN,
+    POWER_FAN_LED_AMBER,
+    POWER_FAN_LED_GREEN_BLINK,
+    POWER_FAN_INVALID
+};
+char *power_fan_led_mode_str[]={"off", "green", "amber", "blink-green", "invalid"};
+
+#define SFP_TX_FAULT_STATUS_SFP49  0x0
+#define SFP_TX_FAULT_STATUS_SFP50  0x1
+#define SFP_TX_FAULT_STATUS_SFP51  0x2
+#define SFP_TX_FAULT_STATUS_SFP52  0x3
+
+#define RESET_REG_WARM_RESET   0x0
+#define RESET_REG_COLD_RESET   0x4
+#define RESET_REG_I2CMUX_RESET 0x6
+#define RESET_REG_ZL_RESET     0x7
+
+static const unsigned short cpld_address_list[] = {0x41, I2C_CLIENT_END};
+
+struct cpld_data {
+    struct i2c_client *client;
+    struct mutex  update_lock;
+    int mb_hw_version;
+    int cpld_version;
+};
+
+static int nokia_7215_ixs_a1_cpld_read(struct cpld_data *data, u8 reg)
+{
+    int val=0;
+    struct i2c_client *client=data->client;
+
+    mutex_lock(&data->update_lock);
+    val = i2c_smbus_read_byte_data(client, reg);
+    if (val < 0) {
+         dev_err(&client->dev, "CPLD READ ERROR: reg(0x%02x) err %d\n", reg, val);
+    }
+    mutex_unlock(&data->update_lock);
+
+    return val;
+}
+
+static void nokia_7215_ixs_a1_cpld_write(struct cpld_data *data, u8 reg, u8 value)
+{
+    int res=0;
+    struct i2c_client *client=data->client;
+
+    mutex_lock(&data->update_lock);
+    res = i2c_smbus_write_byte_data(client, reg, value);
+    if (res < 0) {
+        dev_err(&client->dev, "CPLD WRITE ERROR: reg(0x%02x) err %d\n", reg, res);
+    }
+    mutex_unlock(&data->update_lock);
+}
+
+static ssize_t show_mainboard_hwversion(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    return sprintf(buf,"0x%02x\n",data->mb_hw_version);
+}
+
+static ssize_t show_last_reset_cause(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 val=0;
+    char *reason=NULL;
+    val = nokia_7215_ixs_a1_cpld_read(data, RESET_CAUSE_REG);
+    switch (val) {
+    case RESET_CAUSE_REG_COLD_RESET:
+        reason="cold_reset";
+        break;
+    case RESET_CAUSE_REG_WARM_RESET:
+        reason="warm_reset";
+        break;
+    case RESET_CAUSE_REG_WDOG_RESET:
+        reason="wdog_reset";
+        break;
+    case RESET_CAUSE_REG_SYS_RESET:
+        reason="sys_reset";
+        break;
+    case RESET_CAUSE_REG_THERMAL_OL:
+        reason="thermal_reset";
+        break;
+        
+    default:
+        reason="unknown";
+        break;
+    }
+    return sprintf(buf,"%s\n",reason);
+}
+
+static ssize_t show_cpld_version(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    return sprintf(buf,"0x%02x\n",data->cpld_version);
+}
+
+static ssize_t show_sfp_present(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, SFP_PRESENCE_REG);
+    
+    /* If the bit is set, SFP is not present. So, we are toggling intentionally */
+    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 0:1);
+}
+
+static ssize_t show_sfp_los(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, SFP_LOS_REG);
+    
+    /* If the bit is set, LOS condition */
+    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
+}
+
+static ssize_t show_sfp_tx_disable(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_DISABLE_REG);
+    
+    /* If the bit is set, Tx is disabled */
+    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
+}
+
+static ssize_t set_sfp_tx_disable(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 reg_val=0, usr_val=0, mask;
+    int ret=kstrtou8(buf,10, &usr_val);
+    if (ret != 0) {
+        return ret; 
+    }
+    if (usr_val > 1) {
+        return -EINVAL;
+    }
+
+    mask = (~(1 << sda->index)) & 0xFF;
+    reg_val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_DISABLE_REG);
+    reg_val = reg_val & mask;
+
+    usr_val = usr_val << sda->index;
+
+    nokia_7215_ixs_a1_cpld_write(data, SFP_TX_DISABLE_REG, (reg_val|usr_val));
+
+    return count;
+
+}
+
+static ssize_t show_system_led_status(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, SYSTEM_STATUS_LED_CONTROL_REG);
+    if (val > SYSTEM_STATUS_LED_INVALID) {
+        val = SYSTEM_STATUS_LED_INVALID;
+    }
+    return sprintf(buf,"%s\n",system_status_led_mode_str[val]);
+}
+
+static ssize_t set_system_led_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    int mode;
+
+    for(mode=SYSTEM_STATUS_LED_OFF; mode<SYSTEM_STATUS_LED_INVALID; mode++) {
+        if(strncmp(buf, system_status_led_mode_str[mode],strlen(system_status_led_mode_str[mode]))==0) {
+            nokia_7215_ixs_a1_cpld_write(data, SYSTEM_STATUS_LED_CONTROL_REG, mode);
+            break;
+        }
+    }
+
+    return count;
+}
+
+static ssize_t show_power_fan_led_status(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val = nokia_7215_ixs_a1_cpld_read(data, POWER_AND_FAN_LED_CONTROL_REG);
+    val = (val >> sda->index) & 0x3;
+    return sprintf(buf,"%s\n",power_fan_led_mode_str[val]);
+}
+
+static ssize_t set_power_fan_led_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 reg_val=0, mask=0, usr_val=0;
+    int i;
+
+    mask = (~(0x3 << sda->index)) & 0xFF;
+    reg_val = nokia_7215_ixs_a1_cpld_read(data, POWER_AND_FAN_LED_CONTROL_REG);
+    reg_val = reg_val & mask;
+
+    for(i=POWER_FAN_LED_OFF; i<POWER_FAN_INVALID; i++) {
+        if(strncmp(buf, power_fan_led_mode_str[i],strlen(power_fan_led_mode_str[i]))==0) {
+            usr_val = i << sda->index;
+            nokia_7215_ixs_a1_cpld_write(data, POWER_AND_FAN_LED_CONTROL_REG, reg_val|usr_val);
+            break;
+        }
+    }
+
+    return count;
+}
+
+static ssize_t show_sfp_tx_fault(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_FAULT_STATUS_REG);
+    
+    /* If the bit is set, TX fault condition */
+    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
+}
+
+static ssize_t show_temp_event_status(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 val=0;
+    char *reason=NULL;
+    val = nokia_7215_ixs_a1_cpld_read(data, TEMP_EVENT_STATUS_REG);
+    switch (val) {
+    case TS1_ALERT_EVENT:
+        reason="ts1";
+        break;
+    case TS2_ALERT_EVENT:
+        reason="ts2";
+        break;
+    case TS3_ALERT_EVENT:
+        reason="ts3";
+        break;
+    case CPU_TEMP_EVENT:
+        reason="cpu";
+        break;
+    case AC5X_HIGHTEMP_EVENT:
+        reason="ac5x";
+        break;
+    case DIMM_TEMP_EVENT:
+        reason="dimm";
+        break;
+ 
+    default:
+        reason="none";
+        break;
+    }
+    return sprintf(buf,"0x%02x %s\n",val, reason);
+
+}
+
+static ssize_t show_sfp_ledtest_status(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 val = nokia_7215_ixs_a1_cpld_read(data, SFP_LED_TEST_REG);
+    return sprintf(buf,"0x%02x\n",val);
+}
+
+static ssize_t set_sfp_ledtest_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 usr_val=0;
+    int ret=kstrtou8(buf,16, &usr_val);
+    if (ret != 0) {
+        return ret; 
+    }
+
+    nokia_7215_ixs_a1_cpld_write(data, SFP_LED_TEST_REG, usr_val);
+    return count;
+}
+
+static ssize_t show_temp_event_mask_status(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 val = nokia_7215_ixs_a1_cpld_read(data, TEMP_EVENT_MASK_REG);
+    return sprintf(buf,"0x%02x\n",val);
+}
+
+static ssize_t set_temp_event_mask_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    u8 usr_val=0;
+    int ret=kstrtou8(buf,16, &usr_val);
+    if (ret != 0) {
+        return ret; 
+    }
+
+    nokia_7215_ixs_a1_cpld_write(data, TEMP_EVENT_MASK_REG, usr_val);
+    return count;
+}
+
+static ssize_t show_reset_reg(struct device *dev, struct device_attribute *devattr, char *buf) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 val=0;
+    val = nokia_7215_ixs_a1_cpld_read(data, RESET_REG);
+
+    return sprintf(buf,"0x%02x\n",(val>>sda->index) & 0x1 ? 1:0);
+}
+
+static ssize_t set_reset_reg(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
+{
+    struct cpld_data *data = dev_get_drvdata(dev);
+    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
+    u8 reg_val=0, usr_val=0, mask;
+    int ret=kstrtou8(buf,10, &usr_val);
+    if (ret != 0) {
+        return ret; 
+    }
+    if (usr_val > 1) {
+        return -EINVAL;
+    }
+
+    mask = (~(1 << sda->index)) & 0xFF;
+    reg_val = nokia_7215_ixs_a1_cpld_read(data, RESET_REG);
+    reg_val = reg_val & mask;
+
+    usr_val = usr_val << sda->index;
+
+    nokia_7215_ixs_a1_cpld_write(data, RESET_REG, (reg_val|usr_val));
+
+    return count;
+}
+
+
+/* sysfs attributes */
+static SENSOR_DEVICE_ATTR(mbhwversion, S_IRUGO, show_mainboard_hwversion, NULL, 0);
+static SENSOR_DEVICE_ATTR(last_reset_cause, S_IRUGO, show_last_reset_cause, NULL, 0);
+static SENSOR_DEVICE_ATTR(cpldversion, S_IRUGO, show_cpld_version, NULL, 0);
+static SENSOR_DEVICE_ATTR(sfp49_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP49);
+static SENSOR_DEVICE_ATTR(sfp50_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP50);
+static SENSOR_DEVICE_ATTR(sfp51_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP51);
+static SENSOR_DEVICE_ATTR(sfp52_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP52);
+static SENSOR_DEVICE_ATTR(sfp49_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP49);
+static SENSOR_DEVICE_ATTR(sfp50_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP50);
+static SENSOR_DEVICE_ATTR(sfp51_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP51);
+static SENSOR_DEVICE_ATTR(sfp52_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP52);
+static SENSOR_DEVICE_ATTR(sfp49_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP49);
+static SENSOR_DEVICE_ATTR(sfp50_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP50);
+static SENSOR_DEVICE_ATTR(sfp51_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP51);
+static SENSOR_DEVICE_ATTR(sfp52_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP52);
+static SENSOR_DEVICE_ATTR(system_led, S_IRUGO | S_IWUSR, show_system_led_status, set_system_led_status, 0);
+static SENSOR_DEVICE_ATTR(psu_led, S_IRUGO | S_IWUSR, show_power_fan_led_status, set_power_fan_led_status, POWER_LED_OFFSET);
+static SENSOR_DEVICE_ATTR(fan_led, S_IRUGO | S_IWUSR, show_power_fan_led_status, set_power_fan_led_status, FAN_LED_OFFSET);
+static SENSOR_DEVICE_ATTR(sfp49_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP49);
+static SENSOR_DEVICE_ATTR(sfp50_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP50);
+static SENSOR_DEVICE_ATTR(sfp51_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP51);
+static SENSOR_DEVICE_ATTR(sfp52_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP52);
+static SENSOR_DEVICE_ATTR(temp_event_status, S_IRUGO, show_temp_event_status, NULL, 0);
+static SENSOR_DEVICE_ATTR(sfp_led_test, S_IRUGO | S_IWUSR, show_sfp_ledtest_status, set_sfp_ledtest_status, 0);
+static SENSOR_DEVICE_ATTR(temp_event_mask, S_IRUGO | S_IWUSR, show_temp_event_mask_status, set_temp_event_mask_status, 0);
+static SENSOR_DEVICE_ATTR(warm_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_WARM_RESET);
+static SENSOR_DEVICE_ATTR(cold_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_COLD_RESET);
+static SENSOR_DEVICE_ATTR(i2cmux_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_I2CMUX_RESET);
+static SENSOR_DEVICE_ATTR(zarlink_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_ZL_RESET);
+
+static struct attribute *nokia_7215_ixs_a1_cpld_attributes[] = {
+    &sensor_dev_attr_mbhwversion.dev_attr.attr,
+    &sensor_dev_attr_last_reset_cause.dev_attr.attr,
+    &sensor_dev_attr_cpldversion.dev_attr.attr,
+    &sensor_dev_attr_sfp49_present.dev_attr.attr,
+    &sensor_dev_attr_sfp50_present.dev_attr.attr,
+    &sensor_dev_attr_sfp51_present.dev_attr.attr,
+    &sensor_dev_attr_sfp52_present.dev_attr.attr,
+    &sensor_dev_attr_sfp49_los.dev_attr.attr,
+    &sensor_dev_attr_sfp50_los.dev_attr.attr,
+    &sensor_dev_attr_sfp51_los.dev_attr.attr,
+    &sensor_dev_attr_sfp52_los.dev_attr.attr,
+    &sensor_dev_attr_sfp49_tx_disable.dev_attr.attr,
+    &sensor_dev_attr_sfp50_tx_disable.dev_attr.attr,
+    &sensor_dev_attr_sfp51_tx_disable.dev_attr.attr,
+    &sensor_dev_attr_sfp52_tx_disable.dev_attr.attr,
+    &sensor_dev_attr_temp_event_status.dev_attr.attr,
+    &sensor_dev_attr_system_led.dev_attr.attr,
+    &sensor_dev_attr_psu_led.dev_attr.attr,
+    &sensor_dev_attr_fan_led.dev_attr.attr,
+    &sensor_dev_attr_sfp49_tx_fault.dev_attr.attr,
+    &sensor_dev_attr_sfp50_tx_fault.dev_attr.attr,
+    &sensor_dev_attr_sfp51_tx_fault.dev_attr.attr,
+    &sensor_dev_attr_sfp52_tx_fault.dev_attr.attr,
+    &sensor_dev_attr_sfp_led_test.dev_attr.attr,
+    &sensor_dev_attr_temp_event_mask.dev_attr.attr,
+    &sensor_dev_attr_warm_reset.dev_attr.attr,
+    &sensor_dev_attr_cold_reset.dev_attr.attr,
+    &sensor_dev_attr_i2cmux_reset.dev_attr.attr,
+    &sensor_dev_attr_zarlink_reset.dev_attr.attr,
+    NULL
+};
+
+static const struct attribute_group nokia_7215_ixs_a1_cpld_group = {
+    .attrs = nokia_7215_ixs_a1_cpld_attributes,
+};
+
+
+static int nokia_7215_ixs_a1_cpld_probe(struct i2c_client *client,
+        const struct i2c_device_id *dev_id)
+{
+    int status;
+     struct cpld_data *data=NULL;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+        dev_err(&client->dev, "CPLD PROBE ERROR: i2c_check_functionality failed (0x%x)\n", client->addr);
+        status = -EIO;
+        goto exit;
+    }
+
+    dev_info(&client->dev, "Nokia-7215-IXS-A1 CPLD chip found.\n");
+    data = kzalloc(sizeof(struct cpld_data), GFP_KERNEL);
+
+    if (!data) {
+        dev_err(&client->dev, "CPLD PROBE ERROR: Can't allocate memory\n");
+        status = -ENOMEM;
+        goto exit;
+    }
+
+    data->client = client;
+    i2c_set_clientdata(client, data);
+    mutex_init(&data->update_lock);
+
+    status = sysfs_create_group(&client->dev.kobj, &nokia_7215_ixs_a1_cpld_group);
+    if (status) {
+        dev_err(&client->dev, "CPLD INIT ERROR: Cannot create sysfs\n");
+        goto exit;
+    }
+
+    data->mb_hw_version = nokia_7215_ixs_a1_cpld_read(data, BOARD_ID_REG);
+    data->cpld_version = nokia_7215_ixs_a1_cpld_read(data, CPLD_VERSION_REG);
+
+    return 0;
+
+exit:
+    return status;
+}
+
+static void nokia_7215_ixs_a1_cpld_remove(struct i2c_client *client)
+{
+    struct cpld_data *data = i2c_get_clientdata(client);
+    sysfs_remove_group(&client->dev.kobj, &nokia_7215_ixs_a1_cpld_group);
+    kfree(data);
+    return;
+}
+
+static const struct of_device_id nokia_7215_ixs_a1_cpld_of_ids[] = {
+    {
+        .compatible = "nokia,7215_a1_cpld",
+        .data = (void *) 0,
+    },
+    { },
+};
+MODULE_DEVICE_TABLE(of, nokia_7215_ixs_a1_cpld_of_ids);
+
+static const struct i2c_device_id nokia_7215_ixs_a1_cpld_ids[] = {
+    { DRIVER_NAME, 0 },
+    {}
+};
+MODULE_DEVICE_TABLE(i2c, nokia_7215_ixs_a1_cpld_ids);
+
+static struct i2c_driver nokia_7215_ixs_a1_cpld_driver = {
+    .driver = {
+        .name     = DRIVER_NAME,
+        .of_match_table = of_match_ptr(nokia_7215_ixs_a1_cpld_of_ids),
+    },
+    .probe        = nokia_7215_ixs_a1_cpld_probe,
+    .remove       = nokia_7215_ixs_a1_cpld_remove,
+    .id_table     = nokia_7215_ixs_a1_cpld_ids,
+    .address_list = cpld_address_list,
+};
+
+
+
+static int __init nokia_7215_ixs_a1_cpld_init(void)
+{
+    return i2c_add_driver(&nokia_7215_ixs_a1_cpld_driver);
+}
+
+static void __exit nokia_7215_ixs_a1_cpld_exit(void)
+{
+    i2c_del_driver(&nokia_7215_ixs_a1_cpld_driver);
+}
+
+MODULE_AUTHOR("Nokia");
+MODULE_DESCRIPTION("NOKIA-7215-IXS-A1 CPLD driver");
+MODULE_LICENSE("GPL");
+
+module_init(nokia_7215_ixs_a1_cpld_init);
+module_exit(nokia_7215_ixs_a1_cpld_exit);
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/scripts/cpu_wdt.py b/platform/marvell/sonic-platform-nokia/7215-a1/scripts/cpu_wdt.py
new file mode 100755
index 00000000000..b23cd46566e
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/scripts/cpu_wdt.py
@@ -0,0 +1,46 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+from sonic_py_common import logger
+import time
+import os
+import signal
+import sys
+
+
+TIMEOUT=180
+KEEPALIVE=60
+sonic_logger = logger.Logger('Watchdog')
+sonic_logger.set_min_log_priority_info()
+time.sleep(60)
+chassis = Chassis()
+watchdog = chassis.get_watchdog()
+
+def stopWdtService(signal, frame):
+    watchdog._disablewatchdog()
+    sonic_logger.log_notice("CPUWDT Disabled: watchdog armed=%s" % watchdog.is_armed() )
+    sys.exit()
+
+def main():
+
+    signal.signal(signal.SIGHUP, signal.SIG_IGN)
+    signal.signal(signal.SIGINT, stopWdtService)
+    signal.signal(signal.SIGTERM, stopWdtService)
+    
+    watchdog.arm(TIMEOUT)
+    sonic_logger.log_notice("CPUWDT Enabled: watchdog armed=%s" % watchdog.is_armed() )
+
+
+    while True:
+        time.sleep(KEEPALIVE)
+        watchdog._keepalive()
+        sonic_logger.log_info("CPUWDT keepalive")
+    done
+
+    stopWdtService
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/scripts/nokia-7215-init.sh b/platform/marvell/sonic-platform-nokia/7215-a1/scripts/nokia-7215-init.sh
new file mode 100644
index 00000000000..a69c871b028
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/scripts/nokia-7215-init.sh
@@ -0,0 +1,110 @@
+#!/bin/bash
+
+# Platform init script
+
+# Load required kernel-mode drivers
+load_kernel_drivers() {
+    echo "Loading Kernel Drivers"
+    sudo insmod /lib/modules/6.1.0-11-2-arm64/kernel/extra/nokia_7215_ixs_a1_cpld.ko
+    sudo insmod /lib/modules/6.1.0-11-2-arm64/kernel/extra/cn9130_cpu_thermal_sensor.ko
+}
+
+fw_uboot_env_cfg()
+{
+    echo "Setting up U-Boot environment for Nokia-7215-A1"
+    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x10000'
+    echo $FW_ENV_DEFAULT > /etc/fw_env.config
+}
+
+nokia_7215_profile()
+{
+    MAC_ADDR=$(sudo decode-syseeprom -m)
+    sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g" /usr/share/sonic/device/arm64-nokia_ixs7215_52xb-r0/Nokia-7215-A1/profile.ini
+    sudo ifconfig eth0 hw ether $MAC_ADDR
+    echo "Nokia-7215-A1: Updating switch mac address ${MAC_ADDR}"
+}
+file_exists() {
+    # Wait 10 seconds max till file exists
+    for((i=0; i<10; i++));
+    do
+        if [ -f $1 ]; then
+            return 1
+        fi
+        sleep 1
+    done
+    return 0
+ }
+
+# - Main entry
+
+# Install kernel drivers required for i2c bus access
+load_kernel_drivers
+
+#setting up uboot environment
+fw_uboot_env_cfg
+
+# Enumerate the SFP eeprom device on each mux channel
+echo pca9546 0x70> /sys/bus/i2c/devices/i2c-1/new_device
+
+# Enumerate power monitor
+echo ina230 0x40 > /sys/bus/i2c/devices/i2c-0/new_device
+
+# Enumerate fan
+echo emc2305 0x2f > /sys/bus/i2c/devices/i2c-0/new_device
+
+# Enumerate Thermals
+echo tmp75 0x48 > /sys/bus/i2c/devices/i2c-0/new_device
+echo tmp75 0x49 > /sys/bus/i2c/devices/i2c-0/new_device
+echo tmp75 0x4A > /sys/bus/i2c/devices/i2c-0/new_device
+
+#Enumerate CPLD
+echo nokia_7215_a1_cpld 0x41 > /sys/bus/i2c/devices/i2c-0/new_device
+
+# Enumerate system eeprom
+echo 24c64 0x53 > /sys/class/i2c-adapter/i2c-0/new_device
+
+file_exists /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
+status=$?
+if [ "$status" == "1" ]; then
+    chmod 644 /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
+else
+    echo "SYSEEPROM file not foud"
+fi
+
+#Enumurate GPIO
+echo 41 > /sys/class/gpio/export
+echo 61 > /sys/class/gpio/export
+echo 62 > /sys/class/gpio/export
+chmod 666 /sys/class/gpio/gpio41/value
+
+# Get list of the mux channels
+for((i=0; i<10; i++));
+    do  
+        ismux_bus=$(i2cdetect -l|grep mux|cut -f1)
+        if [[ $ismux_bus ]]; then
+            break;
+        fi
+        sleep 1
+    done
+
+# Enumerate the SFP eeprom device on each mux channel
+for mux in ${ismux_bus}
+do
+    echo optoe2 0x50 > /sys/class/i2c-adapter/${mux}/new_device
+done
+
+# Enable optical SFP Tx
+for i in {49..52}
+do
+    echo 0 > /sys/bus/i2c/devices/0-0041/sfp${i}_tx_disable
+done
+
+#slow down fan speed to 50% untill thermal algorithm kicks in
+i2c_path="/sys/bus/i2c/devices/0-002f/hwmon/hwmon?"  
+echo 128 > $i2c_path/pwm1
+echo 128 > $i2c_path/pwm2 
+
+# Ensure switch is programmed with base MAC addr
+nokia_7215_profile
+
+exit 0
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/service/cpu_wdt.service b/platform/marvell/sonic-platform-nokia/7215-a1/service/cpu_wdt.service
new file mode 100644
index 00000000000..761deec569c
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/service/cpu_wdt.service
@@ -0,0 +1,8 @@
+[Unit]
+Description=CPU WDT
+After=nokia-7215init.service
+[Service]
+ExecStart=/usr/local/bin/cpu_wdt.py
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/service/nokia-7215init.service b/platform/marvell/sonic-platform-nokia/7215-a1/service/nokia-7215init.service
new file mode 100644
index 00000000000..61e0545e73b
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/service/nokia-7215init.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=Nokia-7215 Platform Service
+After=sysinit.target
+Before=pmon.service
+
+[Service]
+ExecStart=/usr/local/bin/nokia-7215-init.sh
+StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/setup.py b/platform/marvell/sonic-platform-nokia/7215-a1/setup.py
new file mode 100755
index 00000000000..67663d3567a
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize Nokia IXS 7215 platforms',
+
+   packages=['sonic_platform','sonic_platform.test'],
+   package_dir={'sonic_platform': 'sonic_platform'},
+)
+
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/__init__.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/__init__.py
new file mode 100644
index 00000000000..4bfefa0fb63
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/chassis.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/chassis.py
new file mode 100644
index 00000000000..19007a3b4de
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/chassis.py
@@ -0,0 +1,440 @@
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    import os
+    import time
+    import sys
+    import glob
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_platform.fan import Fan
+    from .fan_drawer import RealDrawer
+    from sonic_platform.psu import Psu
+    from sonic_platform.thermal import Thermal
+    from sonic_platform.component import Component
+    from sonic_py_common import logger
+    from sonic_py_common.general import getstatusoutput_noshell
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 1
+COPPER_PORT_END = 48
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+PORT_END = 52
+MAX_7215_COMPONENT=2
+
+# Device counts
+MAX_7215_FAN_DRAWERS = 2
+MAX_7215_FANS_PER_DRAWER = 1
+MAX_7215_PSU = 2
+MAX_7215_THERMAL = 5
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class Chassis(ChassisBase):
+    """
+    Nokia platform-specific Chassis class
+        Derived from Dell S6000 platform.
+        customized for the 7215 platform.
+    """
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']
+        # Port numbers for SFP List Initialization
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        # for non-sfp ports create dummy objects for copper / non-sfp ports
+        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
+            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
+            self._sfp_list.append(sfp_node)
+
+        # Verify optoe2 driver SFP eeprom devices were enumerated and exist
+        # then create the sfp nodes
+        eeprom_path = "/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom"
+        mux_dev = sorted(glob.glob("/sys/class/i2c-adapter/i2c-1/i2c-[0-9]"))
+        y = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            mux_dev_num = mux_dev[y]
+            port_i2c_map = mux_dev_num[-1]
+            y = y + 1
+            port_eeprom_path = eeprom_path.format(port_i2c_map)
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info("path %s didnt exist" % port_eeprom_path)
+            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)
+            self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate system eeprom object
+        self._eeprom = Eeprom()
+
+        # Construct lists fans, power supplies, thermals & components
+        drawer_num = MAX_7215_FAN_DRAWERS
+        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER
+        drawer_ctor = RealDrawer
+        fan_index = 0
+        for drawer_index in range(drawer_num):
+            drawer = drawer_ctor(drawer_index)
+            self._fan_drawer_list.append(drawer)
+            for index in range(fan_num_per_drawer):
+                fan = Fan(fan_index, drawer, self.get_model())
+                fan_index += 1
+                drawer._fan_list.append(fan)
+                self._fan_list.append(fan)
+
+        for i in range(MAX_7215_PSU):
+            psu = Psu(i)
+            self._psu_list.append(psu)
+
+        for i in range(MAX_7215_THERMAL):
+            thermal = Thermal(i)
+            self._thermal_list.append(thermal)
+
+        for i in range(MAX_7215_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+  
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _write_sysfs_file(self, sysfs_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if ((self._read_sysfs_file(sysfs_file)) != value ):
+            time.sleep(3)
+            if ((self._read_sysfs_file(sysfs_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+  
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a
+            chassis starting from 1.
+
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_service_tag(self):
+        """
+        Retrieves the Service Tag of the chassis
+        Returns:
+            string: Service Tag of chassis
+        """
+        return self._eeprom.service_tag_str()
+
+    def get_revision(self):
+        """
+        Retrieves the hardware revision of the chassis
+
+        Returns:
+            string: Revision value of chassis
+        """
+        #Revision is always 0 for 7215-IXS-A1
+        return str(0)
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        value = self._read_sysfs_file(CPLD_DIR+"last_reset_cause")
+        thermal = self._read_sysfs_file(CPLD_DIR+"temp_event_status")
+        if (value == 'cold_reset'):
+            reboot_cause=(ChassisBase.REBOOT_CAUSE_POWER_LOSS, "Cold Reset")
+        elif (value == 'warm_reset'):
+            reboot_cause=(ChassisBase.REBOOT_CAUSE_HARDWARE_OTHER, "Warm Reset")
+        elif (value == 'wdog_reset'):
+            reboot_cause=(ChassisBase.REBOOT_CAUSE_WATCHDOG, None)
+        elif (value == 'thermal_reset'):
+            reboot_cause=(ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER, thermal)
+        else:
+            reboot_cause=(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+        #unmask temperature event    
+        self._write_sysfs_file(CPLD_DIR+"temp_event_mask", 0)
+        return reboot_cause
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+
+        Note:
+            We overload this method to ensure that watchdog is only initialized
+            when it is referenced. Currently, only one daemon can open the
+            watchdog. To initialize watchdog in the constructor causes multiple
+            daemon try opening watchdog when loading and constructing a chassis
+            object and fail. By doing so we can eliminate that risk.
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status(port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have timeout
+            # value return true without change after timeout and will
+            # transition to "SYSTEM_READY"
+            status = self.sfp_event.check_sfp_status(port_dict, timeout)
+
+        if status:
+            return True, {'sfp': port_dict}
+        else:
+            return True, {'sfp': {}}
+
+    def get_thermal_manager(self):
+        from .thermal_manager import ThermalManager
+        return ThermalManager
+
+    def initizalize_system_led(self):
+        return True
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the system LED
+
+        Args:
+            color: A string representing the color with which to set the
+                   system LED
+
+        Returns:
+            bool: True if system LED state is set successfully, False if not
+        """
+        if color not in self.system_led_supported_color:
+            return False
+
+        if (color == 'off'):
+            value = 'off'
+        elif (color == 'amber'):
+            value ='amber'
+        elif (color == 'green'):
+            value ='green'
+        elif (color == 'amber_blink'):
+            value = 'blink4-amber'
+        elif (color == 'green_blink'):
+            value = 'blink4-green'
+        else:
+            return False
+        # Write sys led
+        status = self._write_sysfs_file(CPLD_DIR+"system_led", value)
+        
+        if status == "ERR":
+            return False
+
+        return True
+
+    def get_status_led(self):
+        """
+        Gets the state of the system LED
+
+        Returns:
+            A string, one of the valid LED color strings which could be vendor
+            specified.
+        """
+        # Read sys led
+        value = self._read_sysfs_file(CPLD_DIR+"system_led")
+
+        if value == 'off':
+            color = 'off'
+        elif value == 'amber':
+            color = 'amber'
+        elif value == 'green':
+            color = 'green'
+        elif value == 'blink4-amber':
+            color = 'amber_blink'
+        elif value == 'blink4-green':
+            color = 'green_blink'
+        else:
+            return None
+
+        return color
+
+    def get_position_in_parent(self):
+        """
+		Retrieves 1-based relative physical position in parent device. If the agent 
+        cannot determine the parent-relative position
+        for some reason, or if the associated value of entPhysicalContainedIn is '0', 
+        then the value '-1' is returned
+		Returns:
+		    integer: The 1-based relative physical position in parent device or -1 if 
+            cannot determine the position
+		"""
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/component.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/component.py
new file mode 100644
index 00000000000..f4d01291193
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/component.py
@@ -0,0 +1,219 @@
+########################################################################
+# NOKIA IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import os
+    import time
+    import subprocess
+    import ntpath
+    from sonic_platform_base.component_base import ComponentBase
+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+
+class Component(ComponentBase):
+    """Nokia platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["System-CPLD", "Used for managing SFPs, LEDs, PSUs and FANs "],
+        ["U-Boot", "Performs initialization during booting"],
+    ]
+    CPLD_UPDATE_COMMAND = ['./cpldupd_A1', '']
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+    
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _write_sysfs_file(self, sysfs_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if (int(self._read_sysfs_file(sysfs_file)) != value ):
+            time.sleep(3)
+            if (int(self._read_sysfs_file(sysfs_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+
+    def _get_cpld_version(self, cpld_number):
+
+        cpld_version = self._read_sysfs_file(CPLD_DIR+"cpldversion")
+
+        return str(int(cpld_version, 16))
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_model(self):
+        """
+        Retrieves the part number of the component
+        Returns:
+            string: Part number of component
+        """
+        return 'NA'
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the component
+        Returns:
+            string: Serial number of component
+        """
+        return 'NA'
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the component
+        Returns:
+            bool: True if  present, False if not
+        """
+        return True
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the component
+        Returns:
+            bool: True if component is operating properly, False if not
+        """
+        return True
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device.
+        Returns:
+            integer: The 1-based relative physical position in parent
+            device or -1 if cannot determine the position
+        """
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether component is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+        if self.index == 0:
+            return self._get_cpld_version(self.index)
+
+        if self.index == 1:
+            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data ^U-Boot /dev/mtd0ro | cut -d" " -f4')
+            return uboot_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        image_name = ntpath.basename(image_path)
+        print(" ixs-7215-A1 - install cpld {}".format(image_name))
+
+        # check whether the image file exists
+        if not os.path.isfile(image_path):
+            print("ERROR: the cpld image {} doesn't exist ".format(image_path))
+            return False
+
+        # check whether the cpld exe exists
+        if not os.path.isfile('/tmp/cpldupd_A1'):
+            print("ERROR: the cpld exe {} doesn't exist ".format('/tmp/cpldupd_A1'))
+            return False
+
+        self.CPLD_UPDATE_COMMAND[1] = image_name
+
+        success_flag = False
+ 
+        try:   
+            subprocess.check_call(self.CPLD_UPDATE_COMMAND, stderr=subprocess.STDOUT)
+
+            success_flag = True
+        except subprocess.CalledProcessError as e:
+            print("ERROR: Failed to upgrade CPLD: rc={}".format(e.returncode))
+
+        if success_flag:
+            print("INFO: Refresh or power cycle is required to finish CPLD installation")
+
+        return success_flag
+
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/eeprom.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/eeprom.py
new file mode 100644
index 00000000000..b9f770abf90
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/eeprom.py
@@ -0,0 +1,174 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('eeprom')
+
+class Eeprom(TlvInfoDecoder):
+    """Nokia platform-specific EEPROM class"""
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+        
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0053/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.part_number = '1'
+                self.model_str = 'PJT-12V100WBBA'
+                self.serial_number = 'NA'               
+
+            if self.is_fan_eeprom:
+                self.index = fan_index
+                self.part_number = '1'
+                self.model_str = 'FFB0412UHN-BC2EA12'
+                self.serial_number = 'NA'                
+
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            sonic_logger.log_warning("Unable to read system eeprom")
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.service_tag = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                sonic_logger.log_warning("Invalid system eeprom TLV header")
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.service_tag = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.service_tag = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        if self.is_fan_eeprom:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def service_tag_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.service_tag
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan.py
new file mode 100644
index 00000000000..b86370dc0ee
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan.py
@@ -0,0 +1,332 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Fans' information which are available in the platform
+#
+########################################################################
+
+
+try:
+    import os
+    import time
+    from sonic_platform_base.fan_base import FanBase
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_IXS7215_FAN_SPEED = 23000
+WORKING_IXS7215_FAN_SPEED = 2300
+
+
+sonic_logger = logger.Logger('fan')
+
+
+class Fan(FanBase):
+    """Nokia platform-specific Fan class"""
+
+    def __init__(self, fan_index, fan_drawer, chassis_model, psu_fan=False, dependency=None):
+        self.is_psu_fan = psu_fan
+        EMC2302_DIR = " "
+        i2c_path = "/sys/bus/i2c/devices/0-002f/hwmon/"
+        if(os.path.exists(i2c_path)):
+            hwmon_node = os.listdir(i2c_path)[0]
+            EMC2302_DIR = i2c_path + hwmon_node + '/'
+
+        if not self.is_psu_fan:
+            # Fan is 1-based in Nokia platforms
+            self.index = fan_index + 1
+            self.fan_drawer = fan_drawer
+            self.chassis_model = chassis_model
+            self.set_fan_speed_reg = EMC2302_DIR+"pwm{}".format(self.index)
+            self.get_fan_speed_reg = EMC2302_DIR+"fan{}_input".format(self.index)
+            self.max_fan_speed = MAX_IXS7215_FAN_SPEED
+
+            # Fan eeprom
+            self.eeprom = Eeprom(is_fan=True, fan_index=self.index)
+        else:
+            # this is a PSU Fan
+            self.index = fan_index
+            self.dependency = dependency
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _write_sysfs_file(self, sysfs_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if (int(self._read_sysfs_file(sysfs_file)) != value ):
+            time.sleep(3)
+            if (int(self._read_sysfs_file(sysfs_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+
+    def get_name(self):
+        """
+        Retrieves the name of the Fan
+
+        Returns:
+            string: The name of the Fan
+        """
+        if not self.is_psu_fan:
+            return "Fan{}".format(self.index)
+        else:
+            return "PSU{} Fan".format(self.index)
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the Fan Unit
+
+        Returns:
+            bool: True if Fan is present, False if not
+        """
+        #Fixed Fan's on 7215-IXS-A1, Always return True
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number of the Fan
+
+        Returns:
+            string: Model number of Fan. Use part number for this.
+        """
+        return self.eeprom.modelstr()
+    
+    def get_chassis_model(self):
+        """
+        Retrieves the model number of the Fan
+
+        Returns:
+            string: Model number of Fan. Use part number for this.
+        """
+        return self.chassis_model
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Fan
+
+        Returns:
+            string: Serial number of Fan
+        """
+        return self.eeprom.serial_number_str()
+
+    def get_part_number(self):
+        """
+        Retrieves the part number of the Fan
+
+        Returns:
+            string: Part number of Fan
+        """
+        return self.eeprom.part_number_str()
+
+    def get_service_tag(self):
+        """
+        Retrieves the service tag of the Fan
+
+        Returns:
+            string: Service Tag of Fan
+        """
+        return self.eeprom.service_tag_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the Fan
+
+        Returns:
+            bool: True if Fan is operating properly, False if not
+        """
+        status = False
+
+        fan_speed = self._read_sysfs_file(self.get_fan_speed_reg)
+        if (fan_speed != 'ERR'):
+            if (int(fan_speed) > WORKING_IXS7215_FAN_SPEED):
+                status = True
+
+        return status
+
+    def get_direction(self):
+        """
+        Retrieves the fan airflow direction
+        Possible fan directions (relative to port-side of device)
+        Returns:
+            A string, either FAN_DIRECTION_INTAKE or
+            FAN_DIRECTION_EXHAUST depending on fan direction
+        """
+        ch_model=self.get_chassis_model()
+        #compare first 8 characters of chassis molel string
+        if(ch_model[:8]=='3HE18723'):
+            direction = 'intake'
+        else:
+            direction = 'exhaust'
+
+        return direction
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
+
+
+    def get_speed(self):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per
+                 minute defined by 1-based index
+        :param index: An integer, 1-based index of the FAN to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = 0
+
+        fan_speed = self._read_sysfs_file(self.get_fan_speed_reg)
+        if (fan_speed != 'ERR'):
+            speed_in_rpm = int(fan_speed)
+        else:
+            speed_in_rpm = 0
+
+        speed = 100*speed_in_rpm//MAX_IXS7215_FAN_SPEED
+        if speed > 100:
+            speed = 100
+
+        return speed
+
+    def get_speed_tolerance(self):
+        """
+        Retrieves the speed tolerance of the fan
+
+        Returns:
+            An integer, the percentage of variance from target speed
+            which is considered tolerable
+        """
+        if self.get_presence():
+            if self.get_target_speed()<50:
+                tolerance=60
+            else:
+                tolerance = 25
+        else:
+            tolerance = 0
+
+        return tolerance
+
+    def set_speed(self, speed):
+        """
+        Set fan speed to expected value
+        Args:
+            speed: An integer, the percentage of full fan speed to set
+            fan to, in the range 0 (off) to 100 (full speed)
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        if self.is_psu_fan:
+            return False
+
+        if speed in range(0, 6):
+            fandutycycle = 0x00
+        elif speed in range(6, 26):
+            fandutycycle = 64
+        elif speed in range(26, 41):
+            fandutycycle = 102
+        elif speed in range(41, 52):
+            fandutycycle = 128
+        elif speed in range(52, 76):
+            fandutycycle = 192
+        elif speed in range(76, 101):
+            fandutycycle = 255
+        else:
+            return False
+
+        rv = self._write_sysfs_file(self.set_fan_speed_reg, fandutycycle)
+        if (rv != 'ERR'):
+            return True
+        else:
+            return False
+
+    def set_status_led(self, color):
+        """
+        Set led to expected color
+        Args:
+            color: A string representing the color with which to set the
+                   fan module status LED
+        Returns:
+            bool: True if set success, False if fail.
+
+            off , red and green are the only settings 7215 fans
+        """
+        # No Individual Status LED for 7215-IXS-A1
+        return False
+
+    def get_status_led(self):
+        """
+        Gets the state of the fan status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+        if self.get_status():
+            return self.STATUS_LED_COLOR_GREEN
+        else:
+            return self.STATUS_LED_COLOR_OFF
+
+    def get_target_speed(self):
+        """
+        Retrieves the target (expected) speed of the fan
+
+        Returns:
+            An integer, the percentage of full fan speed, in the range 0
+            (off) to 100 (full speed)
+        """
+        speed = 0
+
+        fan_duty = self._read_sysfs_file(self.set_fan_speed_reg)
+        if (fan_duty != 'ERR'):
+            dutyspeed = int(fan_duty)
+            if dutyspeed == 0:
+                speed = 0
+            elif dutyspeed == 64:
+                speed = 25
+            elif dutyspeed == 102:
+                speed = 40
+            elif dutyspeed == 128:
+                speed = 50
+            elif dutyspeed == 192:
+                speed = 75
+            elif dutyspeed == 255:
+                speed = 100
+
+        return speed
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan_drawer.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan_drawer.py
new file mode 100644
index 00000000000..3683b4a22b8
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/fan_drawer.py
@@ -0,0 +1,102 @@
+#############################################################################
+# Nokia
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Fan Drawer status which is available in the platform
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.fan_drawer_base import FanDrawerBase
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('fan_drawer')
+
+class NokiaFanDrawer(FanDrawerBase):
+    def __init__(self, index):
+        super(NokiaFanDrawer, self).__init__()
+        self._index = index + 1
+        self._led = None
+
+    def get_index(self):
+        return self._index
+
+    def get_presence(self):
+        return self._fan_list[0].get_presence()
+
+    def get_model(self):
+        """
+        Retrieves the model number of the Fan Drawer
+        Returns:
+            string: Part number of Fan Drawer
+        """
+        return self._fan_list[0].get_model()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Fan Drawer
+        Returns:
+            string: Serial number of Fan
+        """
+        return self._fan_list[0].get_serial()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the Fan Drawer
+        Returns:
+            bool: True if Fan is operating properly, False if not
+        """
+        return self._fan_list[0].get_status()
+
+    def get_direction(self):
+        return 'intake'
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the fan drawer status LED
+
+        Args:
+            color: A string representing the color with which to set the
+                   fan drawer status LED
+
+        Returns:
+            bool: True if status LED state is set successfully, False if not
+        """
+        return self._fan_list[0].set_status_led(color)
+
+    def get_status_led(self):
+        """
+        Gets the state of the fan drawer LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings
+        """
+        return self._fan_list[0].get_status_led()
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self._index
+
+
+# For Nokia platforms with fan drawer(s)
+class RealDrawer(NokiaFanDrawer):
+    def __init__(self, index):
+        super(RealDrawer, self).__init__(index)
+        self._name = 'drawer{}'.format(self._index)
+
+    def get_name(self):
+        return self._name
\ No newline at end of file
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/platform.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/platform.py
new file mode 100644
index 00000000000..7a3046bc739
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+    """
+    Nokia platform-specific class
+    """
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/psu.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/psu.py
new file mode 100644
index 00000000000..8249954932f
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/psu.py
@@ -0,0 +1,321 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the PSUs' information which are available in the platform
+#
+########################################################################
+
+try:
+    import os
+    import time
+    from sonic_platform_base.psu_base import PsuBase
+    from sonic_py_common import logger
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common.general import getstatusoutput_noshell
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('psu')
+INA230_DIR = "/sys/bus/i2c/devices/0-0040/iio:device0/"
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+PSU_GPIO_DIR = ["/sys/class/gpio/gpio61/value", "/sys/class/gpio/gpio62/value"]
+
+
+class Psu(PsuBase):
+    """Nokia platform-specific PSU class for 7215 """
+
+    def __init__(self, psu_index):
+        PsuBase.__init__(self)
+        # PSU is 1-based in Nokia platforms
+        self.index = psu_index + 1
+        self._fan_list = []
+        
+
+        # PSU eeprom
+        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)
+        self.MAX_VOLTAGE = 14
+        self.MIN_VOLTAGE = 10
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _write_sysfs_file(self, sysfs_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if ((self._read_sysfs_file(sysfs_file)) != value ):
+            time.sleep(3)
+            if ((self._read_sysfs_file(sysfs_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+    
+    def _get_active_psus(self):
+        """
+        Retrieves the operational status of the PSU and
+        calculates number of active PSU's
+
+        Returns:
+            Integer: Number of active PSU's
+        """  
+        active_psus = 0
+        psu1_good = self._read_sysfs_file(PSU_GPIO_DIR[0])
+        psu2_good = self._read_sysfs_file(PSU_GPIO_DIR[1])
+
+        active_psus = int(psu1_good) + int(psu2_good)
+        
+        return active_psus
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return "PSU{}".format(self.index)
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the Power Supply Unit (PSU)
+
+        Returns:
+            bool: True if PSU is present, False if not
+        """
+        #Fixed PSU's on 7215-IXS-A1, Always return True
+
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the part number of the PSU
+
+        Returns:
+            string: Part number of PSU
+        """
+        return self.eeprom.modelstr()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the PSU
+
+        Returns:
+            string: Serial number of PSU
+        """
+        return self.eeprom.serial_number_str()
+
+    def get_revision(self):
+        """
+        Retrieves the HW revision of the PSU
+
+        Returns:
+            string: HW revision of PSU
+        """
+        return self.eeprom.part_number_str()
+
+    def get_part_number(self):
+        """
+        Retrieves the part number of the PSU
+
+        Returns:
+            string: Part number of PSU
+        """
+        return self.eeprom.part_number_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the PSU
+
+        Returns:
+            bool: True if PSU is operating properly, False if not
+        """
+        psu_sysfs_str=PSU_GPIO_DIR[self.index-1]
+        psu_status = self._read_sysfs_file(psu_sysfs_str)
+
+        if psu_status == '1':
+            return True
+
+        return False
+
+    def get_voltage(self):
+        """
+        Retrieves current PSU voltage output
+
+        Returns:
+            A float number, the output voltage in volts,
+            e.g. 12.1
+        """
+        if(self.get_status()):
+            psu_voltage = self._read_sysfs_file(INA230_DIR+"in_voltage1_raw")
+        else:
+            psu_voltage = 0.0
+        
+        psu_voltage = (float(psu_voltage)*1.25)/1000
+
+        return psu_voltage
+    
+    def get_current(self):
+        """
+        Retrieves present electric current supplied by PSU
+
+        Returns:
+            A float number, the electric current in amperes, e.g 15.4
+        """
+        num_psus = self._get_active_psus()
+        if(self.get_status()):
+            psu_current = self._read_sysfs_file(INA230_DIR+"in_current3_raw")
+            psu_current = ((float(psu_current)*0.5)/1000)/num_psus
+        else:
+            psu_current = 0.0
+
+        return psu_current
+    
+    def get_power(self):
+        """
+        Retrieves current energy supplied by PSU
+
+        Returns:
+            A float number, the power in watts, e.g. 302.6
+        """
+        psu_voltage = self.get_voltage()
+        psu_current = self.get_current()
+        psu_power = psu_voltage * psu_current
+
+        return psu_power
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def get_voltage_high_threshold(self):
+        """
+        Retrieves the high threshold PSU voltage output
+
+        Returns:
+            A float number, the high threshold output voltage in volts,
+            e.g. 12.1
+        """
+        return self.MAX_VOLTAGE
+
+    def get_voltage_low_threshold(self):
+        """
+        Retrieves the low threshold PSU voltage output
+
+        Returns:
+            A float number, the low threshold output voltage in volts,
+            e.g. 12.1
+        """
+        return self.MIN_VOLTAGE
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
+
+    def get_powergood_status(self):
+        """
+        Retrieves the powergood status of PSU
+        Returns:
+            A boolean, True if PSU has stablized its output voltages and
+            passed all its internal self-tests, False if not.
+        """
+        psu_sysfs_str=PSU_GPIO_DIR[self.index-1]
+        psu_pg_status = self._read_sysfs_file(psu_sysfs_str)
+
+        if psu_pg_status == '1':
+            return True
+
+        return False
+
+    def get_status_led(self):
+        """
+        Gets the state of the PSU status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+        if self.get_powergood_status():
+            return self.STATUS_LED_COLOR_GREEN
+        else:
+            return self.STATUS_LED_COLOR_OFF
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the PSU status LED
+        Args:
+            color: A string representing the color with which to set the
+                   PSU status LED
+        Returns:
+            bool: True if status LED state is set successfully, False if
+                  not
+        """
+        # No Individual Status LED for 7215-IXS-A1
+        return False
+
+    def get_status_master_led(self):
+        """
+        Gets the state of the front panel PSU status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+        psu_led = self._read_sysfs_file(CPLD_DIR+"psu_led")
+
+        if psu_led == "green":
+            return self.STATUS_LED_COLOR_GREEN
+        elif psu_led == "amber":
+            return self.STATUS_LED_COLOR_AMBER
+        else:
+            return None
+
+    def set_status_master_led(self, color):
+        """
+        Sets the state of the front panel PSU status LED
+
+        Returns:
+            bool: True if status LED state is set successfully, False if
+                  not
+        """
+        if color == self.STATUS_LED_COLOR_GREEN:
+            status = self._write_sysfs_file(CPLD_DIR+"psu_led", "green")
+        elif color == self.STATUS_LED_COLOR_AMBER:
+            status = self._write_sysfs_file(CPLD_DIR+"psu_led", "amber")
+        else:
+            return False
+
+        if status == "ERR":
+            return False
+
+        return True
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp.py
new file mode 100644
index 00000000000..b682080e18d
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp.py
@@ -0,0 +1,214 @@
+# Name: sfp.py, version: 1.0
+#
+# Description: Module contains the definitions of SFP related APIs
+# for Nokia IXS 7215 platform.
+#
+# Copyright (c) 2023, Nokia
+# All rights reserved.
+#
+
+try:
+    import os
+    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase
+    from sonic_py_common.logger import Logger
+    from sonic_py_common import device_info
+    from sonic_py_common.general import getstatusoutput_noshell
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+import subprocess as cmd
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+logger = Logger()
+
+class Sfp(SfpOptoeBase):
+    """
+    Nokia IXS-7215 Platform-specific Sfp refactor class
+    """
+    instances = []
+
+    # Paths
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+
+    PLATFORM = "armhf-nokia_ixs7215_52x-r0"
+    HWSKU = "Nokia-7215"
+
+    port_to_i2c_mapping = 0
+
+    # def __init__(self, index, sfp_type, stub):
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpOptoeBase.__init__(self)
+
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.name = sfp_type + str(index-1)
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+
+        self.port_to_eeprom_mapping[index] = eeprom_path
+
+        self._version_info = device_info.get_sonic_version_info()
+        self.lastPresence = False
+
+        logger.log_debug("Sfp __init__ index {} setting name to {} and eeprom_path to {}".format(index, self.name, self.eeprom_path))
+
+        Sfp.instances.append(self)
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+ 
+    def get_eeprom_path(self):
+        return self.eeprom_path
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        sfpstatus = self._read_sysfs_file(CPLD_DIR+"sfp{}_present".format(self.index))      
+        if sfpstatus == '1':
+            return True
+
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device.
+        Returns:
+            integer: The 1-based relative physical position in parent device or
+                     -1 if cannot determine the position
+        """
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+
+        if self.sfp_type == "SFP":
+            return True
+        else:
+            return False
+
+    def _get_error_code(self):
+        """
+        Get error code of the SFP module
+
+        Returns:
+            The error code
+        """
+        return NotImplementedError
+
+    def get_error_description(self):
+        """
+        Get error description
+
+        Args:
+            error_code: The error code returned by _get_error_code
+
+        Returns:
+            The error description
+        """
+        if not self.get_presence():
+            error_description = self.SFP_STATUS_UNPLUGGED
+        else:
+            error_description = self.SFP_STATUS_OK
+
+        return error_description
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        """
+        reset = self.get_reset_status()
+
+        if reset is True:
+            status = False
+        else:
+            status = True
+
+        return status
+
+    def reset(self):
+        """
+        Reset SFP.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        # RJ45 and SFP ports not resettable
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp_event.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp_event.py
new file mode 100644
index 00000000000..92f759b9789
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/sfp_event.py
@@ -0,0 +1,119 @@
+'''
+listen for the SFP change event and return to chassis.
+'''
+import os
+import time
+from sonic_py_common import logger
+from sonic_py_common.general import getstatusoutput_noshell
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    def __init__(self):
+        self.handle = None
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+    
+    def initialize(self):
+        self.modprs_register = 0
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def _get_transceiver_status(self):
+
+        pos = [1, 2, 4, 8]
+        sfpstatus = 0
+        for port in range (SFP_PORT_START,SFP_PORT_END+1):
+            status = self._read_sysfs_file(CPLD_DIR+"sfp{}_present".format(port))  
+            bit_pos = pos[port-SFP_PORT_START]
+            sfpstatus = sfpstatus + (bit_pos * (int(status)))
+
+        return sfpstatus
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+        check_sfp_status called from get_change_event, this will return correct
+            status of all 4 SFP ports if there is a change in any of them
+        """
+        start_time = time.time()
+        port = SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000)  # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {}  # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
+                    # Mask off the bit corresponding to our port
+                    mask = (1 << port-SFP_PORT_START)
+                    if (changed_ports & mask):
+                        # ModPrsL is active high
+                        if reg_value & mask == 0:
+                            port_change[port] = '0'
+                        else:
+                            port_change[port] = '1'
+                    port += 1
+
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1)  # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
+        return False, {}
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/README b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/README
new file mode 100644
index 00000000000..3efc8fabce0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/README
@@ -0,0 +1 @@
+This directory contains unit tests of the Platform API 2.0
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-chassis.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-chassis.py
new file mode 100755
index 00000000000..93dfcaac3d0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-chassis.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+
+try:
+    import sonic_platform.platform
+    import sonic_platform.chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def main():
+    print("-----------------")
+    print("Chassis Unit Test")
+    print("-----------------")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    print("  Chassis name: {}".format(chassis.get_name()))
+
+    print("  Chassis presence: {}".format(chassis.get_presence()))
+
+    print("  Chassis model: {}".format(chassis.get_model()))
+
+    print("  Chassis serial: {}".format(chassis.get_serial()))
+
+    print("  Chassis revision: {}".format(chassis.get_revision()))
+
+    print("  Chassis status: {}".format(chassis.get_status()))
+
+    print("  Chassis base_mac: {}".format(chassis.get_base_mac()))
+
+    print("  Chassis reboot cause: {}\n".format(chassis.get_reboot_cause()))
+
+    print("  Chassis watchdog: {}".format(chassis.get_watchdog()))
+
+    print("  Chassis num_components: {}".format(chassis.get_num_components()))
+
+    print("  Chassis all_components: {}\n".format(chassis.get_all_components()))
+
+    print("  Chassis num_modules: {}".format(chassis.get_num_modules()))
+
+    print("  Chassis all_modules: {}\n".format(chassis.get_all_modules()))
+
+    print("  Chassis num_fans: {}".format(chassis.get_num_fans()))
+
+    print("  Chassis all_fans: {}\n".format(chassis.get_all_fans()))
+
+    print("  Chassis num_psus: {}".format(chassis.get_num_psus()))
+
+    print("  Chassis all_psus: {}\n".format(chassis.get_all_psus()))
+
+    print("  Chassis num_thermals: {}".format(chassis.get_num_thermals()))
+
+    print("  Chassis all_thermals: {}\n".format(chassis.get_all_thermals()))
+
+    print("  Chassis num_sfps: {}".format(chassis.get_num_sfps()))
+
+    print("  Chassis all_sfps: {}\n".format(chassis.get_all_sfps()))
+
+    print("  Chassis eeprom: {}".format(chassis.get_eeprom()))
+
+    print("  Chassis system_eeprom_info: {}\n".format(chassis.get_system_eeprom_info()))
+
+    print("  Chassis get_status_led start : {}\n".format(chassis.get_status_led()))
+    chassis.set_status_led('amber')
+    print("  Chassis get_status_led amber: {}\n".format(chassis.get_status_led()))
+    chassis.set_status_led('green')
+    print("  Chassis get_status_led green: {}\n".format(chassis.get_status_led()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-component.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-component.py
new file mode 100755
index 00000000000..1116cc7b585
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-component.py
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------------")
+    print("Chassis Component Unit Test")
+    print("---------------------------")
+
+    chassis = Chassis()
+
+    for component in chassis.get_all_components():
+        print("    Name: {}".format(component.get_name()))
+        print("        Description: {}".format(component.get_description()))
+        print("        FW version: {}\n".format(component.get_firmware_version()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-eeprom.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-eeprom.py
new file mode 100755
index 00000000000..bee72e022e8
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-eeprom.py
@@ -0,0 +1,25 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("------------------------")
+    print("Chassis eeprom Unit Test")
+    print("------------------------")
+
+    chassis = Chassis()
+
+    eeprom = chassis.get_eeprom()
+
+    print("    Model: {}, Service Tag: {}".format(eeprom.modelstr(),
+                                             eeprom. service_tag_str()))
+    print("    Part#: {}, Serial#: {}".format(eeprom.part_number_str(),
+                                              eeprom.serial_number_str()))
+    print("    Base MAC: {}".format(eeprom.base_mac_addr()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-fan.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-fan.py
new file mode 100755
index 00000000000..3fbedf1231d
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-fan.py
@@ -0,0 +1,32 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis Fan Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    for fan in chassis.get_all_fans():
+        if not fan.get_presence():
+            print("    Name: {} not present".format(fan.get_name()))
+        else:
+            print("    Name:", fan.get_name())
+            print("        Presence: {}, Status: {}, LED: {}".format(fan.get_presence(),
+                                                                     fan.get_status(),
+                                                                     fan.get_status_led()))
+            print("        Model: {}, Serial#: {}".format(fan.get_model(),
+                                                          fan.get_serial()))
+            print("        Part#: {}, Service Tag: {}".format(fan.get_part_number(),
+                                                              fan.get_service_tag()))
+            print("        Direction: {}, Speed: {}%, Target Speed: {}%\n".format(fan.get_direction(),
+                                                                                    str(fan.get_speed()),
+                                                                                    str(fan.get_target_speed())))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-psu.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-psu.py
new file mode 100755
index 00000000000..e3979b8c417
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-psu.py
@@ -0,0 +1,40 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis PSU Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    for psu in chassis.get_all_psus():
+        if not psu.get_presence():
+            print("    Name: {} not present".format(psu.get_name()))
+        else:
+            print("    Name:", psu.get_name())
+            print("        Presence: {}, Status: {}, LED: {}".format(psu.get_presence(),
+                                                                     psu.get_status(),
+                                                                     psu.get_status_led()))
+            print("        Model: {}, Serial#: {}, Part#: {}".format(psu.get_model(),
+                                                                     psu.get_serial(),
+                                                                     psu.get_part_number()))
+            try:
+                current = psu.get_current()
+            except NotImplementedError:
+                current = "NA"
+            try:
+                power = psu.get_power()
+            except NotImplementedError:
+                power = "NA"
+
+            print("        Voltage: {}, Current: {}, Power: {}\n".format(psu.get_voltage(),
+                                                                         current,
+                                                                         power))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-sfp.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-sfp.py
new file mode 100755
index 00000000000..4d283fa2eb0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-sfp.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python
+
+try:
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def main():
+    print("---------------------")
+    print("Chassis SFP Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    PORT_START = 1
+    PORT_END = 52
+
+    for physical_port in range(PORT_START, PORT_END+1):
+        print(" ")
+        print(" SFP transceiver tests  PORT = ", physical_port)
+        name = chassis.get_sfp(physical_port).get_name()
+        print(" SFP transceiver tests  NAME = ", name)
+
+        presence = chassis.get_sfp(physical_port).get_presence()
+        print("TEST 1 - sfp presence       [ True ] ", physical_port, presence)
+
+        status = chassis.get_sfp(physical_port).get_reset_status()
+        print("TEST 2 - sfp reset status   [ False ] ", physical_port, status)
+
+        txdisable = chassis.get_sfp(physical_port).get_tx_disable()
+        print("TEST 3 - sfp tx_disable     [ False ] ", physical_port, txdisable)
+
+        rxlos = chassis.get_sfp(physical_port).get_rx_los()
+        print("TEST 4 - sfp status rxlos   [ False ] ", physical_port, rxlos)
+
+        txfault = chassis.get_sfp(physical_port).get_tx_fault()
+        print("TEST 5 - sfp status txfault [ False ] ", physical_port, txfault)
+
+        lpmode = chassis.get_sfp(physical_port).get_lpmode()
+        print("TEST 6 - sfp enable lpmode  [ False ] ", physical_port, lpmode)
+
+        trans_info = chassis.get_sfp(physical_port).get_transceiver_info()
+        print("TEST 7 - sfp transceiver info for port:", physical_port, trans_info)
+
+        trans_status = chassis.get_sfp(physical_port).get_transceiver_bulk_status()
+        print("TEST 8 - sfp bulk status for port:", physical_port, trans_status)
+
+        threshold = chassis.get_sfp(physical_port).get_transceiver_threshold_info()
+        print("TEST 9 - sfp bulk status for port:", physical_port, threshold)
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-thermal.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-thermal.py
new file mode 100755
index 00000000000..95cc8e89f0d
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-thermal.py
@@ -0,0 +1,50 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+def main():
+    print("-------------------------")
+    print("Chassis Thermal Unit Test")
+    print("-------------------------")
+
+    chassis = Chassis()
+
+    for thermal in chassis.get_all_thermals():
+        if not thermal.get_presence():
+            print("    Name: {} not present".format(thermal.get_name()))
+        else:
+            print("    Name:", thermal.get_name())
+            print("        Presence: {}, Status: {}".format(thermal.get_presence(),
+                                                            thermal.get_status()))
+            print("        Model: {}, Serial#: {}".format(thermal.get_model(),
+                                                          thermal.get_serial()))
+            print("        Temperature(C): {}".format(thermal.get_temperature()))
+
+            try:
+                low_thresh = thermal.get_low_threshold()
+            except NotImplementedError:
+                low_thresh = "NA"
+            try:
+                high_thresh = thermal.get_high_threshold()
+            except NotImplementedError:
+                high_thresh = "NA"
+
+            print("        Low Threshold(C): {}, High Threshold(C): {}".format(low_thresh,
+                                                                               high_thresh))
+
+            try:
+                crit_low_thresh = thermal.get_low_critical_threshold()
+            except NotImplementedError:
+                crit_low_thresh = "NA"
+            try:
+                crit_high_thresh = thermal.get_high_critical_threshold()
+            except NotImplementedError:
+                crit_high_thresh = "NA"
+
+            print("        Crit Low Threshold(C): {}, Crit High Threshold(C): {}\n".format(crit_low_thresh,
+                                                                                           crit_high_thresh))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-watchdog.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-watchdog.py
new file mode 100755
index 00000000000..20805e04ed2
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/test/test-watchdog.py
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis Watchdog Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    watchdog = chassis.get_watchdog()
+
+    print("    Armed: {}".format(watchdog.is_armed()))
+    print("    Time Left: {}".format(watchdog.get_remaining_time()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal.py
new file mode 100644
index 00000000000..20c15452b68
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal.py
@@ -0,0 +1,265 @@
+########################################################################
+# Nokia IXS7215-A1
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Thermals' information which are available in the platform
+#
+########################################################################
+
+
+try:
+    import os
+    from sonic_platform_base.thermal_base import ThermalBase
+    from swsscommon.swsscommon import SonicV2Connector
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('thermal')
+
+class Thermal(ThermalBase):
+    """Nokia platform-specific Thermal class"""
+
+    I2C_CLASS_DIR = "/sys/class/i2c-adapter/"
+    I2C_DEV_MAPPING = (['i2c-0/0-0048/hwmon/', 1],
+                       ['i2c-0/0-0049/hwmon/', 1],
+                       ['i2c-0/0-004a/hwmon/', 1])
+
+    CN9130_THERMAL_DIR = "/sys/class/hwmon/hwmon1/"
+    ASIC_TEMP_INFO = "ASIC_TEMPERATURE_INFO"
+
+    THERMAL_NAME = ("PCB BACK", "PCB FRONT", "PCB MID", "ASIC", "CPU CORE")
+
+    def __init__(self, thermal_index):
+        ThermalBase.__init__(self)
+        self.index = thermal_index + 1
+        self.is_psu_thermal = False
+        self.dependency = None
+        self._minimum = None
+        self._maximum = None
+        self.thermal_high_threshold_file = None
+        # PCB temperature sensors
+        if self.index < 4:
+            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
+            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
+            sensor_high_suffix = "max"
+            sensor_high_crit_suffix = None
+            hwmon_node = os.listdir(i2c_path)[0]
+            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
+
+        #ASIC temperature sensor
+        elif self.index == 4:
+            sensor_high_suffix = None
+            sensor_high_crit_suffix = None
+            self.sensor_high_threshold = 100.0
+            self.sensor_crit_threshold = 110.0
+            self.SENSOR_DIR = None
+
+        # CPU CN9130 temperature sensor
+        elif self.index == 5:
+            dev_path = self.CN9130_THERMAL_DIR
+            sensor_index = 1
+            sensor_high_suffix = "crit"
+            sensor_high_crit_suffix = "max"
+            self.SENSOR_DIR = dev_path
+
+        # sysfs file for current temperature value
+        if self.SENSOR_DIR:
+            self.thermal_temperature_file = self.SENSOR_DIR \
+                + "temp{}_input".format(sensor_index)
+
+        # sysfs file for high threshold value if supported for this sensor
+        if sensor_high_suffix:
+            self.thermal_high_threshold_file = self.SENSOR_DIR \
+                + "temp{}_{}".format(sensor_index, sensor_high_suffix)
+        else:
+            self.thermal_high_threshold_file = None
+
+        # sysfs file for crit high threshold value if supported for this sensor
+        if sensor_high_crit_suffix:
+            self.thermal_high_crit_threshold_file = self.SENSOR_DIR \
+                + "temp{}_{}".format(sensor_index, sensor_high_crit_suffix)
+        else:
+            self.thermal_high_crit_threshold_file = None
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # sysfs_file and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def get_name(self):
+        """
+        Retrieves the name of the thermal
+
+        Returns:
+            string: The name of the thermal
+        """
+        return self.THERMAL_NAME[self.index - 1]
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the thermal
+
+        Returns:
+            bool: True if thermal is present, False if not
+        """
+        if self.dependency:
+            return self.dependency.get_presence()
+        else:
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the Thermal
+
+        Returns:
+            string: Model/part number of Thermal
+        """
+        return 'NA'
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Thermal
+
+        Returns:
+            string: Serial number of Thermal
+        """
+        return 'NA'
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the thermal
+
+        Returns:
+            A boolean value, True if thermal is operating properly,
+            False if not
+        """
+        if self.dependency:
+            return self.dependency.get_status()
+        else:
+            return True
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to
+            nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        #read from state_db for asic temperature
+        if self.index == 4:
+            db = SonicV2Connector()
+            db.connect(db.STATE_DB)
+            data_dict = db.get_all(db.STATE_DB, self.ASIC_TEMP_INFO)
+            thermal_temperature = float(data_dict['maximum_temperature'])
+        else:
+            thermal_temperature = self._read_sysfs_file(self.thermal_temperature_file)
+            if (thermal_temperature != 'ERR'):
+                thermal_temperature = float(thermal_temperature) / 1000
+            else:
+                thermal_temperature = 0
+
+        if self._minimum is None or self._minimum > thermal_temperature:
+            self._minimum = thermal_temperature
+        if self._maximum is None or self._maximum < thermal_temperature:
+            self._maximum = thermal_temperature
+
+        return float("{:.3f}".format(thermal_temperature))
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in
+            Celsius up to nearest thousandth of one degree Celsius,
+            e.g. 30.125
+        """
+        if self.index == 4:
+            return float("{:.3f}".format(self.sensor_high_threshold))
+        # Not implemented for this sensor
+        if not self.thermal_high_threshold_file:
+            raise  NotImplementedError
+
+        thermal_high_threshold = self._read_sysfs_file(self.thermal_high_threshold_file)
+        if (thermal_high_threshold != 'ERR'):
+            thermal_high_threshold = float(thermal_high_threshold) / 1000
+        else:
+            thermal_high_threshold = 0.0
+
+        return float("{:.3f}".format(thermal_high_threshold))
+
+    def set_high_threshold(self, temperature):
+        """
+        Sets the high threshold temperature of thermal
+
+        Args :
+            temperature: A float number up to nearest thousandth of one
+            degree Celsius, e.g. 30.125
+        Returns:
+            A boolean, True if threshold is set successfully, False if
+            not
+        """
+        # Thermal threshold values are pre-defined based on HW.
+        return False
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        if self.index == 4:
+            return float("{:.3f}".format(self.sensor_crit_threshold))
+        # Not implemented for this sensor
+        if not self.thermal_high_crit_threshold_file:
+            raise  NotImplementedError
+
+        thermal_high_crit_threshold = self._read_sysfs_file(
+            self.thermal_high_crit_threshold_file)
+        if (thermal_high_crit_threshold != 'ERR'):
+            thermal_high_crit_threshold = float(thermal_high_crit_threshold) / 1000
+        else:
+            thermal_high_crit_threshold = 0.0
+
+        return float("{:.3f}".format(thermal_high_crit_threshold))
+
+    def get_minimum_recorded(self):
+        self.get_temperature()
+        return self._minimum
+
+    def get_maximum_recorded(self):
+        self.get_temperature()
+        return self._maximum
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_actions.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_actions.py
new file mode 100644
index 00000000000..4dc9b6ab5b4
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_actions.py
@@ -0,0 +1,222 @@
+from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+
+from sonic_py_common import logger
+
+sonic_logger = logger.Logger('thermal_actions')
+
+
+class SetFanSpeedAction(ThermalPolicyActionBase):
+    """
+    Base thermal action class to set speed for fans
+    """
+    # JSON field definition
+    JSON_FIELD_SPEED = 'speed'
+    JSON_FIELD_DEFAULT_SPEED = 'default_speed'
+    JSON_FIELD_THRESHOLD1_SPEED = 'threshold1_speed'
+    JSON_FIELD_THRESHOLD2_SPEED = 'threshold2_speed'
+    JSON_FIELD_HIGHTEMP_SPEED = 'hightemp_speed'
+
+    def __init__(self):
+        """
+        Constructor of SetFanSpeedAction
+        """
+        self.default_speed = 25
+        self.threshold1_speed=40
+        self.threshold2_speed=75
+        self.hightemp_speed = 100
+        self.speed = self.default_speed
+
+    def load_from_json(self, json_obj):
+        """
+        Construct SetFanSpeedAction via JSON. JSON example:
+            {
+                "type": "fan.all.set_speed"
+                "speed": "100"
+            }
+        :param json_obj: A JSON object representing a SetFanSpeedAction action.
+        :return:
+        """
+        if SetFanSpeedAction.JSON_FIELD_SPEED in json_obj:
+            speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
+            if speed < 0 or speed > 100:
+                raise ValueError('SetFanSpeedAction invalid speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(speed))
+            self.speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_SPEED))
+
+    @classmethod
+    def set_all_fan_speed(cls, thermal_info_dict, speed):
+        from .thermal_infos import FanInfo
+        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
+            fan_info_obj = thermal_info_dict[FanInfo.INFO_NAME]
+            for fan in fan_info_obj.get_presence_fans():
+                fan.set_speed(int(speed))
+
+
+@thermal_json_object('fan.all.set_speed')
+class SetAllFanSpeedAction(SetFanSpeedAction):
+    """
+    Action to set speed for all fans
+    """
+    def execute(self, thermal_info_dict):
+        """
+        Set speed for all fans
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        SetAllFanSpeedAction.set_all_fan_speed(thermal_info_dict, self.speed)
+
+
+@thermal_json_object('thermal.temp_check_and_set_all_fan_speed')
+class ThermalRecoverAction(SetFanSpeedAction):
+    """
+    Action to check thermal sensor temperature change status and set speed for all fans
+    """
+
+    def load_from_json(self, json_obj):
+        """
+        Construct ThermalRecoverAction via JSON. JSON example:
+            {
+                "type": "thermal.temp_check_and_set_all_fan_speed"
+                "default_speed": "25",
+                "threshold1_speed": "40",
+                "threshold2_speed": "75",
+                "hightemp_speed": "100"
+            }
+        :param json_obj: A JSON object representing a ThermalRecoverAction action.
+        :return:
+        """
+        if SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED in json_obj:
+            default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
+            if default_speed < 0 or default_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(default_speed))
+            self.default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED))
+
+        if SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED in json_obj:
+            threshold1_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED])
+            if threshold1_speed < 0 or threshold1_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(threshold1_speed))
+            self.threshold1_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED))
+        
+        if SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED in json_obj:
+            threshold2_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED])
+            if threshold2_speed < 0 or threshold2_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(threshold2_speed))
+            self.threshold2_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED))
+        
+        if SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED in json_obj:
+            hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
+            if hightemp_speed < 0 or hightemp_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid hightemp speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(hightemp_speed))
+            self.hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED))
+
+        sonic_logger.log_warning("ThermalRecoverAction: default: {}, threshold1: {}, threshold2: {}, hightemp: {}".format(self.default_speed, self.threshold1_speed, self.threshold2_speed, self.hightemp_speed))
+
+    def execute(self, thermal_info_dict):
+        """
+        Check check thermal sensor temperature change status and set speed for all fans
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        from .thermal_infos import ThermalInfo
+        if ThermalInfo.INFO_NAME in thermal_info_dict and \
+           isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
+
+            thermal_info_obj = thermal_info_dict[ThermalInfo.INFO_NAME]
+            if thermal_info_obj.is_set_fan_high_temp_speed():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.hightemp_speed) 
+            elif thermal_info_obj.is_set_fan_threshold_two_speed():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.threshold2_speed)
+            elif thermal_info_obj.is_set_fan_threshold_one_speed():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.threshold1_speed)
+            elif thermal_info_obj.is_set_fan_default_speed():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.default_speed)
+
+
+@thermal_json_object('switch.shutdown')
+class SwitchPolicyAction(ThermalPolicyActionBase):
+    """
+    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,
+    all predefined thermal action will be executed.
+    """
+    def execute(self, thermal_info_dict):
+        """
+        Take action when thermal condition matches. For example, adjust speed of fan or shut
+        down the switch.
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        sonic_logger.log_warning("Alarm for temperature critical is detected, reboot Device")
+        # import os
+        # os.system('reboot')
+
+
+@thermal_json_object('thermal_control.control')
+class ControlThermalAlgoAction(ThermalPolicyActionBase):
+    """
+    Action to control the thermal control algorithm
+    """
+    # JSON field definition
+    JSON_FIELD_STATUS = 'status'
+
+    def __init__(self):
+        self.status = True
+
+    def load_from_json(self, json_obj):
+        """
+        Construct ControlThermalAlgoAction via JSON. JSON example:
+            {
+                "type": "thermal_control.control"
+                "status": "true"
+            }
+        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.
+        :return:
+        """
+        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:
+            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()
+            if status_str == 'true':
+                self.status = True
+            elif status_str == 'false':
+                self.status = False
+            else:
+                raise ValueError('Invalid {} field value, please specify true of false'.
+                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
+        else:
+            raise ValueError('ControlThermalAlgoAction '
+                             'missing mandatory field {} in JSON policy file'.
+                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
+
+    def execute(self, thermal_info_dict):
+        """
+        Disable thermal control algorithm
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        from .thermal_infos import ChassisInfo
+        if ChassisInfo.INFO_NAME in thermal_info_dict:
+            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]
+            chassis = chassis_info_obj.get_chassis()
+            thermal_manager = chassis.get_thermal_manager()
+            if self.status:
+                thermal_manager.start_thermal_control_algorithm()
+            else:
+                thermal_manager.stop_thermal_control_algorithm()
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_conditions.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_conditions.py
new file mode 100644
index 00000000000..4923d63d746
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_conditions.py
@@ -0,0 +1,81 @@
+from sonic_platform_base.sonic_thermal_control.thermal_condition_base import ThermalPolicyConditionBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+
+
+class FanCondition(ThermalPolicyConditionBase):
+    def get_fan_info(self, thermal_info_dict):
+        from .thermal_infos import FanInfo
+        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
+            return thermal_info_dict[FanInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('fan.any.absence')
+class AnyFanAbsenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_absence_fans()) > 0 if fan_info_obj else False
+
+
+@thermal_json_object('fan.all.absence')
+class AllFanAbsenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_presence_fans()) == 0 if fan_info_obj else False
+
+
+@thermal_json_object('fan.all.presence')
+class AllFanPresenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_absence_fans()) == 0 if fan_info_obj else False
+
+
+class ThermalCondition(ThermalPolicyConditionBase):
+    def get_thermal_info(self, thermal_info_dict):
+        from .thermal_infos import ThermalInfo
+        if ThermalInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
+            return thermal_info_dict[ThermalInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('thermal.over.high_critical_threshold')
+class ThermalOverHighCriticalCondition(ThermalCondition):
+    def is_match(self, thermal_info_dict):
+        thermal_info_obj = self.get_thermal_info(thermal_info_dict)
+        if thermal_info_obj:
+            return thermal_info_obj.is_over_high_critical_threshold()
+        else:
+            return False
+
+
+class PsuCondition(ThermalPolicyConditionBase):
+    def get_psu_info(self, thermal_info_dict):
+        from .thermal_infos import PsuInfo
+        if PsuInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[PsuInfo.INFO_NAME], PsuInfo):
+            return thermal_info_dict[PsuInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('psu.any.absence')
+class AnyPsuAbsenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_absence_psus()) > 0 if psu_info_obj else False
+
+
+@thermal_json_object('psu.all.absence')
+class AllPsuAbsenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_presence_psus()) == 0 if psu_info_obj else False
+
+
+@thermal_json_object('psu.all.presence')
+class AllPsuPresenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_absence_psus()) == 0 if psu_info_obj else False
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_infos.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_infos.py
new file mode 100644
index 00000000000..0f03ee7a4fd
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_infos.py
@@ -0,0 +1,270 @@
+from sonic_platform_base.sonic_thermal_control.thermal_info_base import ThermalPolicyInfoBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+from sonic_py_common.logger import Logger
+
+logger = Logger()
+
+@thermal_json_object('fan_info')
+class FanInfo(ThermalPolicyInfoBase):
+    """
+    Fan information needed by thermal policy
+    """
+
+    # Fan information name
+    INFO_NAME = 'fan_info'
+
+    def __init__(self):
+        self._absence_fans = set()
+        self._presence_fans = set()
+        self._status_changed = False
+
+    def collect(self, chassis):
+        """
+        Collect absence and presence fans.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._status_changed = False
+        for fan in chassis.get_all_fans():
+            if fan.get_presence() and fan not in self._presence_fans:
+                self._presence_fans.add(fan)
+                self._status_changed = True
+                if fan in self._absence_fans:
+                    self._absence_fans.remove(fan)
+            elif not fan.get_presence() and fan not in self._absence_fans:
+                self._absence_fans.add(fan)
+                self._status_changed = True
+                if fan in self._presence_fans:
+                    self._presence_fans.remove(fan)
+
+    def get_absence_fans(self):
+        """
+        Retrieves absence fans
+        :return: A set of absence fans
+        """
+        return self._absence_fans
+
+    def get_presence_fans(self):
+        """
+        Retrieves presence fans
+        :return: A set of presence fans
+        """
+        return self._presence_fans
+
+    def is_status_changed(self):
+        """
+        Retrieves if the status of fan information changed
+        :return: True if status changed else False
+        """
+        return self._status_changed
+
+
+@thermal_json_object('thermal_info')
+class ThermalInfo(ThermalPolicyInfoBase):
+    """
+    Thermal information needed by thermal policy
+    """
+
+    # Fan information name
+    INFO_NAME = 'thermal_info'
+
+    def __init__(self):
+        self._old_threshold_level = -1
+        self._current_threshold_level = 0
+        self._num_fan_levels = 3
+        self._high_crital_threshold = 75
+        #THERMAL_NAME ("PCB BACK", "PCB FRONT", "PCB MID", "ASIC", "CPU CORE")
+        self._f2b_level_up_threshold = [[38,30,37,60,77],
+                                        [51,44,50,72,90],
+                                        [61,57,61,77,94]]
+        
+        self._f2b_level_down_threshold = [[29,24,29,50,64],
+                                          [40,37,40,59,75],
+                                          [58,54,58,72,90]]
+        
+        self._b2f_level_up_threshold = [[30,38,41,65,71],
+                                        [43,50,54,76,86],
+                                        [53,59,61,79,92]]
+        
+        self._b2f_level_down_threshold = [[22,30,33,54,60],
+                                          [37,44,46,62,73],
+                                          [51,57,58,75,90]]
+    def collect(self, chassis):
+        """
+        Collect thermal sensor temperature change status
+        :param chassis: The chassis object
+        :return:
+        """
+        self._temps = []
+        self._over_high_critical_threshold = False
+        self._set_fan_default_speed = False
+        self._set_fan_threshold_one_speed = False
+        self._set_fan_threshold_two_speed = False
+        self._set_fan_high_temp_speed = False
+
+        # Calculate average temp within the device
+        num_of_thermals = chassis.get_num_thermals()
+        for index in range(num_of_thermals):
+            self._temps.insert(index, chassis.get_thermal(index).get_temperature())
+        
+        fan_direction=chassis.get_fan(1).get_direction()
+        if(fan_direction == "intake"):
+            level_up_threshold=self._f2b_level_up_threshold
+            level_down_threshold=self._f2b_level_down_threshold
+        else:
+            level_up_threshold=self._b2f_level_up_threshold
+            level_down_threshold=self._b2f_level_down_threshold
+
+       # Find current required threshold level
+        max_level =0
+        min_level = [self._num_fan_levels for i in range(num_of_thermals)]  
+        for index in range(num_of_thermals):
+            for level in range(self._num_fan_levels):
+
+                if self._temps[index]>level_up_threshold[level][index]:
+                    if max_level<level+1:
+                        max_level=level+1
+                if self._temps[index]<level_down_threshold[level][index]:
+                    if min_level[index]>level:
+                        min_level[index]=level
+
+        max_of_min_level=max(min_level)
+
+        #compare with running threshold level 
+        if max_of_min_level > self._old_threshold_level:
+            max_of_min_level=self._old_threshold_level
+          
+        self._current_threshold_level = max(max_of_min_level,max_level)
+       
+        #set fan to max speed if one fan is down
+        for fan in chassis.get_all_fans():
+            if not fan.get_status() :
+                self._current_threshold_level = 3
+          
+       # Decide fan speed based on threshold level
+
+        if self._current_threshold_level != self._old_threshold_level:
+            if self._current_threshold_level == 0:
+                self._set_fan_default_speed = True
+            elif self._current_threshold_level == 1:
+                self._set_fan_threshold_one_speed = True
+            elif self._current_threshold_level == 2:
+                self._set_fan_threshold_two_speed = True
+            elif self._current_threshold_level == 3:
+                self._set_fan_high_temp_speed = True
+
+        self._old_threshold_level=self._current_threshold_level
+
+    def is_set_fan_default_speed(self):
+        """
+        Retrieves if the temperature is warm up and over high threshold
+        :return: True if the temperature is warm up and over high threshold else False
+        """
+        return self._set_fan_default_speed
+
+    def is_set_fan_threshold_one_speed(self):
+        """
+        Retrieves if the temperature is warm up and over high threshold
+        :return: True if the temperature is warm up and over high threshold else False
+        """
+        return self._set_fan_threshold_one_speed
+    
+    def is_set_fan_threshold_two_speed(self):
+        """
+        Retrieves if the temperature is warm up and over high threshold
+        :return: True if the temperature is warm up and over high threshold else False
+        """
+        return self._set_fan_threshold_two_speed
+
+    def is_set_fan_high_temp_speed(self):
+        """
+        Retrieves if the temperature is warm up and over high threshold
+        :return: True if the temperature is warm up and over high threshold else False
+        """
+        return self._set_fan_high_temp_speed
+
+    def is_over_high_critical_threshold(self):
+        """
+        Retrieves if the temperature is over high critical threshold
+        :return: True if the temperature is over high critical threshold else False
+        """
+        return self._over_high_critical_threshold
+
+
+@thermal_json_object('psu_info')
+class PsuInfo(ThermalPolicyInfoBase):
+    """
+    PSU information needed by thermal policy
+    """
+    INFO_NAME = 'psu_info'
+
+    def __init__(self):
+        self._absence_psus = set()
+        self._presence_psus = set()
+        self._status_changed = False
+
+    def collect(self, chassis):
+        """
+        Collect absence and presence PSUs.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._status_changed = False
+        for psu in chassis.get_all_psus():
+            if psu.get_presence() and psu.get_powergood_status() and psu not in self._presence_psus:
+                self._presence_psus.add(psu)
+                self._status_changed = True
+                if psu in self._absence_psus:
+                    self._absence_psus.remove(psu)
+            elif (not psu.get_presence() or not psu.get_powergood_status()) and psu not in self._absence_psus:
+                self._absence_psus.add(psu)
+                self._status_changed = True
+                if psu in self._presence_psus:
+                    self._presence_psus.remove(psu)
+
+    def get_absence_psus(self):
+        """
+        Retrieves presence PSUs
+        :return: A set of absence PSUs
+        """
+        return self._absence_psus
+
+    def get_presence_psus(self):
+        """
+        Retrieves presence PSUs
+        :return: A set of presence fans
+        """
+        return self._presence_psus
+
+    def is_status_changed(self):
+        """
+        Retrieves if the status of PSU information changed
+        :return: True if status changed else False
+        """
+        return self._status_changed
+
+
+@thermal_json_object('chassis_info')
+class ChassisInfo(ThermalPolicyInfoBase):
+    """
+    Chassis information needed by thermal policy
+    """
+    INFO_NAME = 'chassis_info'
+
+    def __init__(self):
+        self._chassis = None
+
+    def collect(self, chassis):
+        """
+        Collect platform chassis.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._chassis = chassis
+
+    def get_chassis(self):
+        """
+        Retrieves platform chassis object
+        :return: A platform chassis object.
+        """
+        return self._chassis
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_manager.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_manager.py
new file mode 100644
index 00000000000..967cf175934
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/thermal_manager.py
@@ -0,0 +1,49 @@
+from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase
+from .thermal_actions import *
+from .thermal_conditions import *
+from .thermal_infos import *
+
+
+class ThermalManager(ThermalManagerBase):
+    THERMAL_ALGORITHM_CONTROL_PATH = '/var/run/hw-management/config/suspend'
+
+    @classmethod
+    def start_thermal_control_algorithm(cls):
+        """
+        Start thermal control algorithm
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        cls._control_thermal_control_algorithm(False)
+
+    @classmethod
+    def stop_thermal_control_algorithm(cls):
+        """
+        Stop thermal control algorithm
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        cls._control_thermal_control_algorithm(True)
+
+    @classmethod
+    def _control_thermal_control_algorithm(cls, suspend):
+        """
+        Control thermal control algorithm
+
+        Args:
+            suspend: Bool, indicate suspend the algorithm or not
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        status = True
+        write_value = 1 if suspend else 0
+        try:
+            with open(cls.THERMAL_ALGORITHM_CONTROL_PATH, 'w') as control_file:
+                control_file.write(str(write_value))
+        except (ValueError, IOError):
+            status = False
+
+        return status
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/watchdog.py b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/watchdog.py
new file mode 100644
index 00000000000..052a276af42
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/sonic_platform/watchdog.py
@@ -0,0 +1,231 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+import time
+from sonic_platform_base.watchdog_base import WatchdogBase
+
+""" ioctl constants """
+IO_WRITE = 0x40000000
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_READ_WRITE = 0xC0000000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_SETTIMEOUT = 6 | WDWR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+WDIOC_SETPRETIMEOUT = 8 | WDWR_INT
+WDIOC_GETPRETIMEOUT = 9 | WDR_INT
+WDIOC_GETTIMELEFT = 10 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/watchdog0/"
+WD_GPIO_PATH = "/sys/class/gpio/gpio41/value"
+CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
+
+WD_COMMON_ERROR = -1
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+        super(WatchdogImplBase, self).__init__()
+        
+        self.watchdog=""
+        self.watchdog_path = wd_device_path
+        self.watchdog_gpio_reg = WD_GPIO_PATH
+        self.wd_state_reg = WD_SYSFS_PATH+"state"
+        self.wd_timeout_reg = WD_SYSFS_PATH+"timeout"
+        self.wd_timeleft_reg = WD_SYSFS_PATH+"timeleft"
+    
+        self.timeout = self._gettimeout()
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+    
+    def _write_sysfs_file(self, sysfs_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if (int(self._read_sysfs_file(sysfs_file)) != value ):
+            time.sleep(3)
+            if (int(self._read_sysfs_file(sysfs_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+        self._write_sysfs_file(self.watchdog_gpio_reg, 1)
+        self._read_sysfs_file(CPLD_DIR+"last_reset_cause")
+        
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
+
+    def _settimeout(self, seconds):
+        """
+        Set watchdog timer timeout
+        @param seconds - timeout in seconds
+        @return is the actual set timeout
+        """
+
+        req = array.array('I', [seconds])
+        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+        timeout=0
+        timeout=self._read_sysfs_file(self.wd_timeout_reg)
+
+        return timeout
+
+    def _gettimeleft(self):
+        """
+        Get time left before watchdog timer expires
+        @return time left in seconds
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+
+        ret = WD_COMMON_ERROR
+        if (seconds < 0 or seconds > 340 ):
+            return ret
+        # Stop the watchdog service to gain access of watchdog file pointer
+        if self.is_armed():
+            os.popen("systemctl stop cpu_wdt.service")
+            time.sleep(2)
+        if not self.watchdog:
+            self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.is_armed():
+                self._keepalive()
+            else:
+                self._enablewatchdog()
+            ret = self.timeout
+        except IOError:
+            pass
+        if(ret == seconds):
+            self._write_sysfs_file(self.watchdog_gpio_reg, 0)
+        return ret
+
+    def disarm(self):
+        """
+        Implements disarm WatchdogBase API
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        
+        if self.is_armed():
+            os.popen("systemctl stop cpu_wdt.service")
+            time.sleep(2)
+            if not self.watchdog:
+                self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+            try:
+                self._disablewatchdog()
+                self.timeout = 0
+            except IOError:
+                return False    
+        return True
+
+    def is_armed(self):
+        """
+        Implements is_armed WatchdogBase API
+        """
+        status = False
+
+        state = self._read_sysfs_file(self.wd_state_reg)
+        if (state != 'inactive'):
+            status = True
+
+        return status
+
+    def get_remaining_time(self):
+        """
+        Implements get_remaining_time WatchdogBase API
+        """
+
+        timeleft = WD_COMMON_ERROR
+
+        if self.is_armed():
+            timeleft=self._read_sysfs_file(self.wd_timeleft_reg)
+
+        return int(timeleft)
diff --git a/platform/marvell/sonic-platform-nokia/7215-a1/utils/sonic_ssd.py b/platform/marvell/sonic-platform-nokia/7215-a1/utils/sonic_ssd.py
new file mode 100644
index 00000000000..563a0b22ce2
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215-a1/utils/sonic_ssd.py
@@ -0,0 +1,47 @@
+
+import os
+
+# pylint: disable=import-error
+from sonic_platform_base.sonic_ssd.ssd_base import SsdBase
+from sonic_platform_base.sonic_ssd.ssd_generic import SsdUtil as SsdUtilDefault
+
+class EmmcUtil(SsdBase):
+   def __init__(self, diskdev):
+      self.diskdev = diskdev
+      self.path = os.path.join('/sys/block', os.path.basename(diskdev))
+
+   def _readDeviceEntry(self, entry, default=None):
+      path = os.path.join(self.path, 'device', entry)
+      try:
+         with open(path, encoding='utf8') as f:
+            return f.read().rstrip()
+      except OSError:
+         return default
+
+   def _isSlc(self):
+      return bool(self._readDeviceEntry('enhanced_area_offset'))
+
+   def get_health(self):
+      data = self._readDeviceEntry('life_time')
+      if data is None:
+         raise NotImplementedError
+      value = int(data.split()[0 if self._isSlc() else 1], 0)
+      return float(100 - (10 * (value - 1)))
+
+   def get_temperature(self):
+      return 'N/A'
+
+   def get_model(self):
+      return self._readDeviceEntry('name')
+
+   def get_firmware(self):
+      return self._readDeviceEntry('fwrev')
+
+   def get_serial(self):
+      return self._readDeviceEntry('serial')
+
+   def get_vendor_output(self):
+      return ''
+
+def SsdUtil(diskdev):
+   return EmmcUtil('/dev/mmcblk0')
diff --git a/platform/marvell/sonic-platform-nokia/7215/scripts/cpu_wdt.py b/platform/marvell/sonic-platform-nokia/7215/scripts/cpu_wdt.py
new file mode 100755
index 00000000000..60f75b4f2e5
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/scripts/cpu_wdt.py
@@ -0,0 +1,46 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+from sonic_py_common import logger
+import time
+import os
+import signal
+import sys
+
+
+TIMEOUT=170
+KEEPALIVE=55
+sonic_logger = logger.Logger('Watchdog')
+sonic_logger.set_min_log_priority_info()
+time.sleep(60)
+chassis = Chassis()
+watchdog = chassis.get_watchdog()
+
+def stopWdtService(signal, frame):
+    watchdog._disablewatchdog()
+    sonic_logger.log_notice("CPUWDT Disabled: watchdog armed=%s" % watchdog.is_armed() )
+    sys.exit()
+
+def main():
+
+    signal.signal(signal.SIGHUP, signal.SIG_IGN)
+    signal.signal(signal.SIGINT, stopWdtService)
+    signal.signal(signal.SIGTERM, stopWdtService)
+    
+    watchdog.arm(TIMEOUT)
+    sonic_logger.log_notice("CPUWDT Enabled: watchdog armed=%s" % watchdog.is_armed() )
+
+
+    while True:
+        time.sleep(KEEPALIVE)
+        watchdog._keepalive()
+        sonic_logger.log_info("CPUWDT keepalive")
+    done
+
+    stopWdtService
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/scripts/inband_mgmt.sh b/platform/marvell/sonic-platform-nokia/7215/scripts/inband_mgmt.sh
new file mode 100644
index 00000000000..25455d16ecb
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/scripts/inband_mgmt.sh
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+#inband_mgmt
+
+inband_mgmt(){
+ # In this platform, one of the network ports is used as mgmt interface.
+ # This script periodically monitors inband management port eth0 and
+ # assigns IP address to eth0 if needed.
+ if [ ! -f /host/machine.conf ]; then
+     exit 0
+ fi
+ #wait for n/w port init to complete
+ sleep 60
+ while :; do
+   ip -br link show eth0 2> /dev/null
+   if [ $? -eq 0 ]; then
+       ip address show eth0 | grep -qw "inet" 2>/dev/null
+       if [ $? -ne 0 ]; then
+           ifconfig eth0 down
+           systemctl restart networking
+       fi
+       sleep 120
+   else
+     sleep 3
+   fi
+ done
+}
+(inband_mgmt > /dev/null)&
diff --git a/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215_plt_setup.sh b/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215_plt_setup.sh
new file mode 100755
index 00000000000..017c7e5153a
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215_plt_setup.sh
@@ -0,0 +1,31 @@
+#!/bin/bash
+
+fw_uboot_env_cfg()
+{
+    echo "Setting up U-Boot environment..."
+
+    MACH_FILE="/host/machine.conf"
+    PLATFORM=`sed -n 's/onie_platform=\(.*\)/\1/p' $MACH_FILE`
+
+    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
+	# Ixs7215 / IPD6448M board Uboot ENV offset
+        FW_ENV_DEFAULT='/dev/mtd0 0x00100000 0x10000 0x10000'
+    else
+        FW_ENV_DEFAULT='/dev/mtd0 0x00500000 0x80000 0x100000 8'
+    fi
+
+    echo "Using pre-configured uboot env"
+    echo $FW_ENV_DEFAULT > /etc/fw_env.config
+
+}
+
+
+main()
+{
+    fw_uboot_env_cfg
+    echo "Nokia-IXS7215: /dev/mtd0 FW_ENV_DEFAULT"
+
+    /bin/sh /etc/inband_mgmt.sh
+}
+
+main $@
diff --git a/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215init.sh b/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
new file mode 100755
index 00000000000..5ec108d1cfc
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
@@ -0,0 +1,68 @@
+#!/bin/bash
+
+# Platform init script for Nokia IXS 7215
+
+# Load required kernel-mode drivers
+load_kernel_drivers() {
+    # Remove modules loaded during Linux init
+    # FIX-ME: This will be removed in the future when Linux init no longer loads these
+    rmmod i2c_mux_gpio
+    rmmod i2c_dev
+    rmmod i2c_mv64xxx
+
+    # Carefully control the load order here to ensure consistent i2c bus numbering
+    modprobe i2c_mv64xxx
+    modprobe i2c_dev
+    modprobe i2c_mux_gpio
+    modprobe eeprom
+}
+
+
+nokia_7215_profile()
+{
+    MAC_ADDR=$(sudo decode-syseeprom -m)
+    sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g" /usr/share/sonic/device/armhf-nokia_ixs7215_52x-r0/Nokia-7215/profile.ini
+    echo "Nokia-7215: Updating switch mac address ${MAC_ADDR}"
+}
+
+# - Main entry
+
+# Install kernel drivers required for i2c bus access
+load_kernel_drivers
+
+# Disable sysrq-trigger
+echo 0 > /proc/sys/kernel/sysrq
+
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+# the mux may be enumerated at number 4 or 5 so we check for the mux and skip if needed
+
+# Get list of the mux channels
+ismux_bus=$(i2cdetect -l|grep mux|cut -f1)
+
+# Enumerate the SFP eeprom device on each mux channel
+for mux in ${ismux_bus}
+do
+    echo optoe2 0x50 > /sys/class/i2c-adapter/${mux}/new_device
+done
+
+# Enumerate system eeprom
+echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device
+sleep 2
+chmod 644 /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
+
+# Enumerate fan eeprom devices
+echo eeprom 0x55 > /sys/class/i2c-adapter/i2c-0/new_device
+echo eeprom 0x56 > /sys/class/i2c-adapter/i2c-0/new_device
+
+# Enumerate PSU eeprom devices
+echo eeprom 0x50 > /sys/class/i2c-adapter/i2c-1/new_device
+echo eeprom 0x51 > /sys/class/i2c-adapter/i2c-1/new_device
+
+# Enable optical SFP Tx
+i2cset -y -m 0x0f 0 0x41 0x5 0x00
+
+# Ensure switch is programmed with chassis base MAC addr
+nokia_7215_profile
+
+echo "Nokia-7215 - completed platform init script"
+exit 0
diff --git a/platform/marvell/sonic-platform-nokia/7215/service/cpu_wdt.service b/platform/marvell/sonic-platform-nokia/7215/service/cpu_wdt.service
new file mode 100644
index 00000000000..761deec569c
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/service/cpu_wdt.service
@@ -0,0 +1,8 @@
+[Unit]
+Description=CPU WDT
+After=nokia-7215init.service
+[Service]
+ExecStart=/usr/local/bin/cpu_wdt.py
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf b/platform/marvell/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
new file mode 100644
index 00000000000..0456c60d42b
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
@@ -0,0 +1,5 @@
+[Unit]
+Description=Discard unused blocks daily
+
+[Timer]
+OnCalendar=daily
diff --git a/platform/marvell/sonic-platform-nokia/7215/service/nokia-7215init.service b/platform/marvell/sonic-platform-nokia/7215/service/nokia-7215init.service
new file mode 100644
index 00000000000..8b17dbc8edc
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/service/nokia-7215init.service
@@ -0,0 +1,14 @@
+[Unit]
+Description=Nokia-7215 Platform Service
+Before=pmon.service
+After=sysinit.target
+DefaultDependencies=no
+
+[Service]
+ExecStart=/usr/local/bin/nokia-7215init.sh
+KillSignal=SIGKILL
+SuccessExitStatus=SIGKILL
+#StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell/sonic-platform-nokia/7215/setup.py b/platform/marvell/sonic-platform-nokia/7215/setup.py
new file mode 100755
index 00000000000..67663d3567a
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize Nokia IXS 7215 platforms',
+
+   packages=['sonic_platform','sonic_platform.test'],
+   package_dir={'sonic_platform': 'sonic_platform'},
+)
+
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/__init__.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/__init__.py
new file mode 100755
index 00000000000..39c712316dc
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/__init__.py
@@ -0,0 +1,4 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
+
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/chassis.py
new file mode 100755
index 00000000000..008d5ba08b7
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/chassis.py
@@ -0,0 +1,415 @@
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    import os
+    import sys
+    import glob
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_platform.fan import Fan
+    from .fan_drawer import RealDrawer
+    from sonic_platform.psu import Psu
+    from sonic_platform.thermal import Thermal
+    from sonic_platform.component import Component
+    from sonic_py_common import logger
+    from sonic_py_common.general import getstatusoutput_noshell
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 1
+COPPER_PORT_END = 48
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+PORT_END = 52
+
+# Device counts
+MAX_7215_FAN_DRAWERS = 2
+MAX_7215_FANS_PER_DRAWER = 1
+MAX_7215_PSU = 2
+MAX_7215_THERMAL = 6
+
+# Temp - disable these to help with early debug
+MAX_7215_COMPONENT = 2
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class Chassis(ChassisBase):
+    """
+    Nokia platform-specific Chassis class
+        Derived from Dell S6000 platform.
+        customized for the 7215 platform.
+    """
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']
+        # Port numbers for SFP List Initialization
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        # for non-sfp ports create dummy objects for copper / non-sfp ports
+        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
+            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
+            self._sfp_list.append(sfp_node)
+
+        # Verify optoe2 driver SFP eeprom devices were enumerated and exist
+        # then create the sfp nodes
+        eeprom_path = "/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom"
+        mux_dev = sorted(glob.glob("/sys/class/i2c-adapter/i2c-0/i2c-[0-9]"))
+        y = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            mux_dev_num = mux_dev[y]
+            port_i2c_map = mux_dev_num[-1]
+            y = y + 1
+            port_eeprom_path = eeprom_path.format(port_i2c_map)
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info("path %s didnt exist" % port_eeprom_path)
+            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)
+            self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate system eeprom object
+        self._eeprom = Eeprom()
+
+        # Construct lists fans, power supplies, thermals & components
+        drawer_num = MAX_7215_FAN_DRAWERS
+        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER
+        drawer_ctor = RealDrawer
+        fan_index = 0
+        for drawer_index in range(drawer_num):
+            drawer = drawer_ctor(drawer_index)
+            self._fan_drawer_list.append(drawer)
+            for index in range(fan_num_per_drawer):
+                fan = Fan(fan_index, drawer)
+                fan_index += 1
+                drawer._fan_list.append(fan)
+                self._fan_list.append(fan)
+
+        for i in range(MAX_7215_PSU):
+            psu = Psu(i)
+            self._psu_list.append(psu)
+
+        for i in range(MAX_7215_THERMAL):
+            thermal = Thermal(i)
+            self._thermal_list.append(thermal)
+
+        for i in range(MAX_7215_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a
+            chassis starting from 1.
+
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_service_tag(self):
+        """
+        Retrieves the Service Tag of the chassis
+        Returns:
+            string: Service Tag of chassis
+        """
+        return self._eeprom.service_tag_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_revision(self):
+        """
+        Retrieves the hardware revision of the chassis
+
+        Returns:
+            string: Revision value of chassis
+        """
+        if smbus_present == 0:  # called from host
+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x0
+            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+        return str(value)
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        # The ixs7215 CPLD does not have a hardware reboot cause register so
+        # the hardware portion of reboot cause can't be implemented
+
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status(port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have timeout
+            # value return true without change after timeout and will
+            # transition to "SYSTEM_READY"
+            status = self.sfp_event.check_sfp_status(port_dict, timeout)
+
+        if status:
+            return True, {'sfp': port_dict}
+        else:
+            return True, {'sfp': {}}
+
+    def get_thermal_manager(self):
+        from .thermal_manager import ThermalManager
+        return ThermalManager
+
+    def initizalize_system_led(self):
+        return True
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the system LED
+
+        Args:
+            color: A string representing the color with which to set the
+                   system LED
+
+        Returns:
+            bool: True if system LED state is set successfully, False if not
+        """
+        if color not in self.system_led_supported_color:
+            return False
+
+        if (color == 'off'):
+            value = 0x00
+        elif (color == 'amber'):
+            value = 0x01
+        elif (color == 'green'):
+            value = 0x02
+        elif (color == 'amber_blink'):
+            value = 0x03
+        elif (color == 'green_blink'):
+            value = 0x04
+        else:
+            return False
+
+        # Write sys led
+        if smbus_present == 0:  # called from host (e.g. 'show system-health')
+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])
+            if cmdstatus:
+                sonic_logger.log_warning("  System LED set %s failed" % value)
+                return False
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICEREG = 0x7
+            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)
+
+        return True
+
+    def get_status_led(self):
+        """
+        Gets the state of the system LED
+
+        Returns:
+            A string, one of the valid LED color strings which could be vendor
+            specified.
+        """
+        # Read sys led
+        if smbus_present == 0:  # called from host
+            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])
+            value = int(value, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x7
+            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if value == 0x00:
+            color = 'off'
+        elif value == 0x01:
+            color = 'amber'
+        elif value == 0x02:
+            color = 'green'
+        elif value == 0x03:
+            color = 'amber_blink'
+        elif value == 0x04:
+            color = 'green_blink'
+        else:
+            return None
+
+        return color
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+
+        Note:
+            We overload this method to ensure that watchdog is only initialized
+            when it is referenced. Currently, only one daemon can open the
+            watchdog. To initialize watchdog in the constructor causes multiple
+            daemon try opening watchdog when loading and constructing a chassis
+            object and fail. By doing so we can eliminate that risk.
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+    def get_position_in_parent(self):
+        """
+		Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position
+        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned
+		Returns:
+		    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position
+		"""
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/component.py
new file mode 100644
index 00000000000..4e8863e64fd
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/component.py
@@ -0,0 +1,175 @@
+########################################################################
+# NOKIA IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import os
+    import subprocess
+    import ntpath
+    from sonic_platform_base.component_base import ComponentBase
+    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+
+class Component(ComponentBase):
+    """Nokia platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["System-CPLD", "Used for managing SFPs, LEDs, PSUs and FANs "],
+        ["U-Boot", "Performs initialization during booting"],
+    ]
+    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']
+    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']
+    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']
+    CPLD_UPDATE_COMMAND4 = ['./vme', '']
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_cpld_version(self, cpld_number):
+
+        if smbus_present == 0:
+            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x2
+            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))
+
+        return str(int(cpld_version, 16))
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_model(self):
+        """
+        Retrieves the part number of the component
+        Returns:
+            string: Part number of component
+        """
+        return 'NA'
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the component
+        Returns:
+            string: Serial number of component
+        """
+        return 'NA'
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the component
+        Returns:
+            bool: True if  present, False if not
+        """
+        return True
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the component
+        Returns:
+            bool: True if component is operating properly, False if not
+        """
+        return True
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device.
+        Returns:
+            integer: The 1-based relative physical position in parent
+            device or -1 if cannot determine the position
+        """
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether component is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+        if self.index == 0:
+            return self._get_cpld_version(self.index)
+
+        if self.index == 1:
+            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']
+            cmd2 = ['head', '-1']
+            cmd3 = ['cut', '-d', ' ', '-f2-4']
+            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)
+            return uboot_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        image_name = ntpath.basename(image_path)
+        print(" ixs7215 - install cpld {}".format(image_name))
+
+        # check whether the image file exists
+        if not os.path.isfile(image_path):
+            print("ERROR: the cpld image {} doesn't exist ".format(image_path))
+            return False
+
+        self.CPLD_UPDATE_COMMAND2[1] = image_path
+        self.CPLD_UPDATE_COMMAND4[1] = image_name
+
+        success_flag = False
+ 
+        try:   
+            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)
+            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)
+            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)
+            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)
+            success_flag = True
+        except subprocess.CalledProcessError as e:
+            print("ERROR: Failed to upgrade CPLD: rc={}".format(e.returncode))
+
+        if success_flag:
+            print("INFO: Refresh or power cycle is required to finish CPLD installation")
+
+        return success_flag
+
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/eeprom.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/eeprom.py
new file mode 100644
index 00000000000..b3b31605b24
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/eeprom.py
@@ -0,0 +1,284 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Model name and Part number.
+# - Fan EEPROM : Contains Part number, Serial number, Manufacture Date,
+#                and Service Tag.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('Model', 's', 15), ('burn', 'x', 1),
+    ('Part Number', 's', 14), ('burn', 'x', 40),
+    ('Serial Number', 's', 11)
+    ]
+
+sonic_logger = logger.Logger('eeprom')
+
+
+class Eeprom(TlvInfoDecoder):
+    """Nokia platform-specific EEPROM class"""
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0053/eeprom"
+
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 18
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-1/1-005{}/eeprom".format(self.index - 1)
+                self.format = psu_eeprom_format
+
+                # Decode device eeprom as per specified format
+                EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                       self.start_offset, '', True)
+            else:
+                self.index = fan_index
+                self.start_offset = 0
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(self.index + 4)
+
+                # Fan EEPROM is in ONIE TlvInfo EEPROM format
+                super(Eeprom, self).__init__(self.eeprom_path,
+                                             self.start_offset, '', True)
+
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            sonic_logger.log_warning("Unable to read system eeprom")
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.service_tag = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            if not self.is_valid_tlvinfo_header(eeprom):
+                sonic_logger.log_warning("Invalid system eeprom TLV header")
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.service_tag = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            # Construct dictionary of eeprom TLV entries
+            self.eeprom_tlv_dict = dict()
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.service_tag = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and interprets as per the specified format
+        """
+        self.serial_number = 'NA'
+        self.part_number = 'NA'
+        self.model_str = 'NA'
+        self.service_tag = 'NA'
+        self.mfg_date = 'NA'
+
+        # PSU device eeproms use proprietary format
+        if self.is_psu_eeprom:
+            try:
+                # Read Fan/PSU EEPROM as per the specified format.
+                self.eeprom_data = EepromDecoder.read_eeprom(self)
+            except Exception as e:
+                sonic_logger.log_warning("Unable to read device eeprom for PSU#{}".format(self.index))
+                return
+
+            # Bail out if PSU eeprom unavailable
+            if self.eeprom_data[0] == 255:
+                sonic_logger.log_warning("Uninitialized device eeprom for PSU#{}".format(self.index))
+                return
+
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data.decode()
+
+            (valid, data) = self._get_eeprom_field("Part Number")
+            if valid:
+                self.part_number = data.decode()
+
+            # Early PSU device eeproms were not programmed with serial #
+            try:
+                (valid, data) = self._get_eeprom_field("Serial Number")
+                if valid:
+                    self.serial_number = data.decode()
+            except Exception as e:
+                sonic_logger.log_warning("Unable to read serial# of PSU#{}".format(self.index))
+                return
+
+        # Fan device eeproms use ONIE TLV format
+        else:
+            try:
+                # Read Fan EEPROM as per ONIE TlvInfo EEPROM format.
+                self.eeprom_data = self.read_eeprom()
+            except Exception as e:
+                sonic_logger.log_warning("Unable to read device eeprom for Fan#{}".format(self.index))
+                return
+
+            eeprom = self.eeprom_data
+            if not self.is_valid_tlvinfo_header(eeprom):
+                sonic_logger.log_warning("Invalid device eeprom TLV header for Fan#{}".format(self.index))
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            # Construct dictionary of eeprom TLV entries
+            self.eeprom_tlv_dict = dict()
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.serial_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.service_tag = self.eeprom_tlv_dict.get(
+                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _get_eeprom_field(self, field_name, decode=False):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                if decode:
+                    return (True, self.eeprom_data[field_start:field_end].decode('ascii'))
+                else:
+                    return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def service_tag_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.service_tag
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan.py
new file mode 100644
index 00000000000..71334ca4858
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan.py
@@ -0,0 +1,384 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Fans' information which are available in the platform
+#
+########################################################################
+
+
+try:
+    import os
+    import time
+    from sonic_platform_base.fan_base import FanBase
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+MAX_IXS7215_FAN_SPEED = 19000
+WORKING_IXS7215_FAN_SPEED = 960
+
+sonic_logger = logger.Logger('fan')
+
+
+class Fan(FanBase):
+    """Nokia platform-specific Fan class"""
+
+    def __init__(self, fan_index, fan_drawer, psu_fan=False, dependency=None):
+        self.is_psu_fan = psu_fan
+        ADT7473_DIR = "/sys/bus/i2c/devices/0-002e/hwmon/hwmon1/"
+
+        if not self.is_psu_fan:
+            # Fan is 1-based in Nokia platforms
+            self.index = fan_index + 1
+            self.fan_drawer = fan_drawer
+            self.set_fan_speed_reg = ADT7473_DIR+"pwm{}".format(self.index)
+            self.get_fan_speed_reg = ADT7473_DIR+"fan{}_input".format(self.index)
+            self.max_fan_speed = MAX_IXS7215_FAN_SPEED
+            self.supported_led_color = ['off', 'green', 'red']
+
+            # Fan eeprom
+            self.eeprom = Eeprom(is_fan=True, fan_index=self.index)
+        else:
+            # this is a PSU Fan
+            self.index = fan_index
+            self.dependency = dependency
+
+    def _get_i2c_register(self, reg_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(reg_file)):
+            return rv
+
+        try:
+            with open(reg_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _set_i2c_register(self, reg_file, value):
+        # On successful write, the value read will be written on
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(reg_file)):
+            return rv
+
+        try:
+            with open(reg_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        # Ensure that the write operation has succeeded
+        if (int(self._get_i2c_register(reg_file)) != value ):
+            time.sleep(3)
+            if (int(self._get_i2c_register(reg_file)) != value ):
+                rv = 'ERR'
+
+        return rv
+
+    def get_name(self):
+        """
+        Retrieves the name of the Fan
+
+        Returns:
+            string: The name of the Fan
+        """
+        if not self.is_psu_fan:
+            return "Fan{}".format(self.index)
+        else:
+            return "PSU{} Fan".format(self.index)
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the Fan Unit
+
+        Returns:
+            bool: True if Fan is present, False if not
+        """
+        if smbus_present == 0:
+            sonic_logger.log_info("PMON fan-smbus ERROR - presence ")
+            return False
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0xb
+            fanstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            fanstatus = fanstatus & 1
+            if fanstatus == 1:
+                return False
+        if self.index == 2:
+            fanstatus = fanstatus & 2
+            if fanstatus == 2:
+                return False
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number of the Fan
+
+        Returns:
+            string: Model number of Fan. Use part number for this.
+        """
+        return self.eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Fan
+
+        Returns:
+            string: Serial number of Fan
+        """
+        return self.eeprom.serial_number_str()
+
+    def get_part_number(self):
+        """
+        Retrieves the part number of the Fan
+
+        Returns:
+            string: Part number of Fan
+        """
+        return self.eeprom.part_number_str()
+
+    def get_service_tag(self):
+        """
+        Retrieves the service tag of the Fan
+
+        Returns:
+            string: Service Tag of Fan
+        """
+        return self.eeprom.service_tag_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the Fan
+
+        Returns:
+            bool: True if Fan is operating properly, False if not
+        """
+        status = False
+
+        fan_speed = self._get_i2c_register(self.get_fan_speed_reg)
+        if (fan_speed != 'ERR'):
+            if (int(fan_speed) > WORKING_IXS7215_FAN_SPEED):
+                status = True
+
+        return status
+
+    def get_direction(self):
+        """
+        Retrieves the fan airflow direction
+        Possible fan directions (relative to port-side of device)
+        Returns:
+            A string, either FAN_DIRECTION_INTAKE or
+            FAN_DIRECTION_EXHAUST depending on fan direction
+        """
+
+        return 'intake'
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return True
+
+
+    def get_speed(self):
+        """
+        Retrieves the speed of a Front FAN in the tray in revolutions per
+                 minute defined by 1-based index
+        :param index: An integer, 1-based index of the FAN to query speed
+        :return: integer, denoting front FAN speed
+        """
+        speed = 0
+
+        fan_speed = self._get_i2c_register(self.get_fan_speed_reg)
+        if (fan_speed != 'ERR'):
+            speed_in_rpm = int(fan_speed)
+        else:
+            speed_in_rpm = 0
+
+        speed = 100*speed_in_rpm//MAX_IXS7215_FAN_SPEED
+        if speed > 100:
+            speed = 100
+
+        return speed
+
+    def get_speed_tolerance(self):
+        """
+        Retrieves the speed tolerance of the fan
+
+        Returns:
+            An integer, the percentage of variance from target speed
+            which is considered tolerable
+        """
+        if self.get_presence():
+            # The tolerance value is fixed as 25% for this platform
+            tolerance = 25
+        else:
+            tolerance = 0
+
+        return tolerance
+
+    def set_speed(self, speed):
+        """
+        Set fan speed to expected value
+        Args:
+            speed: An integer, the percentage of full fan speed to set
+            fan to, in the range 0 (off) to 100 (full speed)
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        if self.is_psu_fan:
+            return False
+
+        # Set current fan duty cycle
+        # - 0x00 : fan off
+        # - 0x40 : 25% duty cycle
+        # - 0x80 : 50% duty cycle (default)
+        # - 0xff : 100% duty cycle (full speed)
+        if speed in range(0, 6):
+            fandutycycle = 0x00
+        elif speed in range(6, 41):
+            fandutycycle = 64
+        elif speed in range(41, 76):
+            fandutycycle = 128
+        elif speed in range(76, 101):
+            fandutycycle = 255
+        else:
+            return False
+
+        rv = self._set_i2c_register(self.set_fan_speed_reg, fandutycycle)
+        if (rv != 'ERR'):
+            return True
+        else:
+            return False
+
+    def set_status_led(self, color):
+        """
+        Set led to expected color
+        Args:
+            color: A string representing the color with which to set the
+                   fan module status LED
+        Returns:
+            bool: True if set success, False if fail.
+
+            off , red and green are the only settings 7215 fans
+        """
+
+        if self.is_psu_fan or (color not in self.supported_led_color):
+            return False
+        if (color == self.STATUS_LED_COLOR_AMBER):
+            return False
+        if (color == self.STATUS_LED_COLOR_RED):
+            value = 0x02
+        elif (color == self.STATUS_LED_COLOR_GREEN):
+            value = 0x01
+        elif (color == self.STATUS_LED_COLOR_OFF):
+            value = 0x00
+        else:
+            return False
+
+        if smbus_present == 0:
+            return False
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICEREG = 0x8
+            original = bus.read_byte_data(DEVICE_ADDRESS, DEVICEREG)
+            if (self.index == 1):
+                new = value << 4
+                ledstatus = original & 0xcf
+                ledstatus = ledstatus | new
+            elif self.index == 2:
+                new = value << 6
+                ledstatus = original & 0x3f
+                ledstatus = ledstatus | new
+            else:
+                return False
+
+            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, ledstatus)
+
+        return True
+
+    def get_status_led(self):
+        """
+        Gets the state of the fan status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+
+        if self.is_psu_fan:
+            return None
+
+        if smbus_present == 0:
+            return None
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x8
+            ledstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            ledstatus = (ledstatus & 0x30)
+            ledstatus = ledstatus >> 4
+        elif self.index == 2:
+            ledstatus = (ledstatus & 0xC0)
+            ledstatus = ledstatus >> 6
+        if ledstatus == 0x02:
+            return self.STATUS_LED_COLOR_RED
+        elif ledstatus == 0x1:
+            return self.STATUS_LED_COLOR_GREEN
+        else:
+            return self.STATUS_LED_COLOR_OFF
+
+    def get_target_speed(self):
+        """
+        Retrieves the target (expected) speed of the fan
+
+        Returns:
+            An integer, the percentage of full fan speed, in the range 0
+            (off) to 100 (full speed)
+        """
+        speed = 0
+
+        fan_duty = self._get_i2c_register(self.set_fan_speed_reg)
+        if (fan_duty != 'ERR'):
+            dutyspeed = int(fan_duty)
+            if dutyspeed == 0:
+                speed = 0
+            elif dutyspeed == 64:
+                speed = 25
+            elif dutyspeed == 128:
+                speed = 50
+            elif dutyspeed == 255:
+                speed = 100
+
+        return speed
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
new file mode 100644
index 00000000000..6c6218f0a79
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
@@ -0,0 +1,102 @@
+#############################################################################
+# Nokia
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Fan Drawer status which is available in the platform
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.fan_drawer_base import FanDrawerBase
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('fan_drawer')
+
+class NokiaFanDrawer(FanDrawerBase):
+    def __init__(self, index):
+        super(NokiaFanDrawer, self).__init__()
+        self._index = index + 1
+        self._led = None
+
+    def get_index(self):
+        return self._index
+
+    def get_presence(self):
+        return self._fan_list[0].get_presence()
+
+    def get_model(self):
+        """
+        Retrieves the model number of the Fan Drawer
+        Returns:
+            string: Part number of Fan Drawer
+        """
+        return self._fan_list[0].get_model()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Fan Drawer
+        Returns:
+            string: Serial number of Fan
+        """
+        return self._fan_list[0].get_serial()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the Fan Drawer
+        Returns:
+            bool: True if Fan is operating properly, False if not
+        """
+        return self._fan_list[0].get_status()
+
+    def get_direction(self):
+        return 'intake'
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the fan drawer status LED
+
+        Args:
+            color: A string representing the color with which to set the
+                   fan drawer status LED
+
+        Returns:
+            bool: True if status LED state is set successfully, False if not
+        """
+        return self._fan_list[0].set_status_led(color)
+
+    def get_status_led(self):
+        """
+        Gets the state of the fan drawer LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings
+        """
+        return self._fan_list[0].get_status_led()
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return True
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self._index
+
+
+# For Nokia platforms with fan drawer(s)
+class RealDrawer(NokiaFanDrawer):
+    def __init__(self, index):
+        super(RealDrawer, self).__init__(index)
+        self._name = 'drawer{}'.format(self._index)
+
+    def get_name(self):
+        return self._name
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/platform.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/platform.py
new file mode 100755
index 00000000000..7a3046bc739
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+    """
+    Nokia platform-specific class
+    """
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/psu.py
new file mode 100644
index 00000000000..243b807edb7
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/psu.py
@@ -0,0 +1,317 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the PSUs' information which are available in the platform
+#
+########################################################################
+
+try:
+    import os
+    from sonic_platform_base.psu_base import PsuBase
+    from sonic_py_common import logger
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common.general import getstatusoutput_noshell
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+smbus_present = 1
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+sonic_logger = logger.Logger('psu')
+
+class Psu(PsuBase):
+    """Nokia platform-specific PSU class for 7215 """
+
+    def __init__(self, psu_index):
+        PsuBase.__init__(self)
+        # PSU is 1-based in Nokia platforms
+        self.index = psu_index + 1
+        self._fan_list = []
+
+        # PSU eeprom
+        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)
+
+    def _write_sysfs_file(self, sysfs_file, value):
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'w') as fd:
+                rv = fd.write(str(value))
+        except Exception as e:
+            rv = 'ERR'
+
+        return rv
+
+    def _read_sysfs_file(self, sysfs_file):
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+
+        Returns:
+            string: The name of the device
+        """
+        return "PSU{}".format(self.index)
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the Power Supply Unit (PSU)
+
+        Returns:
+            bool: True if PSU is present, False if not
+        """
+
+        if smbus_present == 0:  # if called from psuutil outside of pmon
+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
+            psustatus = int(psustatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0xa
+            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            psustatus = psustatus & 1
+            if psustatus == 1:
+                return False
+        if self.index == 2:
+            psustatus = psustatus & 2
+            if psustatus == 2:
+                return False
+
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the part number of the PSU
+
+        Returns:
+            string: Part number of PSU
+        """
+        return self.eeprom.modelstr()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the PSU
+
+        Returns:
+            string: Serial number of PSU
+        """
+        return self.eeprom.serial_number_str()
+
+    def get_revision(self):
+        """
+        Retrieves the HW revision of the PSU
+
+        Returns:
+            string: HW revision of PSU
+        """
+        return self.eeprom.part_number_str()
+
+    def get_part_number(self):
+        """
+        Retrieves the part number of the PSU
+
+        Returns:
+            string: Part number of PSU
+        """
+        return self.eeprom.part_number_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the PSU
+
+        Returns:
+            bool: True if PSU is operating properly, False if not
+        """
+
+        if smbus_present == 0:
+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
+            psustatus = int(psustatus, 16)
+            sonic_logger.log_warning("PMON psu-smbus - presence = 0 ")
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0xa
+            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            psustatus = psustatus & 4
+            if psustatus == 4:
+                return True
+        if self.index == 2:
+            psustatus = psustatus & 8
+            if psustatus == 8:
+                return True
+
+        return False
+
+    def get_voltage(self):
+        """
+        Retrieves current PSU voltage output
+
+        Returns:
+            A float number, the output voltage in volts,
+            e.g. 12.1
+        """
+        if smbus_present == 0:
+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
+            psustatus = int(psustatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0xa
+            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            psustatus = psustatus & 4
+            if psustatus == 4:
+                psu_voltage = 12.0
+                return psu_voltage
+        if self.index == 2:
+            psustatus = psustatus & 8
+            if psustatus == 8:
+                psu_voltage = 12.0
+                return psu_voltage
+
+        psu_voltage = 0.0
+        return psu_voltage
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return True
+
+    def get_powergood_status(self):
+        """
+        Retrieves the powergood status of PSU
+        Returns:
+            A boolean, True if PSU has stablized its output voltages and
+            passed all its internal self-tests, False if not.
+        """
+
+        if smbus_present == 0:
+            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
+            psustatus = int(psustatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0xa
+            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        if self.index == 1:
+            psustatus = psustatus & 4
+            if psustatus == 4:
+                return True
+        if self.index == 2:
+            psustatus = psustatus & 8
+            if psustatus == 8:
+                return True
+
+        return False
+
+    def get_status_led(self):
+        """
+        Gets the state of the PSU status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+        if self.get_powergood_status():
+            return self.STATUS_LED_COLOR_GREEN
+        else:
+            return self.STATUS_LED_COLOR_OFF
+
+    def set_status_led(self, color):
+        """
+        Sets the state of the PSU status LED
+        Args:
+            color: A string representing the color with which to set the
+                   PSU status LED
+        Returns:
+            bool: True if status LED state is set successfully, False if
+                  not
+        """
+        # The firmware running in the PSU controls the LED
+        # and the PSU LED state cannot be changed from CPU.
+        return False
+
+    def get_status_master_led(self):
+        """
+        Gets the state of the front panel PSU status LED
+
+        Returns:
+            A string, one of the predefined STATUS_LED_COLOR_* strings.
+        """
+        if (not os.path.isfile("/sys/class/gpio/psuLedGreen/value") or
+            not os.path.isfile("/sys/class/gpio/psuLedAmber/value")):
+            return None
+
+        green = self._read_sysfs_file("/sys/class/gpio/psuLedGreen/value")
+        amber = self._read_sysfs_file("/sys/class/gpio/psuLedAmber/value")
+        if green == "ERR" or amber == "ERR":
+            return None
+        if green == "1":
+            return self.STATUS_LED_COLOR_GREEN
+        elif amber == "1":
+            return self.STATUS_LED_COLOR_AMBER
+        else:
+            return None
+
+    def set_status_master_led(self, color):
+        """
+        Sets the state of the front panel PSU status LED
+
+        Returns:
+            bool: True if status LED state is set successfully, False if
+                  not
+        """
+        if (not os.path.isfile("/sys/class/gpio/psuLedGreen/value") or
+            not os.path.isfile("/sys/class/gpio/psuLedAmber/value")):
+            return False
+
+        if color == self.STATUS_LED_COLOR_GREEN:
+            rvg = self._write_sysfs_file("/sys/class/gpio/psuLedGreen/value", 1)
+            if rvg != "ERR":
+                rva = self._write_sysfs_file("/sys/class/gpio/psuLedAmber/value", 0)
+        elif color == self.STATUS_LED_COLOR_AMBER:
+            rvg = self._write_sysfs_file("/sys/class/gpio/psuLedGreen/value", 0)
+            if rvg != "ERR":
+                rva = self._write_sysfs_file("/sys/class/gpio/psuLedAmber/value", 1)
+        else:
+            return False
+
+        if rvg == "ERR" or rva == "ERR":
+            return False
+
+        return True
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp.py
new file mode 100644
index 00000000000..e05908386d3
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp.py
@@ -0,0 +1,216 @@
+# Name: sfp.py, version: 1.0
+#
+# Description: Module contains the definitions of SFP related APIs
+# for Nokia IXR 7250 platform.
+#
+# Copyright (c) 2023, Nokia
+# All rights reserved.
+#
+
+try:
+    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase
+    from sonic_py_common.logger import Logger
+    from sonic_py_common import device_info
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+import subprocess as cmd
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+
+logger = Logger()
+
+class Sfp(SfpOptoeBase):
+    """
+    Nokia IXR-7215 Platform-specific Sfp refactor class
+    """
+    instances = []
+
+    # Paths
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+
+    PLATFORM = "armhf-nokia_ixs7215_52x-r0"
+    HWSKU = "Nokia-7215"
+
+    port_to_i2c_mapping = 0
+
+    # def __init__(self, index, sfp_type, stub):
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpOptoeBase.__init__(self)
+
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.name = sfp_type + str(index-1)
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+
+        self.port_to_eeprom_mapping[index] = eeprom_path
+
+        self._version_info = device_info.get_sonic_version_info()
+        self.lastPresence = False
+
+        logger.log_debug("Sfp __init__ index {} setting name to {} and eeprom_path to {}".format(index, self.name, self.eeprom_path))
+
+        Sfp.instances.append(self)
+        
+    def get_eeprom_path(self):
+        return self.eeprom_path
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+
+        if smbus_present == 0:  # if called from sfputil outside of pmon
+            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x3
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        pos = [1, 2, 4, 8]
+        bit_pos = pos[self.index-SFP_PORT_START]
+        sfpstatus = sfpstatus & (bit_pos)
+
+        if sfpstatus == 0:
+            return True
+
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device.
+        Returns:
+            integer: The 1-based relative physical position in parent device or
+                     -1 if cannot determine the position
+        """
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+
+        if self.sfp_type == "SFP":
+            return True
+        else:
+            return False
+
+    def _get_error_code(self):
+        """
+        Get error code of the SFP module
+
+        Returns:
+            The error code
+        """
+        return NotImplementedError
+
+    def get_error_description(self):
+        """
+        Get error description
+
+        Args:
+            error_code: The error code returned by _get_error_code
+
+        Returns:
+            The error description
+        """
+        if not self.get_presence():
+            error_description = self.SFP_STATUS_UNPLUGGED
+        else:
+            error_description = self.SFP_STATUS_OK
+
+        return error_description
+        # return NotImplementedError
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        """
+        reset = self.get_reset_status()
+
+        if reset is True:
+            status = False
+        else:
+            status = True
+
+        return status
+
+    def reset(self):
+        """
+        Reset SFP.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        # RJ45 and SFP ports not resettable
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
new file mode 100644
index 00000000000..34fc2bc6ae5
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
@@ -0,0 +1,112 @@
+'''
+listen for the SFP change event and return to chassis.
+'''
+import time
+from sonic_py_common import logger
+from sonic_py_common.general import getstatusoutput_noshell
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    def __init__(self):
+        self.handle = None
+
+    def initialize(self):
+        self.modprs_register = 0
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x3
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+            sfpstatus = ~sfpstatus
+            sfpstatus = sfpstatus & 0xF
+
+        return sfpstatus
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+        check_sfp_status called from get_change_event, this will return correct
+            status of all 4 SFP ports if there is a change in any of them
+        """
+        start_time = time.time()
+        port = SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000)  # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {}  # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
+                    # Mask off the bit corresponding to our port
+                    mask = (1 << port-SFP_PORT_START)
+                    if (changed_ports & mask):
+                        # ModPrsL is active high
+                        if reg_value & mask == 0:
+                            port_change[port] = '0'
+                        else:
+                            port_change[port] = '1'
+                    port += 1
+
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1)  # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
+        return False, {}
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/README b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/README
new file mode 100644
index 00000000000..3efc8fabce0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/README
@@ -0,0 +1 @@
+This directory contains unit tests of the Platform API 2.0
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
new file mode 100755
index 00000000000..93dfcaac3d0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
@@ -0,0 +1,72 @@
+#!/usr/bin/env python
+
+try:
+    import sonic_platform.platform
+    import sonic_platform.chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def main():
+    print("-----------------")
+    print("Chassis Unit Test")
+    print("-----------------")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    print("  Chassis name: {}".format(chassis.get_name()))
+
+    print("  Chassis presence: {}".format(chassis.get_presence()))
+
+    print("  Chassis model: {}".format(chassis.get_model()))
+
+    print("  Chassis serial: {}".format(chassis.get_serial()))
+
+    print("  Chassis revision: {}".format(chassis.get_revision()))
+
+    print("  Chassis status: {}".format(chassis.get_status()))
+
+    print("  Chassis base_mac: {}".format(chassis.get_base_mac()))
+
+    print("  Chassis reboot cause: {}\n".format(chassis.get_reboot_cause()))
+
+    print("  Chassis watchdog: {}".format(chassis.get_watchdog()))
+
+    print("  Chassis num_components: {}".format(chassis.get_num_components()))
+
+    print("  Chassis all_components: {}\n".format(chassis.get_all_components()))
+
+    print("  Chassis num_modules: {}".format(chassis.get_num_modules()))
+
+    print("  Chassis all_modules: {}\n".format(chassis.get_all_modules()))
+
+    print("  Chassis num_fans: {}".format(chassis.get_num_fans()))
+
+    print("  Chassis all_fans: {}\n".format(chassis.get_all_fans()))
+
+    print("  Chassis num_psus: {}".format(chassis.get_num_psus()))
+
+    print("  Chassis all_psus: {}\n".format(chassis.get_all_psus()))
+
+    print("  Chassis num_thermals: {}".format(chassis.get_num_thermals()))
+
+    print("  Chassis all_thermals: {}\n".format(chassis.get_all_thermals()))
+
+    print("  Chassis num_sfps: {}".format(chassis.get_num_sfps()))
+
+    print("  Chassis all_sfps: {}\n".format(chassis.get_all_sfps()))
+
+    print("  Chassis eeprom: {}".format(chassis.get_eeprom()))
+
+    print("  Chassis system_eeprom_info: {}\n".format(chassis.get_system_eeprom_info()))
+
+    print("  Chassis get_status_led start : {}\n".format(chassis.get_status_led()))
+    chassis.set_status_led('amber')
+    print("  Chassis get_status_led amber: {}\n".format(chassis.get_status_led()))
+    chassis.set_status_led('green')
+    print("  Chassis get_status_led green: {}\n".format(chassis.get_status_led()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-component.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
new file mode 100755
index 00000000000..1116cc7b585
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------------")
+    print("Chassis Component Unit Test")
+    print("---------------------------")
+
+    chassis = Chassis()
+
+    for component in chassis.get_all_components():
+        print("    Name: {}".format(component.get_name()))
+        print("        Description: {}".format(component.get_description()))
+        print("        FW version: {}\n".format(component.get_firmware_version()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
new file mode 100755
index 00000000000..40836611692
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
@@ -0,0 +1,25 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("------------------------")
+    print("Chassis eeprom Unit Test")
+    print("------------------------")
+
+    chassis = Chassis()
+
+    eeprom = chassis.get_eeprom()
+
+    print("    Model: {}, Service Tag: {}".format(eeprom.modelstr(),
+                                             eeprom.service_tag_str()))
+    print("    Part#: {}, Serial#: {}".format(eeprom.part_number_str(),
+                                              eeprom.serial_number_str()))
+    print("    Base MAC: {}".format(eeprom.base_mac_addr()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
new file mode 100755
index 00000000000..9bbf4d864ac
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
@@ -0,0 +1,32 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis Fan Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    for fan in chassis.get_all_fans():
+        if not fan.get_presence():
+            print("    Name: {} not present".format(fan.get_name()))
+        else:
+            print("    Name:", fan.get_name())
+            print("        Presence: {}, Status: {}, LED: {}".format(fan.get_presence(),
+                                                                     fan.get_status(),
+                                                                     fan.get_status_led()))
+            print("        Model: {}, Serial#: {}".format(fan.get_model(),
+                                                          fan.get_serial()))
+            print("        Part#: {}, Service Tag: {}".format(fan.get_part_number(),
+                                                              fan.get_service_tag()))
+            print("        Direction: {}, Speed: {}RPM, Target Speed: {}%\n".format(fan.get_direction(),
+                                                                                    str(fan.get_speed()),
+                                                                                    str(fan.get_target_speed())))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
new file mode 100755
index 00000000000..e3979b8c417
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
@@ -0,0 +1,40 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis PSU Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    for psu in chassis.get_all_psus():
+        if not psu.get_presence():
+            print("    Name: {} not present".format(psu.get_name()))
+        else:
+            print("    Name:", psu.get_name())
+            print("        Presence: {}, Status: {}, LED: {}".format(psu.get_presence(),
+                                                                     psu.get_status(),
+                                                                     psu.get_status_led()))
+            print("        Model: {}, Serial#: {}, Part#: {}".format(psu.get_model(),
+                                                                     psu.get_serial(),
+                                                                     psu.get_part_number()))
+            try:
+                current = psu.get_current()
+            except NotImplementedError:
+                current = "NA"
+            try:
+                power = psu.get_power()
+            except NotImplementedError:
+                power = "NA"
+
+            print("        Voltage: {}, Current: {}, Power: {}\n".format(psu.get_voltage(),
+                                                                         current,
+                                                                         power))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
new file mode 100755
index 00000000000..4d283fa2eb0
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
@@ -0,0 +1,56 @@
+#!/usr/bin/env python
+
+try:
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+def main():
+    print("---------------------")
+    print("Chassis SFP Unit Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    PORT_START = 1
+    PORT_END = 52
+
+    for physical_port in range(PORT_START, PORT_END+1):
+        print(" ")
+        print(" SFP transceiver tests  PORT = ", physical_port)
+        name = chassis.get_sfp(physical_port).get_name()
+        print(" SFP transceiver tests  NAME = ", name)
+
+        presence = chassis.get_sfp(physical_port).get_presence()
+        print("TEST 1 - sfp presence       [ True ] ", physical_port, presence)
+
+        status = chassis.get_sfp(physical_port).get_reset_status()
+        print("TEST 2 - sfp reset status   [ False ] ", physical_port, status)
+
+        txdisable = chassis.get_sfp(physical_port).get_tx_disable()
+        print("TEST 3 - sfp tx_disable     [ False ] ", physical_port, txdisable)
+
+        rxlos = chassis.get_sfp(physical_port).get_rx_los()
+        print("TEST 4 - sfp status rxlos   [ False ] ", physical_port, rxlos)
+
+        txfault = chassis.get_sfp(physical_port).get_tx_fault()
+        print("TEST 5 - sfp status txfault [ False ] ", physical_port, txfault)
+
+        lpmode = chassis.get_sfp(physical_port).get_lpmode()
+        print("TEST 6 - sfp enable lpmode  [ False ] ", physical_port, lpmode)
+
+        trans_info = chassis.get_sfp(physical_port).get_transceiver_info()
+        print("TEST 7 - sfp transceiver info for port:", physical_port, trans_info)
+
+        trans_status = chassis.get_sfp(physical_port).get_transceiver_bulk_status()
+        print("TEST 8 - sfp bulk status for port:", physical_port, trans_status)
+
+        threshold = chassis.get_sfp(physical_port).get_transceiver_threshold_info()
+        print("TEST 9 - sfp bulk status for port:", physical_port, threshold)
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
new file mode 100755
index 00000000000..95cc8e89f0d
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
@@ -0,0 +1,50 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+def main():
+    print("-------------------------")
+    print("Chassis Thermal Unit Test")
+    print("-------------------------")
+
+    chassis = Chassis()
+
+    for thermal in chassis.get_all_thermals():
+        if not thermal.get_presence():
+            print("    Name: {} not present".format(thermal.get_name()))
+        else:
+            print("    Name:", thermal.get_name())
+            print("        Presence: {}, Status: {}".format(thermal.get_presence(),
+                                                            thermal.get_status()))
+            print("        Model: {}, Serial#: {}".format(thermal.get_model(),
+                                                          thermal.get_serial()))
+            print("        Temperature(C): {}".format(thermal.get_temperature()))
+
+            try:
+                low_thresh = thermal.get_low_threshold()
+            except NotImplementedError:
+                low_thresh = "NA"
+            try:
+                high_thresh = thermal.get_high_threshold()
+            except NotImplementedError:
+                high_thresh = "NA"
+
+            print("        Low Threshold(C): {}, High Threshold(C): {}".format(low_thresh,
+                                                                               high_thresh))
+
+            try:
+                crit_low_thresh = thermal.get_low_critical_threshold()
+            except NotImplementedError:
+                crit_low_thresh = "NA"
+            try:
+                crit_high_thresh = thermal.get_high_critical_threshold()
+            except NotImplementedError:
+                crit_high_thresh = "NA"
+
+            print("        Crit Low Threshold(C): {}, Crit High Threshold(C): {}\n".format(crit_low_thresh,
+                                                                                           crit_high_thresh))
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
new file mode 100755
index 00000000000..20805e04ed2
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
@@ -0,0 +1,22 @@
+#!/usr/bin/python
+
+from sonic_platform.chassis import Chassis
+
+
+def main():
+    print("---------------------")
+    print("Chassis Watchdog Test")
+    print("---------------------")
+
+    chassis = Chassis()
+
+    watchdog = chassis.get_watchdog()
+
+    print("    Armed: {}".format(watchdog.is_armed()))
+    print("    Time Left: {}".format(watchdog.get_remaining_time()))
+
+    return
+
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal.py
new file mode 100644
index 00000000000..444ca5b137d
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal.py
@@ -0,0 +1,259 @@
+########################################################################
+# Nokia IXS7215
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Thermals' information which are available in the platform
+#
+########################################################################
+
+
+try:
+    import os
+    from sonic_platform_base.thermal_base import ThermalBase
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+sonic_logger = logger.Logger('thermal')
+
+class Thermal(ThermalBase):
+    """Nokia platform-specific Thermal class"""
+
+    I2C_CLASS_DIR = "/sys/class/i2c-adapter/"
+    I2C_DEV_MAPPING = (['i2c-0/0-004a/hwmon/', 1],
+                       ['i2c-0/0-004b/hwmon/', 1],
+                       ['i2c-0/0-002e/hwmon/', 1],
+                       ['i2c-0/0-002e/hwmon/', 2],
+                       ['i2c-0/0-002e/hwmon/', 3])
+
+    HWMON_CLASS_DIR = "/sys/class/hwmon/"
+
+    THERMAL_NAME = ("PCB PHY", "PCB MAC",
+                    "ADT7473-CPU", "ADT7473-LOC", "ADT7473-MAC",
+                    "CPU Core")
+
+    def __init__(self, thermal_index):
+        ThermalBase.__init__(self)
+        self.index = thermal_index + 1
+        self.is_psu_thermal = False
+        self.dependency = None
+        self._minimum = None
+        self._maximum = None
+        self.thermal_high_threshold_file = None
+        # PCB temperature sensors
+        if self.index < 3:
+            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
+            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
+            sensor_high_suffix = "max"
+            sensor_high_crit_suffix = None
+            hwmon_node = os.listdir(i2c_path)[0]
+            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
+
+        # ADT7473 temperature sensors
+        elif self.index < 6:
+            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
+            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
+            sensor_high_suffix = "crit"
+            sensor_high_crit_suffix = None
+            hwmon_node = os.listdir(i2c_path)[0]
+            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
+
+        # Armada 38x SOC temperature sensor
+        else:
+            dev_path = self.HWMON_CLASS_DIR
+            sensor_index = 1
+            sensor_high_suffix = None
+            sensor_high_crit_suffix = None
+            hwmon_node = os.listdir(dev_path)[0]
+            self.SENSOR_DIR = dev_path + hwmon_node + '/'
+
+        # sysfs file for current temperature value
+        self.thermal_temperature_file = self.SENSOR_DIR \
+            + "temp{}_input".format(sensor_index)
+
+        # sysfs file for high threshold value if supported for this sensor
+        if sensor_high_suffix:
+            self.thermal_high_threshold_file = self.SENSOR_DIR \
+                + "temp{}_{}".format(sensor_index, sensor_high_suffix)
+        else:
+            self.thermal_high_threshold_file = None
+
+        # sysfs file for crit high threshold value if supported for this sensor
+        if sensor_high_crit_suffix:
+            self.thermal_high_crit_threshold_file = self.SENSOR_DIR \
+                + "temp{}_{}".format(sensor_index, sensor_high_crit_suffix)
+        else:
+            self.thermal_high_crit_threshold_file = None
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # sysfs_file and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def get_name(self):
+        """
+        Retrieves the name of the thermal
+
+        Returns:
+            string: The name of the thermal
+        """
+        return self.THERMAL_NAME[self.index - 1]
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the thermal
+
+        Returns:
+            bool: True if thermal is present, False if not
+        """
+        if self.dependency:
+            return self.dependency.get_presence()
+        else:
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the Thermal
+
+        Returns:
+            string: Model/part number of Thermal
+        """
+        return 'NA'
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the Thermal
+
+        Returns:
+            string: Serial number of Thermal
+        """
+        return 'NA'
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the thermal
+
+        Returns:
+            A boolean value, True if thermal is operating properly,
+            False if not
+        """
+        if self.dependency:
+            return self.dependency.get_status()
+        else:
+            return True
+
+    def get_temperature(self):
+        """
+        Retrieves current temperature reading from thermal
+
+        Returns:
+            A float number of current temperature in Celsius up to
+            nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+        thermal_temperature = self._read_sysfs_file(
+            self.thermal_temperature_file)
+        if (thermal_temperature != 'ERR'):
+            thermal_temperature = float(thermal_temperature) / 1000
+            if self._minimum is None or self._minimum > thermal_temperature:
+                self._minimum = thermal_temperature
+            if self._maximum is None or self._maximum < thermal_temperature:
+                self._maximum = thermal_temperature
+        else:
+            thermal_temperature = 0
+
+        return float("{:.3f}".format(thermal_temperature))
+
+    def get_high_threshold(self):
+        """
+        Retrieves the high threshold temperature of thermal
+
+        Returns:
+            A float number, the high threshold temperature of thermal in
+            Celsius up to nearest thousandth of one degree Celsius,
+            e.g. 30.125
+        """
+        # Not implemented for this sensor
+        if not self.thermal_high_threshold_file:
+            raise  NotImplementedError
+
+        thermal_high_threshold = self._read_sysfs_file(
+            self.thermal_high_threshold_file)
+        if (thermal_high_threshold != 'ERR'):
+            thermal_high_threshold = float(thermal_high_threshold) / 1000
+        else:
+            thermal_high_threshold = 0.0
+
+        return float("{:.3f}".format(thermal_high_threshold))
+
+    def set_high_threshold(self, temperature):
+        """
+        Sets the high threshold temperature of thermal
+
+        Args :
+            temperature: A float number up to nearest thousandth of one
+            degree Celsius, e.g. 30.125
+        Returns:
+            A boolean, True if threshold is set successfully, False if
+            not
+        """
+        # Thermal threshold values are pre-defined based on HW.
+        return False
+
+    def get_high_critical_threshold(self):
+        """
+        Retrieves the high critical threshold temperature of thermal
+
+        Returns:
+            A float number, the high critical threshold temperature of thermal in Celsius
+            up to nearest thousandth of one degree Celsius, e.g. 30.125
+        """
+
+        # Not implemented for this sensor
+        if not self.thermal_high_crit_threshold_file:
+            raise  NotImplementedError
+
+        thermal_high_crit_threshold = self._read_sysfs_file(
+            self.thermal_high_crit_threshold_file)
+        if (thermal_high_crit_threshold != 'ERR'):
+            thermal_high_crit_threshold = float(thermal_high_crit_threshold) / 1000
+        else:
+            thermal_high_crit_threshold = 0.0
+
+        return float("{:.3f}".format(thermal_high_crit_threshold))
+
+    def get_minimum_recorded(self):
+        self.get_temperature()
+        return self._minimum
+
+    def get_maximum_recorded(self):
+        self.get_temperature()
+        return self._maximum
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+        return False
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
new file mode 100644
index 00000000000..a829fd80a5b
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
@@ -0,0 +1,192 @@
+from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+
+from sonic_py_common import logger
+
+sonic_logger = logger.Logger('thermal_actions')
+
+
+class SetFanSpeedAction(ThermalPolicyActionBase):
+    """
+    Base thermal action class to set speed for fans
+    """
+    # JSON field definition
+    JSON_FIELD_SPEED = 'speed'
+    JSON_FIELD_DEFAULT_SPEED = 'default_speed'
+    JSON_FIELD_HIGHTEMP_SPEED = 'hightemp_speed'
+
+    def __init__(self):
+        """
+        Constructor of SetFanSpeedAction
+        """
+        self.default_speed = 50
+        self.hightemp_speed = 100
+        self.speed = self.default_speed
+
+    def load_from_json(self, json_obj):
+        """
+        Construct SetFanSpeedAction via JSON. JSON example:
+            {
+                "type": "fan.all.set_speed"
+                "speed": "100"
+            }
+        :param json_obj: A JSON object representing a SetFanSpeedAction action.
+        :return:
+        """
+        if SetFanSpeedAction.JSON_FIELD_SPEED in json_obj:
+            speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
+            if speed < 0 or speed > 100:
+                raise ValueError('SetFanSpeedAction invalid speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(speed))
+            self.speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_SPEED))
+
+    @classmethod
+    def set_all_fan_speed(cls, thermal_info_dict, speed):
+        from .thermal_infos import FanInfo
+        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
+            fan_info_obj = thermal_info_dict[FanInfo.INFO_NAME]
+            for fan in fan_info_obj.get_presence_fans():
+                fan.set_speed(int(speed))
+
+
+@thermal_json_object('fan.all.set_speed')
+class SetAllFanSpeedAction(SetFanSpeedAction):
+    """
+    Action to set speed for all fans
+    """
+    def execute(self, thermal_info_dict):
+        """
+        Set speed for all fans
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        SetAllFanSpeedAction.set_all_fan_speed(thermal_info_dict, self.speed)
+
+
+@thermal_json_object('thermal.temp_check_and_set_all_fan_speed')
+class ThermalRecoverAction(SetFanSpeedAction):
+    """
+    Action to check thermal sensor temperature change status and set speed for all fans
+    """
+
+    def load_from_json(self, json_obj):
+        """
+        Construct ThermalRecoverAction via JSON. JSON example:
+            {
+                "type": "thermal.temp_check_and_set_all_fan_speed"
+                "default_speed": "50"
+                "hightemp_speed": "100"
+            }
+        :param json_obj: A JSON object representing a ThermalRecoverAction action.
+        :return:
+        """
+        if SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED in json_obj:
+            default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
+            if default_speed < 0 or default_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(default_speed))
+            self.default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED))
+
+        if SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED in json_obj:
+            hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
+            if hightemp_speed < 0 or hightemp_speed > 100:
+                raise ValueError('SetFanSpeedAction invalid hightemp speed value {} in JSON policy file, valid value should be [0, 100]'.
+                                 format(hightemp_speed))
+            self.hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
+        else:
+            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
+                             format(SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED))
+
+        sonic_logger.log_warning("ThermalRecoverAction: default: {}, hightemp: {}".format(self.default_speed, self.hightemp_speed))
+
+    def execute(self, thermal_info_dict):
+        """
+        Check check thermal sensor temperature change status and set speed for all fans
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        from .thermal_infos import ThermalInfo
+        if ThermalInfo.INFO_NAME in thermal_info_dict and \
+           isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
+
+            thermal_info_obj = thermal_info_dict[ThermalInfo.INFO_NAME]
+            if thermal_info_obj.is_warm_up_and_over_high_threshold():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.hightemp_speed)
+            elif thermal_info_obj.is_cool_down_and_below_low_threshold():
+                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.default_speed)
+
+
+@thermal_json_object('switch.shutdown')
+class SwitchPolicyAction(ThermalPolicyActionBase):
+    """
+    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,
+    all predefined thermal action will be executed.
+    """
+    def execute(self, thermal_info_dict):
+        """
+        Take action when thermal condition matches. For example, adjust speed of fan or shut
+        down the switch.
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        sonic_logger.log_warning("Alarm for temperature critical is detected, reboot Device")
+        # import os
+        # os.system('reboot')
+
+
+@thermal_json_object('thermal_control.control')
+class ControlThermalAlgoAction(ThermalPolicyActionBase):
+    """
+    Action to control the thermal control algorithm
+    """
+    # JSON field definition
+    JSON_FIELD_STATUS = 'status'
+
+    def __init__(self):
+        self.status = True
+
+    def load_from_json(self, json_obj):
+        """
+        Construct ControlThermalAlgoAction via JSON. JSON example:
+            {
+                "type": "thermal_control.control"
+                "status": "true"
+            }
+        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.
+        :return:
+        """
+        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:
+            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()
+            if status_str == 'true':
+                self.status = True
+            elif status_str == 'false':
+                self.status = False
+            else:
+                raise ValueError('Invalid {} field value, please specify true of false'.
+                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
+        else:
+            raise ValueError('ControlThermalAlgoAction '
+                             'missing mandatory field {} in JSON policy file'.
+                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
+
+    def execute(self, thermal_info_dict):
+        """
+        Disable thermal control algorithm
+        :param thermal_info_dict: A dictionary stores all thermal information.
+        :return:
+        """
+        from .thermal_infos import ChassisInfo
+        if ChassisInfo.INFO_NAME in thermal_info_dict:
+            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]
+            chassis = chassis_info_obj.get_chassis()
+            thermal_manager = chassis.get_thermal_manager()
+            if self.status:
+                thermal_manager.start_thermal_control_algorithm()
+            else:
+                thermal_manager.stop_thermal_control_algorithm()
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
new file mode 100644
index 00000000000..4923d63d746
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
@@ -0,0 +1,81 @@
+from sonic_platform_base.sonic_thermal_control.thermal_condition_base import ThermalPolicyConditionBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+
+
+class FanCondition(ThermalPolicyConditionBase):
+    def get_fan_info(self, thermal_info_dict):
+        from .thermal_infos import FanInfo
+        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
+            return thermal_info_dict[FanInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('fan.any.absence')
+class AnyFanAbsenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_absence_fans()) > 0 if fan_info_obj else False
+
+
+@thermal_json_object('fan.all.absence')
+class AllFanAbsenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_presence_fans()) == 0 if fan_info_obj else False
+
+
+@thermal_json_object('fan.all.presence')
+class AllFanPresenceCondition(FanCondition):
+    def is_match(self, thermal_info_dict):
+        fan_info_obj = self.get_fan_info(thermal_info_dict)
+        return len(fan_info_obj.get_absence_fans()) == 0 if fan_info_obj else False
+
+
+class ThermalCondition(ThermalPolicyConditionBase):
+    def get_thermal_info(self, thermal_info_dict):
+        from .thermal_infos import ThermalInfo
+        if ThermalInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
+            return thermal_info_dict[ThermalInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('thermal.over.high_critical_threshold')
+class ThermalOverHighCriticalCondition(ThermalCondition):
+    def is_match(self, thermal_info_dict):
+        thermal_info_obj = self.get_thermal_info(thermal_info_dict)
+        if thermal_info_obj:
+            return thermal_info_obj.is_over_high_critical_threshold()
+        else:
+            return False
+
+
+class PsuCondition(ThermalPolicyConditionBase):
+    def get_psu_info(self, thermal_info_dict):
+        from .thermal_infos import PsuInfo
+        if PsuInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[PsuInfo.INFO_NAME], PsuInfo):
+            return thermal_info_dict[PsuInfo.INFO_NAME]
+        else:
+            return None
+
+
+@thermal_json_object('psu.any.absence')
+class AnyPsuAbsenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_absence_psus()) > 0 if psu_info_obj else False
+
+
+@thermal_json_object('psu.all.absence')
+class AllPsuAbsenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_presence_psus()) == 0 if psu_info_obj else False
+
+
+@thermal_json_object('psu.all.presence')
+class AllPsuPresenceCondition(PsuCondition):
+    def is_match(self, thermal_info_dict):
+        psu_info_obj = self.get_psu_info(thermal_info_dict)
+        return len(psu_info_obj.get_absence_psus()) == 0 if psu_info_obj else False
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
new file mode 100644
index 00000000000..cd0a0591cd2
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
@@ -0,0 +1,210 @@
+from sonic_platform_base.sonic_thermal_control.thermal_info_base import ThermalPolicyInfoBase
+from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
+
+
+@thermal_json_object('fan_info')
+class FanInfo(ThermalPolicyInfoBase):
+    """
+    Fan information needed by thermal policy
+    """
+
+    # Fan information name
+    INFO_NAME = 'fan_info'
+
+    def __init__(self):
+        self._absence_fans = set()
+        self._presence_fans = set()
+        self._status_changed = False
+
+    def collect(self, chassis):
+        """
+        Collect absence and presence fans.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._status_changed = False
+        for fan in chassis.get_all_fans():
+            if fan.get_presence() and fan not in self._presence_fans:
+                self._presence_fans.add(fan)
+                self._status_changed = True
+                if fan in self._absence_fans:
+                    self._absence_fans.remove(fan)
+            elif not fan.get_presence() and fan not in self._absence_fans:
+                self._absence_fans.add(fan)
+                self._status_changed = True
+                if fan in self._presence_fans:
+                    self._presence_fans.remove(fan)
+
+    def get_absence_fans(self):
+        """
+        Retrieves absence fans
+        :return: A set of absence fans
+        """
+        return self._absence_fans
+
+    def get_presence_fans(self):
+        """
+        Retrieves presence fans
+        :return: A set of presence fans
+        """
+        return self._presence_fans
+
+    def is_status_changed(self):
+        """
+        Retrieves if the status of fan information changed
+        :return: True if status changed else False
+        """
+        return self._status_changed
+
+
+@thermal_json_object('thermal_info')
+class ThermalInfo(ThermalPolicyInfoBase):
+    """
+    Thermal information needed by thermal policy
+    """
+
+    # Fan information name
+    INFO_NAME = 'thermal_info'
+
+    def __init__(self):
+        self.init = False
+        self._old_avg_temp = 0
+        self._current_avg_temp = 0
+        self._high_crital_threshold = 75
+        self._high_threshold = 45
+        self._low_threshold = 40
+
+    def collect(self, chassis):
+        """
+        Collect thermal sensor temperature change status
+        :param chassis: The chassis object
+        :return:
+        """
+        self._temps = []
+        self._over_high_critical_threshold = False
+        self._warm_up_and_over_high_threshold = False
+        self._cool_down_and_below_low_threshold = False
+
+        # Calculate average temp within the device
+        temp = 0
+        num_of_thermals = chassis.get_num_thermals()
+        for index in range(num_of_thermals):
+            self._temps.insert(index, chassis.get_thermal(index).get_temperature())
+            temp += self._temps[index]
+
+        self._current_avg_temp = temp / num_of_thermals
+
+        # Special case if first time
+        if self.init is False:
+            self._old_avg_temp = self._current_avg_temp
+            self.init = True
+
+        # Check if new average temp exceeds high threshold value
+        if self._current_avg_temp >= self._old_avg_temp and self._current_avg_temp >= self._high_threshold:
+            self._warm_up_and_over_high_threshold = True
+
+        # Check if new average temp exceeds low threshold value
+        if self._current_avg_temp <= self._old_avg_temp and self._current_avg_temp <= self._low_threshold:
+            self._cool_down_and_below_low_threshold = True
+
+        self._old_avg_temp = self._current_avg_temp
+
+    def is_warm_up_and_over_high_threshold(self):
+        """
+        Retrieves if the temperature is warm up and over high threshold
+        :return: True if the temperature is warm up and over high threshold else False
+        """
+        return self._warm_up_and_over_high_threshold
+
+    def is_cool_down_and_below_low_threshold(self):
+        """
+        Retrieves if the temperature is cold down and below low threshold
+        :return: True if the temperature is cold down and below low threshold else False
+        """
+        return self._cool_down_and_below_low_threshold
+
+    def is_over_high_critical_threshold(self):
+        """
+        Retrieves if the temperature is over high critical threshold
+        :return: True if the temperature is over high critical threshold else False
+        """
+        return self._over_high_critical_threshold
+
+
+@thermal_json_object('psu_info')
+class PsuInfo(ThermalPolicyInfoBase):
+    """
+    PSU information needed by thermal policy
+    """
+    INFO_NAME = 'psu_info'
+
+    def __init__(self):
+        self._absence_psus = set()
+        self._presence_psus = set()
+        self._status_changed = False
+
+    def collect(self, chassis):
+        """
+        Collect absence and presence PSUs.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._status_changed = False
+        for psu in chassis.get_all_psus():
+            if psu.get_presence() and psu.get_powergood_status() and psu not in self._presence_psus:
+                self._presence_psus.add(psu)
+                self._status_changed = True
+                if psu in self._absence_psus:
+                    self._absence_psus.remove(psu)
+            elif (not psu.get_presence() or not psu.get_powergood_status()) and psu not in self._absence_psus:
+                self._absence_psus.add(psu)
+                self._status_changed = True
+                if psu in self._presence_psus:
+                    self._presence_psus.remove(psu)
+
+    def get_absence_psus(self):
+        """
+        Retrieves presence PSUs
+        :return: A set of absence PSUs
+        """
+        return self._absence_psus
+
+    def get_presence_psus(self):
+        """
+        Retrieves presence PSUs
+        :return: A set of presence fans
+        """
+        return self._presence_psus
+
+    def is_status_changed(self):
+        """
+        Retrieves if the status of PSU information changed
+        :return: True if status changed else False
+        """
+        return self._status_changed
+
+
+@thermal_json_object('chassis_info')
+class ChassisInfo(ThermalPolicyInfoBase):
+    """
+    Chassis information needed by thermal policy
+    """
+    INFO_NAME = 'chassis_info'
+
+    def __init__(self):
+        self._chassis = None
+
+    def collect(self, chassis):
+        """
+        Collect platform chassis.
+        :param chassis: The chassis object
+        :return:
+        """
+        self._chassis = chassis
+
+    def get_chassis(self):
+        """
+        Retrieves platform chassis object
+        :return: A platform chassis object.
+        """
+        return self._chassis
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
new file mode 100644
index 00000000000..967cf175934
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
@@ -0,0 +1,49 @@
+from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase
+from .thermal_actions import *
+from .thermal_conditions import *
+from .thermal_infos import *
+
+
+class ThermalManager(ThermalManagerBase):
+    THERMAL_ALGORITHM_CONTROL_PATH = '/var/run/hw-management/config/suspend'
+
+    @classmethod
+    def start_thermal_control_algorithm(cls):
+        """
+        Start thermal control algorithm
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        cls._control_thermal_control_algorithm(False)
+
+    @classmethod
+    def stop_thermal_control_algorithm(cls):
+        """
+        Stop thermal control algorithm
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        cls._control_thermal_control_algorithm(True)
+
+    @classmethod
+    def _control_thermal_control_algorithm(cls, suspend):
+        """
+        Control thermal control algorithm
+
+        Args:
+            suspend: Bool, indicate suspend the algorithm or not
+
+        Returns:
+            bool: True if set success, False if fail.
+        """
+        status = True
+        write_value = 1 if suspend else 0
+        try:
+            with open(cls.THERMAL_ALGORITHM_CONTROL_PATH, 'w') as control_file:
+                control_file.write(str(write_value))
+        except (ValueError, IOError):
+            status = False
+
+        return status
diff --git a/platform/marvell/sonic-platform-nokia/7215/sonic_platform/watchdog.py b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/watchdog.py
new file mode 100644
index 00000000000..03a8d9ecb4e
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/7215/sonic_platform/watchdog.py
@@ -0,0 +1,209 @@
+"""
+ARMADA 38x Watchdog - one 32 bit cpu watchdog per cpu - 2 watchdogs ( page 662)
+
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+import time
+from sonic_platform_base.watchdog_base import WatchdogBase
+
+""" ioctl constants """
+IO_WRITE = 0x40000000
+IO_READ = 0x80000000
+IO_READ_WRITE = 0xC0000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_SETTIMEOUT = 6 | WDWR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+WDIOC_SETPRETIMEOUT = 8 | WDWR_INT
+WDIOC_GETPRETIMEOUT = 9 | WDR_INT
+WDIOC_GETTIMELEFT = 10 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/watchdog0/"
+
+WD_COMMON_ERROR = -1
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+        super(WatchdogImplBase, self).__init__()
+        
+        self.watchdog=""
+        self.watchdog_path = wd_device_path
+        self.wd_state_reg = WD_SYSFS_PATH+"state"
+        self.wd_timeout_reg = WD_SYSFS_PATH+"timeout"
+        self.wd_timeleft_reg = WD_SYSFS_PATH+"timeleft"
+    
+        self.timeout = self._gettimeout()
+
+    def _read_sysfs_file(self, sysfs_file):
+        # On successful read, returns the value read from given
+        # reg_name and on failure returns 'ERR'
+        rv = 'ERR'
+
+        if (not os.path.isfile(sysfs_file)):
+            return rv
+        try:
+            with open(sysfs_file, 'r') as fd:
+                rv = fd.read()
+        except Exception as e:
+            rv = 'ERR'
+
+        rv = rv.rstrip('\r\n')
+        rv = rv.lstrip(" ")
+        return rv
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
+
+    def _settimeout(self, seconds):
+        """
+        Set watchdog timer timeout
+        @param seconds - timeout in seconds
+        @return is the actual set timeout
+        """
+
+        req = array.array('I', [seconds])
+        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+        timeout=0
+        timeout=self._read_sysfs_file(self.wd_timeout_reg)
+
+        return timeout
+
+    def _gettimeleft(self):
+        """
+        Get time left before watchdog timer expires
+        @return time left in seconds
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Arm the hardware watchdog
+        """
+
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+        
+        # Stop the watchdog service to gain access of watchdog file pointer
+        if self.is_armed():
+            os.popen("systemctl stop cpu_wdt.service")
+            time.sleep(2)
+        if not self.watchdog:
+            self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.is_armed():
+                self._keepalive()
+            else:
+                self._enablewatchdog()
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        
+        if self.is_armed():
+            os.popen("systemctl stop cpu_wdt.service")
+            time.sleep(2)
+            if not self.watchdog:
+                self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+            try:
+                self._disablewatchdog()
+                self.timeout = 0
+            except IOError:
+                return False
+
+        return True
+
+    def is_armed(self):
+        """
+        Implements is_armed WatchdogBase API
+        """
+        status = False
+
+        state = self._read_sysfs_file(self.wd_state_reg)
+        if (state != 'inactive'):
+            status = True
+
+        return status
+
+    def get_remaining_time(self):
+        """
+        Implements get_remaining_time WatchdogBase API
+        """
+
+        timeleft = WD_COMMON_ERROR
+
+        if self.is_armed():
+            timeleft=self._read_sysfs_file(self.wd_timeleft_reg)
+
+        return int(timeleft)
diff --git a/platform/marvell/sonic-platform-nokia/debian/changelog b/platform/marvell/sonic-platform-nokia/debian/changelog
new file mode 100755
index 00000000000..a369a030e40
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/changelog
@@ -0,0 +1,5 @@
+sonic-platform-nokia (1.0) unstable; urgency=low
+
+  * Add support for nokia-7215.
+
+ -- Nokia <pavan.prakash@nokia.com>  Fri, 20 Jan 2023 09:35:58 +0800
diff --git a/platform/marvell/sonic-platform-nokia/debian/compat b/platform/marvell/sonic-platform-nokia/debian/compat
new file mode 100644
index 00000000000..ec635144f60
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell/sonic-platform-nokia/debian/control b/platform/marvell/sonic-platform-nokia/debian/control
new file mode 100755
index 00000000000..3bdaa197367
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/control
@@ -0,0 +1,20 @@
+Source: sonic-platform-nokia
+Section: unknown
+Priority: optional
+Maintainer: Nokia <pavan.prakash@nokia.com>
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-nokia-7215-a1
+Architecture: any
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
+
+Package: sonic-platform-nokia-7215
+Architecture: any
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
+
diff --git a/platform/marvell/sonic-platform-nokia/debian/rules b/platform/marvell/sonic-platform-nokia/debian/rules
new file mode 100755
index 00000000000..f3fe01d1b5a
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/rules
@@ -0,0 +1,106 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-nokia
+ifneq ($(CROSS_BUILD_ENVIRON), y)
+KVERSION   ?= $(shell uname -r)
+endif
+KERNEL_SRC :=  /lib/modules/$(KVERSION)
+INSTALL_MOD_DIR := kernel/extra/
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= 7215 7215-a1
+UTILS_DIR := utils
+MODULE_DIR:= modules
+MRVL_MODULE_DIR:= mrvl-modules
+PRESTERA_MODULE_PREFIX := mrvl-prestera/drivers/generic/
+PRESTERA_MODULE_PREFIX_ARMHF := mrvl-prestera/drivers/armhf/
+PRESTERA_MODULE_SRC := /cpssEnabler/linuxNoKernelModule/drivers/
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+	(for mod in $(MODULE_DIRS); do \
+		cd $(MOD_SRC_DIR)/$${mod}; \
+		rm -rf build/; \
+		rm -rf $(MRVL_MODULE_DIR)/; \
+		rm -rf *.egg-info/; \
+		rm -f *.whl; \
+		cd $(MOD_SRC_DIR)/; \
+	done)
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		mkdir -p $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR); \
+		if [ $$mod = "7215-a1" ] && [ $(CONFIGURED_ARCH) = "arm64" ]; then \
+			cp -r $(MOD_SRC_DIR)/../$(PRESTERA_MODULE_PREFIX)/* $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/; \
+			cd $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/$(PRESTERA_MODULE_SRC); \
+			make clean; \
+			make modules -C $(KERNEL_SRC)/build M=`pwd` CONFIG_KM_MVPCI=y CONFIG_KM_MVINT=y || exit 1; \
+			cd $(MOD_SRC_DIR); \
+			make modules -C $(KERNEL_SRC)/build M=$(MOD_SRC_DIR)/$${mod}/modules || exit 1; \
+		elif [ $$mod = "7215" ] && [ $(CONFIGURED_ARCH) = "armhf" ]; then \
+			cp -r $(MOD_SRC_DIR)/../$(PRESTERA_MODULE_PREFIX_ARMHF)/* $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/; \
+			cd $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/$(PRESTERA_MODULE_SRC); \
+			make clean; \
+			make modules -C $(KERNEL_SRC)/build M=`pwd` CONFIG_KM_MVPCI=y CONFIG_KM_MVDMA=y CONFIG_KM_MVINT=y || exit 1; \
+		fi; \
+		cd $(MOD_SRC_DIR)/$${mod}; \
+		python3 setup.py build; \
+		python3 setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+		cd $(MOD_SRC_DIR); \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /boot; \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /lib/systemd/system; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/$(PRESTERA_MODULE_SRC)/mvcpss.ko debian/$(PACKAGE_PRE_NAME)-$${mod}/$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
+		cp $(MOD_SRC_DIR)/$${mod}/$(MODULE_DIR)/*.ko debian/$(PACKAGE_PRE_NAME)-$${mod}/$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
+		cd $(MOD_SRC_DIR)/$${mod}; \
+		python3 setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		cd $(MOD_SRC_DIR); \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.install b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.install
new file mode 100644
index 00000000000..dc35c1385b1
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.install
@@ -0,0 +1,6 @@
+7215-a1/scripts/nokia-7215-init.sh usr/local/bin
+7215-a1/scripts/cpu_wdt.py  usr/local/bin
+7215-a1/service/nokia-7215init.service  etc/systemd/system
+7215-a1/service/cpu_wdt.service  etc/systemd/system
+7215-a1/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-nokia_ixs7215_52xb-r0
+../mrvl-prestera/platform/arm64/ac5x/* /
diff --git a/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.postinst b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.postinst
new file mode 100644
index 00000000000..949cd1a289e
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215-a1.postinst
@@ -0,0 +1,48 @@
+#!/bin/sh
+# postinst script for sonic-platform-nokia-7215
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postinst> `configure' <most-recently-configured-version>
+#        * <old-postinst> `abort-upgrade' <new version>
+#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
+#          <new-version>
+#        * <postinst> `abort-remove'
+#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
+#          <failed-install-package> <version> `removing'
+#          <conflicting-package> <version>
+# for details, see https://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    configure)
+        chmod a+x /usr/local/bin/nokia-7215-init.sh
+        depmod -a
+        systemctl restart kmod
+        systemctl enable nokia-7215init.service
+        systemctl start nokia-7215init.service
+
+        systemctl enable cpu_wdt.service
+        systemctl start cpu_wdt.service
+
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
diff --git a/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
new file mode 100644
index 00000000000..187c1ee4dd7
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
@@ -0,0 +1,8 @@
+7215/scripts/nokia-7215_plt_setup.sh usr/sbin
+7215/scripts/nokia-7215init.sh  usr/local/bin
+7215/scripts/cpu_wdt.py  usr/local/bin
+7215/service/nokia-7215init.service  etc/systemd/system
+7215/service/cpu_wdt.service  etc/systemd/system
+7215/service/fstrim.timer/timer-override.conf  /lib/systemd/system/fstrim.timer.d
+7215/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/armhf-nokia_ixs7215_52x-r0
+7215/scripts/inband_mgmt.sh etc/
diff --git a/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
new file mode 100644
index 00000000000..9dfcc91de04
--- /dev/null
+++ b/platform/marvell/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
@@ -0,0 +1,16 @@
+#!/bin/sh
+# postinst script for sonic-platform-nokia-7215
+#
+# see: dh_installdeb(1)
+
+sh /usr/sbin/nokia-7215_plt_setup.sh
+depmod -a
+systemctl restart kmod
+systemctl enable nokia-7215init.service
+systemctl start nokia-7215init.service
+
+systemctl enable cpu_wdt.service
+systemctl start cpu_wdt.service
+
+exit 0
+

From a813b70c036b0309d58fbe7585fad86585189e2d Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 05:58:53 +0000
Subject: [PATCH 03/10] Change marvell platform makefile to support all arch

Combine all the architecture targets in makefiles.
Added CONFIGURED_ARCH check to build for specific architecture.
Updated sai deb which matches latest SAI commit.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 platform/marvell/docker-saiserver-mrvl.dep    |   8 +
 platform/marvell/docker-saiserver-mrvl.mk     |  15 ++
 platform/marvell/docker-syncd-mrvl-rpc.dep    |   8 +
 platform/marvell/docker-syncd-mrvl-rpc.mk     |   3 +
 .../docker-syncd-mrvl-rpc/99-syncd.conf       |   1 -
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |  11 +-
 platform/marvell/docker-syncd-mrvl.dep        |  10 ++
 platform/marvell/docker-syncd-mrvl.mk         |   5 +-
 .../marvell/docker-syncd-mrvl/Dockerfile.j2   |  12 +-
 .../docker-syncd-mrvl/supervisord.conf        |   2 +-
 platform/marvell/libsaithrift-dev.dep         |  11 ++
 platform/marvell/libsaithrift-dev.mk          |  10 +-
 platform/marvell/mrvl-prestera.dep            |   9 ++
 platform/marvell/mrvl-prestera.mk             |   7 +
 platform/marvell/one-image.dep                |   1 +
 platform/marvell/one-image.mk                 |  13 ++
 platform/marvell/platform-marvell.dep         |   9 ++
 platform/marvell/platform-marvell.mk          |  18 +++
 platform/marvell/platform-nokia.dep           |   8 +
 platform/marvell/platform-nokia.mk            |  30 ++++
 platform/marvell/rules.dep                    |  11 ++
 platform/marvell/rules.mk                     |  10 +-
 platform/marvell/sai.dep                      |   6 +
 platform/marvell/sai.mk                       |  18 ++-
 platform/marvell/sai/Makefile                 |   9 --
 platform/marvell/sonic_fit.its                | 151 ++++++++++++++++++
 26 files changed, 363 insertions(+), 33 deletions(-)
 create mode 100644 platform/marvell/docker-saiserver-mrvl.dep
 create mode 100644 platform/marvell/docker-saiserver-mrvl.mk
 create mode 100644 platform/marvell/docker-syncd-mrvl-rpc.dep
 create mode 100644 platform/marvell/docker-syncd-mrvl.dep
 create mode 100644 platform/marvell/libsaithrift-dev.dep
 create mode 100644 platform/marvell/mrvl-prestera.dep
 create mode 100644 platform/marvell/mrvl-prestera.mk
 create mode 100644 platform/marvell/one-image.dep
 create mode 100644 platform/marvell/platform-marvell.dep
 create mode 100644 platform/marvell/platform-marvell.mk
 create mode 100644 platform/marvell/platform-nokia.dep
 create mode 100644 platform/marvell/platform-nokia.mk
 create mode 100644 platform/marvell/rules.dep
 create mode 100644 platform/marvell/sai.dep
 delete mode 100644 platform/marvell/sai/Makefile
 create mode 100644 platform/marvell/sonic_fit.its

diff --git a/platform/marvell/docker-saiserver-mrvl.dep b/platform/marvell/docker-saiserver-mrvl.dep
new file mode 100644
index 00000000000..3ded7bc916e
--- /dev/null
+++ b/platform/marvell/docker-saiserver-mrvl.dep
@@ -0,0 +1,8 @@
+DPATH       := $($(DOCKER_SAISERVER_MRVL)_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-saiserver-mrvl.mk $(PLATFORM_PATH)/docker-saiserver-mrvl.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+DEP_FILES   += $(shell git ls-files $(DPATH))
+
+$(DOCKER_SAISERVER_MRVL)_CACHE_MODE  := GIT_CONTENT_SHA
+$(DOCKER_SAISERVER_MRVL)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(DOCKER_SAISERVER_MRVL)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell/docker-saiserver-mrvl.mk b/platform/marvell/docker-saiserver-mrvl.mk
new file mode 100644
index 00000000000..7e5c83ffc34
--- /dev/null
+++ b/platform/marvell/docker-saiserver-mrvl.mk
@@ -0,0 +1,15 @@
+# docker image for mrvl saiserver
+
+DOCKER_SAISERVER_MRVL = docker-saiserver-mrvl.gz
+$(DOCKER_SAISERVER_MRVL)_PATH = $(PLATFORM_PATH)/docker-saiserver-mrvl
+$(DOCKER_SAISERVER_MRVL)_DEPENDS += $(SAISERVER)
+$(DOCKER_SAISERVER_MRVL)_LOAD_DOCKERS += $(DOCKER_CONFIG_ENGINE_BULLSEYE)
+SONIC_DOCKER_IMAGES += $(DOCKER_SAISERVER_MRVL)
+SONIC_BULLSEYE_DOCKERS += $(DOCKER_SAISERVER_MRVL)
+
+$(DOCKER_SAISERVER_MRVL)_CONTAINER_NAME = saiserver
+$(DOCKER_SAISERVER_MRVL)_RUN_OPT += --privileged -t
+$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
+$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /var/run/docker-saiserver:/var/run/sswsyncd
+$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
+$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell/docker-syncd-mrvl-rpc.dep b/platform/marvell/docker-syncd-mrvl-rpc.dep
new file mode 100644
index 00000000000..3ab0dec8eb5
--- /dev/null
+++ b/platform/marvell/docker-syncd-mrvl-rpc.dep
@@ -0,0 +1,8 @@
+DPATH       := $($(DOCKER_SYNCD_MRVL_RPC)_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+DEP_FILES   += $(shell git ls-files $(DPATH))
+
+$(DOCKER_SYNCD_MRVL_RPC)_CACHE_MODE  := GIT_CONTENT_SHA
+$(DOCKER_SYNCD_MRVL_RPC)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(DOCKER_SYNCD_MRVL_RPC)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell/docker-syncd-mrvl-rpc.mk b/platform/marvell/docker-syncd-mrvl-rpc.mk
index 20698efdf9e..d642f4da4d9 100644
--- a/platform/marvell/docker-syncd-mrvl-rpc.mk
+++ b/platform/marvell/docker-syncd-mrvl-rpc.mk
@@ -19,7 +19,10 @@ endif
 $(DOCKER_SYNCD_MRVL_RPC)_CONTAINER_NAME = syncd
 $(DOCKER_SYNCD_MRVL_RPC)_VERSION = 1.0.0+rpc
 $(DOCKER_SYNCD_MRVL_RPC)_PACKAGE_NAME = syncd
+$(DOCKER_SYNCD_MRVL_RPC)_MACHINE = marvell
 $(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += --privileged -t
 $(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
 $(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
 $(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/warmboot:/var/warmboot
+
+SONIC_BULLSEYE_DOCKERS += $(DOCKER_SYNCD_MRVL_RPC)
diff --git a/platform/marvell/docker-syncd-mrvl-rpc/99-syncd.conf b/platform/marvell/docker-syncd-mrvl-rpc/99-syncd.conf
index f3b57e3b196..3fabe208d81 100644
--- a/platform/marvell/docker-syncd-mrvl-rpc/99-syncd.conf
+++ b/platform/marvell/docker-syncd-mrvl-rpc/99-syncd.conf
@@ -1,2 +1 @@
 sysctl -w net.core.rmem_max=509430500
-
diff --git a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
index 68670343bf3..6bd7fb9c7f6 100644
--- a/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -15,7 +15,8 @@ RUN apt-get purge -y syncd
 RUN apt-get update \
  && apt-get -y install  \
     net-tools           \
-    python-pip          \
+    python3-pip		\
+    python3-setuptools	\
     build-essential     \
     libssl-dev          \
     libffi-dev          \
@@ -24,7 +25,7 @@ RUN apt-get update \
     cmake               \
     libqt5core5a        \
     libqt5network5      \
-    libboost-atomic1.71.0
+    libboost-atomic1.74.0
 
 RUN dpkg_apt() { [ -f $1 ] && { dpkg -i $1 || apt-get -y install -f; } || return 1; } ; \
 {% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
@@ -41,9 +42,9 @@ RUN wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && cd ..               \
  && rm -fr nanomsg-1.0.0 \
  && rm -f 1.0.0.tar.gz  \
- && pip install cffi==1.7.0    \
- && pip install --upgrade cffi==1.7.0 \
- && pip install nnpy    \
+ && pip3 install cffi==1.7.0    \
+ && pip3 install --upgrade cffi==1.7.0 \
+ && pip3 install nnpy    \
  && mkdir -p /opt       \
  && cd /opt             \
  && wget https://raw.githubusercontent.com/p4lang/ptf/master/ptf_nn/ptf_nn_agent.py \
diff --git a/platform/marvell/docker-syncd-mrvl.dep b/platform/marvell/docker-syncd-mrvl.dep
new file mode 100644
index 00000000000..d3f213a2da8
--- /dev/null
+++ b/platform/marvell/docker-syncd-mrvl.dep
@@ -0,0 +1,10 @@
+DPATH       := $($(DOCKER_SYNCD_BASE)_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-syncd-mrvl.mk $(PLATFORM_PATH)/docker-syncd-mrvl.dep $(PLATFORM_PATH)/sai.mk
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+DEP_FILES   += $(shell git ls-files $(DPATH))
+
+$(DOCKER_SYNCD_BASE)_CACHE_MODE  := GIT_CONTENT_SHA
+$(DOCKER_SYNCD_BASE)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(DOCKER_SYNCD_BASE)_DEP_FILES   := $(DEP_FILES)
+
+$(eval $(call add_dbg_docker,$(DOCKER_SYNCD_BASE),$(DOCKER_SYNCD_BASE_DBG)))
diff --git a/platform/marvell/docker-syncd-mrvl.mk b/platform/marvell/docker-syncd-mrvl.mk
index d8a2050901f..566de773b33 100644
--- a/platform/marvell/docker-syncd-mrvl.mk
+++ b/platform/marvell/docker-syncd-mrvl.mk
@@ -1,9 +1,10 @@
 # docker image for mrvl syncd
 
 DOCKER_SYNCD_PLATFORM_CODE = mrvl
-include $(PLATFORM_PATH)/../template/docker-syncd-base.mk
+include $(PLATFORM_PATH)/../template/docker-syncd-bullseye.mk
 
 $(DOCKER_SYNCD_BASE)_DEPENDS += $(SYNCD)
+$(DOCKER_SYNCD_BASE)_DEPENDS += $(MRVL_SAI)
 
 $(DOCKER_SYNCD_BASE)_DBG_DEPENDS += $(SYNCD_DBG) \
                                 $(LIBSWSSCOMMON_DBG) \
@@ -12,6 +13,6 @@ $(DOCKER_SYNCD_BASE)_DBG_DEPENDS += $(SYNCD_DBG) \
 
 $(DOCKER_SYNCD_BASE)_VERSION = 1.0.0
 $(DOCKER_SYNCD_BASE)_PACKAGE_NAME = syncd
+$(DOCKER_SYNCD_BASE)_MACHINE = marvell
 
 $(DOCKER_SYNCD_BASE)_RUN_OPT += -v /host/warmboot:/var/warmboot
-$(DOCKER_SYNCD_BASE)_RUN_OPT += -v /var/run/docker-syncd:/var/run/sswsyncd
diff --git a/platform/marvell/docker-syncd-mrvl/Dockerfile.j2 b/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
index 4de6df31383..84e3d5bde2f 100755
--- a/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
+++ b/platform/marvell/docker-syncd-mrvl/Dockerfile.j2
@@ -1,5 +1,5 @@
 {% from "dockers/dockerfile-macros.j2" import install_debian_packages %}
-FROM docker-config-engine-buster-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
+FROM docker-config-engine-bullseye-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
 
 ARG docker_container_name
 
@@ -14,16 +14,20 @@ debs/{{ deb }}{{' '}}
 {%- endfor -%}
 debs/
 
-RUN apt-get -y install libpcap-dev libxml2-dev python-dev swig libsensors4-dev libatomic1 liblua5.1-0 lua-bitop lua-cjson nfs-common
+RUN apt-get update \
+ && apt-get -y install  \
+    net-tools           \
+    iputils-ping
+
+RUN apt-get -y install libpcap-dev libxml2-dev python-dev swig libsensors4-dev nfs-common
 
 RUN dpkg -i \
 {% for deb in docker_syncd_mrvl_debs.split(' ') -%}
 debs/{{ deb }}{{' '}}
 {%- endfor %}
 
-COPY ["syncd.sh", "/usr/bin/"]
 COPY ["supervisord.conf", "/etc/supervisor/conf.d/"]
-COPY ["files/supervisor-proc-exit-listener", "/usr/bin"]
+COPY ["files/supervisor-proc-exit-listener", "/usr/bin/"]
 COPY ["critical_processes", "/etc/supervisor/"]
 
 ## Clean up
diff --git a/platform/marvell/docker-syncd-mrvl/supervisord.conf b/platform/marvell/docker-syncd-mrvl/supervisord.conf
index 3829f6a81fd..62a28387248 100644
--- a/platform/marvell/docker-syncd-mrvl/supervisord.conf
+++ b/platform/marvell/docker-syncd-mrvl/supervisord.conf
@@ -23,7 +23,7 @@ buffer_size=1024
 command=/usr/sbin/rsyslogd -n -iNONE
 priority=1
 autostart=false
-autorestart=unexpected
+autorestart=false
 stdout_logfile=syslog
 stderr_logfile=syslog
 dependent_startup=true
diff --git a/platform/marvell/libsaithrift-dev.dep b/platform/marvell/libsaithrift-dev.dep
new file mode 100644
index 00000000000..d7d08f14a31
--- /dev/null
+++ b/platform/marvell/libsaithrift-dev.dep
@@ -0,0 +1,11 @@
+SPATH       := $($(LIBSAITHRIFT_DEV)_SRC_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/libsaithrift-dev.mk $(PLATFORM_PATH)/libsaithrift-dev.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+SMDEP_PATHS := $(SPATH)  $(SPATH)/bm/behavioral-model  $(SPATH)/test/ptf  $(SPATH)/test/saithrift/ctypesgen
+$(foreach path, $(SMDEP_PATHS), $(eval $(path) :=$(filter-out $(SMDEP_PATHS),$(addprefix $(path)/, $(shell cd $(path) &&  git ls-files | grep -Ev " " )))))
+
+$(LIBSAITHRIFT_DEV)_CACHE_MODE  := GIT_CONTENT_SHA
+$(LIBSAITHRIFT_DEV)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(LIBSAITHRIFT_DEV)_DEP_FILES   := $(DEP_FILES)
+$(LIBSAITHRIFT_DEV)_SMDEP_FILES := $(foreach path, $(SMDEP_PATHS), $($(path)))
+$(LIBSAITHRIFT_DEV)_SMDEP_PATHS := $(SMDEP_PATHS)
diff --git a/platform/marvell/libsaithrift-dev.mk b/platform/marvell/libsaithrift-dev.mk
index dd178c0b130..e1c3da156ec 100644
--- a/platform/marvell/libsaithrift-dev.mk
+++ b/platform/marvell/libsaithrift-dev.mk
@@ -2,19 +2,19 @@
 
 SAI_VER = 0.9.4
 
-LIBSAITHRIFT_DEV = libsaithrift-dev_$(SAI_VER)_amd64.deb
+LIBSAITHRIFT_DEV = libsaithrift-dev_$(SAI_VER)_$(CONFIGURED_ARCH).deb
 $(LIBSAITHRIFT_DEV)_SRC_PATH = $(SRC_PATH)/sonic-sairedis/SAI
 $(LIBSAITHRIFT_DEV)_DEPENDS += $(LIBTHRIFT) $(LIBTHRIFT_DEV) $(PYTHON_THRIFT) $(THRIFT_COMPILER) $(MRVL_FPA) $(MRVL_SAI)
 $(LIBSAITHRIFT_DEV)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
 SONIC_DPKG_DEBS += $(LIBSAITHRIFT_DEV)
 
-PYTHON_SAITHRIFT = python-saithrift_$(SAI_VER)_amd64.deb
+PYTHON_SAITHRIFT = python-saithrift_$(SAI_VER)_$(CONFIGURED_ARCH).deb
 $(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(PYTHON_SAITHRIFT)))
 
-SAISERVER = saiserver_$(SAI_VER)_amd64.deb
-$(SAISERVER)_RDEPENDS += $(LIBTHRIFT) $(BRCM_XGS_SAI)
+SAISERVER = saiserver_$(SAI_VER)_$(CONFIGURED_ARCH).deb
+$(SAISERVER)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
 $(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER)))
 
-SAISERVER_DBG = saiserver-dbg_$(SAI_VER)_amd64.deb
+SAISERVER_DBG = saiserver-dbg_$(SAI_VER)_$(CONFIGURED_ARCH).deb
 $(SAISERVER_DBG)_RDEPENDS += $(SAISERVER)
 $(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER_DBG)))
diff --git a/platform/marvell/mrvl-prestera.dep b/platform/marvell/mrvl-prestera.dep
new file mode 100644
index 00000000000..3ee32c3cbcd
--- /dev/null
+++ b/platform/marvell/mrvl-prestera.dep
@@ -0,0 +1,9 @@
+MPATH       := $($(MRVL_PRESTERA_DEB)_SRC_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/mrvl-prestera.mk $(PLATFORM_PATH)/mrvl-prestera.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+SMDEP_FILES := $(addprefix $(MPATH)/,$(shell cd $(MPATH) && git ls-files))
+
+$(MRVL_PRESTERA_DEB)_CACHE_MODE  := GIT_CONTENT_SHA
+$(MRVL_PRESTERA_DEB)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(MRVL_PRESTERA_DEB)_DEP_FILES   := $(DEP_FILES)
+$(MRVL_PRESTERA_DEB)_SMDEP_FILES := $(SMDEP_FILES)
diff --git a/platform/marvell/mrvl-prestera.mk b/platform/marvell/mrvl-prestera.mk
new file mode 100644
index 00000000000..36207041dc7
--- /dev/null
+++ b/platform/marvell/mrvl-prestera.mk
@@ -0,0 +1,7 @@
+# Marvell Prestera platform package
+export MRVL_PRESTERA_VER = 1.0
+export MRVL_PRESTERA = mrvlprestera_$(MRVL_PRESTERA_VER)_$(PLATFORM_ARCH)
+export MRVL_PRESTERA_DEB = $(MRVL_PRESTERA).deb
+
+$(MRVL_PRESTERA_DEB)_SRC_PATH = $(PLATFORM_PATH)/mrvl-prestera
+SONIC_DPKG_DEBS += $(MRVL_PRESTERA_DEB)
diff --git a/platform/marvell/one-image.dep b/platform/marvell/one-image.dep
new file mode 100644
index 00000000000..154112a82ab
--- /dev/null
+++ b/platform/marvell/one-image.dep
@@ -0,0 +1 @@
+$(SONIC_ONE_IMAGE)_CACHE_MODE  := none
diff --git a/platform/marvell/one-image.mk b/platform/marvell/one-image.mk
index fcac0385434..155662aa66e 100644
--- a/platform/marvell/one-image.mk
+++ b/platform/marvell/one-image.mk
@@ -1,9 +1,22 @@
 # sonic marvell one image installer
 
+ifeq ($(CONFIGURED_ARCH),$(filter $(CONFIGURED_ARCH),arm64 armhf))
+SONIC_ONE_IMAGE = sonic-marvell-$(CONFIGURED_ARCH).bin
+else
 SONIC_ONE_IMAGE = sonic-marvell.bin
+endif
 $(SONIC_ONE_IMAGE)_MACHINE = marvell
 $(SONIC_ONE_IMAGE)_IMAGE_TYPE = onie
 $(SONIC_ONE_IMAGE)_INSTALLS += $(SYSTEMD_SONIC_GENERATOR)
+ifeq ($(CONFIGURED_ARCH),arm64)
+$(SONIC_ONE_IMAGE)_INSTALLS += $(MRVL_PRESTERA_DEB)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(NOKIA_7215_PLATFORM) \
+				$(AC5X_RD98DX35xx_PLATFORM) \
+				$(AC5X_RD98DX35xxCN9131_PLATFORM)
+else ifeq ($(CONFIGURED_ARCH),armhf)
+$(SONIC_ONE_IMAGE)_INSTALLS += $(MRVL_PRESTERA_DEB)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(NOKIA_7215_PLATFORM)
+endif
 ifeq ($(INSTALL_DEBUG_TOOLS),y)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
diff --git a/platform/marvell/platform-marvell.dep b/platform/marvell/platform-marvell.dep
new file mode 100644
index 00000000000..f906215e3c0
--- /dev/null
+++ b/platform/marvell/platform-marvell.dep
@@ -0,0 +1,9 @@
+MPATH       := $($(AC5X_RD98DX35xx_PLATFORM)_SRC_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/platform-marvell.dep $(PLATFORM_PATH)/platform-marvell.mk
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+SMDEP_FILES := $(addprefix $(MPATH)/,$(shell cd $(MPATH) && git ls-files))
+
+$(AC5X_RD98DX35xx_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
+$(AC5X_RD98DX35xx_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(AC5X_RD98DX35xx_PLATFORM)_DEP_FILES   := $(DEP_FILES)
+$(AC5X_RD98DX35xx_PLATFORM)_SMDEP_FILES := $(SMDEP_FILES)
diff --git a/platform/marvell/platform-marvell.mk b/platform/marvell/platform-marvell.mk
new file mode 100644
index 00000000000..9dffbf5e5bf
--- /dev/null
+++ b/platform/marvell/platform-marvell.mk
@@ -0,0 +1,18 @@
+# Marvell Platform modules
+
+AC5X_RD98DX35xx_PLATFORM_MODULE_VERSION = 1.0
+AC5X_RD98DX35xxCN9131_PLATFORM_MODULE_VERSION = 1.0
+
+ifeq ($(CONFIGURED_ARCH),arm64)
+
+AC5X_RD98DX35xx_PLATFORM = sonic-platform-rd98dx35xx_$(AC5X_RD98DX35xx_PLATFORM_MODULE_VERSION)_$(CONFIGURED_ARCH).deb
+$(AC5X_RD98DX35xx_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-marvell
+$(AC5X_RD98DX35xx_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(AC5X_RD98DX35xx_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx-r0
+SONIC_DPKG_DEBS += $(AC5X_RD98DX35xx_PLATFORM)
+
+AC5X_RD98DX35xxCN9131_PLATFORM = sonic-platform-rd98dx35xx-cn9131_$(AC5X_RD98DX35xxCN9131_PLATFORM_MODULE_VERSION)_$(CONFIGURED_ARCH).deb
+$(AC5X_RD98DX35xxCN9131_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx_cn9131-r0
+$(eval $(call add_extra_package,$(AC5X_RD98DX35xx_PLATFORM),$(AC5X_RD98DX35xxCN9131_PLATFORM)))
+
+endif
diff --git a/platform/marvell/platform-nokia.dep b/platform/marvell/platform-nokia.dep
new file mode 100644
index 00000000000..603feb645eb
--- /dev/null
+++ b/platform/marvell/platform-nokia.dep
@@ -0,0 +1,8 @@
+MPATH       := $($(NOKIA_7215_PLATFORM)_SRC_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/platform-nokia.mk $(PLATFORM_PATH)/platform-nokia.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+DEP_FILES   += $(shell git ls-files $(MPATH))
+
+$(NOKIA_7215_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
+$(NOKIA_7215_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(NOKIA_7215_PLATFORM)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell/platform-nokia.mk b/platform/marvell/platform-nokia.mk
new file mode 100644
index 00000000000..f8136070861
--- /dev/null
+++ b/platform/marvell/platform-nokia.mk
@@ -0,0 +1,30 @@
+# Nokia Platform
+
+NOKIA_7215_PLATFORM_VERSION = 1.0
+export NOKIA_7215_PLATFORM_VERSION
+SONIC_KERNEL_DEB_PKG = $(LINUX_KERNEL)
+export SONIC_KERNEL_DEB_PKG
+
+ifeq ($(CONFIGURED_ARCH),arm64)
+NOKIA_7215_PLATFORM = sonic-platform-nokia-7215-a1_$(NOKIA_7215_PLATFORM_VERSION)_$(CONFIGURED_ARCH).deb
+$(NOKIA_7215_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-nokia
+$(NOKIA_7215_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(NOKIA_7215_PLATFORM)_PLATFORM = arm64-nokia_ixs7215_52xb-r0
+
+MPATH       := $($(NOKIA_7215_PLATFORM)_SRC_PATH)
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell/platform-nokia.mk
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+DEP_FILES   += $(shell git ls-files $(MPATH))
+
+$(NOKIA_7215_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
+$(NOKIA_7215_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(NOKIA_7215_PLATFORM)_DEP_FILES   := $(DEP_FILES)
+SONIC_DPKG_DEBS += $(NOKIA_7215_PLATFORM)
+
+else ifeq ($(CONFIGURED_ARCH),armhf)
+NOKIA_7215_PLATFORM = sonic-platform-nokia-7215_$(NOKIA_7215_PLATFORM_VERSION)_$(CONFIGURED_ARCH).deb
+$(NOKIA_7215_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-nokia
+$(NOKIA_7215_PLATFORM)_PLATFORM = armhf-nokia_ixs7215_52x-r0
+$(NOKIA_7215_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+SONIC_DPKG_DEBS += $(NOKIA_7215_PLATFORM)
+endif
diff --git a/platform/marvell/rules.dep b/platform/marvell/rules.dep
new file mode 100644
index 00000000000..a5bdbf59d16
--- /dev/null
+++ b/platform/marvell/rules.dep
@@ -0,0 +1,11 @@
+include $(PLATFORM_PATH)/docker-saiserver-mrvl.dep
+include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep
+include $(PLATFORM_PATH)/docker-syncd-mrvl.dep
+include $(PLATFORM_PATH)/libsaithrift-dev.dep
+include $(PLATFORM_PATH)/one-image.dep
+include $(PLATFORM_PATH)/platform-marvell.dep
+ifeq ($(CONFIGURED_ARCH),$(filter $(CONFIGURED_ARCH),arm64 armhf))
+include $(PLATFORM_PATH)/mrvl-prestera.dep
+include $(PLATFORM_PATH)/platform-nokia.dep
+endif
+include $(PLATFORM_PATH)/sai.dep
diff --git a/platform/marvell/rules.mk b/platform/marvell/rules.mk
index da23e53f26b..0b78cd088a0 100644
--- a/platform/marvell/rules.mk
+++ b/platform/marvell/rules.mk
@@ -1,15 +1,21 @@
 include $(PLATFORM_PATH)/sai.mk
 include $(PLATFORM_PATH)/docker-syncd-mrvl.mk
 include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk
+include $(PLATFORM_PATH)/docker-saiserver-mrvl.mk
 include $(PLATFORM_PATH)/libsaithrift-dev.mk
 include $(PLATFORM_PATH)/one-image.mk
+include $(PLATFORM_PATH)/platform-marvell.mk
+ifeq ($(CONFIGURED_ARCH),$(filter $(CONFIGURED_ARCH),arm64 armhf))
+include $(PLATFORM_PATH)/mrvl-prestera.mk
+include $(PLATFORM_PATH)/platform-nokia.mk
+endif
 
 SONIC_ALL += $(SONIC_ONE_IMAGE) \
-             $(DOCKER_FPM) \
+             $(DOCKER_FPM) 	\
              $(DOCKER_SYNCD_MRVL_RPC)
 
 # Inject mrvl sai into syncd
-$(SYNCD)_DEPENDS += $(MRVL_FPA) $(MRVL_SAI)
+$(SYNCD)_DEPENDS += $(MRVL_SAI)
 $(SYNCD)_UNINSTALLS += $(MRVL_SAI)
 
 ifeq ($(ENABLE_SYNCD_RPC),y)
diff --git a/platform/marvell/sai.dep b/platform/marvell/sai.dep
new file mode 100644
index 00000000000..fee88c0fa0b
--- /dev/null
+++ b/platform/marvell/sai.dep
@@ -0,0 +1,6 @@
+DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/sai.mk $(PLATFORM_PATH)/sai.dep
+DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
+
+$(MRVL_SAI)_CACHE_MODE  := GIT_CONTENT_SHA
+$(MRVL_SAI)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
+$(MRVL_SAI)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell/sai.mk b/platform/marvell/sai.mk
index 231bdfc810a..4fd89bf6cf8 100644
--- a/platform/marvell/sai.mk
+++ b/platform/marvell/sai.mk
@@ -1,9 +1,19 @@
 # Marvell SAI
 
-export MRVL_SAI_VERSION = 1.13.0-1
-export MRVL_SAI = mrvllibsai_amd64_$(MRVL_SAI_VERSION).deb
+BRANCH = master
+ifeq ($(CONFIGURED_ARCH),arm64)
+MRVL_SAI_VERSION = 1.13.0-1
+else ifeq ($(CONFIGURED_ARCH),armhf)
+MRVL_SAI_VERSION = 1.13.0-2
+else
+MRVL_SAI_VERSION = 1.13.0-1
+endif
 
-$(MRVL_SAI)_SRC_PATH = $(PLATFORM_PATH)/sai
+MRVL_SAI_URL_PREFIX = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/$(CONFIGURED_ARCH)/sai-plugin/$(BRANCH)/
+MRVL_SAI = mrvllibsai_$(MRVL_SAI_VERSION)_$(PLATFORM_ARCH).deb
+$(MRVL_SAI)_URL = $(MRVL_SAI_URL_PREFIX)/$(MRVL_SAI)
+
+SONIC_ONLINE_DEBS += $(MRVL_SAI)
+$(MRVL_SAI)_SKIP_VERSION=y
 $(eval $(call add_conflict_package,$(MRVL_SAI),$(LIBSAIVS_DEV)))
 
-SONIC_MAKE_DEBS += $(MRVL_SAI)
diff --git a/platform/marvell/sai/Makefile b/platform/marvell/sai/Makefile
deleted file mode 100644
index 1cd6d0267fa..00000000000
--- a/platform/marvell/sai/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-.ONESHELL:
-SHELL = /bin/bash
-.SHELLFLAGS += -e
-
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/amd64/sai-plugin/$(MRVL_SAI)
-
-$(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
-	# get deb package
-	wget -O $(DEST)/$(MRVL_SAI) $(MRVL_SAI_URL)
diff --git a/platform/marvell/sonic_fit.its b/platform/marvell/sonic_fit.its
new file mode 100644
index 00000000000..3208388d980
--- /dev/null
+++ b/platform/marvell/sonic_fit.its
@@ -0,0 +1,151 @@
+/dts-v1/;
+  
+/ {
+    description = "U-Boot fitImage for SONIC Marvell Arm64";
+    #address-cells = <1>;
+  
+    images {
+        kernel_ac5x {
+            description = "Linux Kernel for AC5x";
+            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
+            type = "kernel";
+            arch = "arm64";
+            os = "linux";
+            compression = "none";
+            load = <0x2 0x2080000>;
+            entry = <0x2 0x2080000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        fdt_ac5x {
+            description = "Flattened Device Tree blob for AC5x";
+            data = /incbin/("/usr/lib/linux-image-6.1.0-11-2-arm64/marvell/ac5-98dx35xx-rd.dtb");
+            type = "flat_dt";
+            arch = "arm64";
+            compression = "none";
+            load = <0x2 0x1000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        fdt_7215_a1 {
+            description = "Flattened Device Tree blob for 7215_IXS_A1";
+            data = /incbin/("/usr/lib/linux-image-6.1.0-11-2-arm64/marvell/7215-ixs-a1.dtb");
+            type = "flat_dt";
+            arch = "arm64";
+            compression = "none";
+            load = <0x11000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        ramdisk_ac5x {
+            description = "ramdisk for AC5x";
+            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
+            type = "ramdisk";
+            arch = "arm64";
+            os = "linux";
+            compression = "gzip";
+            load = <0x2 0x6000000>;
+            entry = <0x2 0x6000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        kernel_1 {
+            description = "Linux Kernel";
+            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
+            type = "kernel";
+            arch = "arm64";
+            os = "linux";
+            compression = "none";
+            load = <0x1000000>;
+            entry = <0x1000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        ramdisk_1 {
+            description = "ramdisk";
+            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
+            type = "ramdisk";
+            arch = "arm64";
+            os = "linux";
+            compression = "gzip";
+            load = <0x6000000>;
+            entry = <0x6000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        kernel_2 {
+            description = "Linux Kernel";
+            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
+            type = "kernel";
+            arch = "arm64";
+            os = "linux";
+            compression = "none";
+            load = <0x12000000>;
+            entry = <0x12000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        ramdisk_2 {
+            description = "ramdisk";
+            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
+            type = "ramdisk";
+            arch = "arm64";
+            os = "linux";
+            compression = "gzip";
+            load = <0x18000000>;
+            entry = <0x18000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        fdt_cn9131 {
+            description = "Flattened Device Tree blob";
+            data = /incbin/("/boot/cn9131-db-comexpress.dtb");
+            type = "flat_dt";
+            arch = "arm64";
+            compression = "none";
+            load = <0x0a00000>;
+            entry = <0x0a00000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+    };
+    configurations {
+        default = "conf_ac5x";
+        conf_ac5x {
+            description = "Boot Linux kernel with FDT blob + ramdisk for RD_AC5x";
+            kernel = "kernel_ac5x";
+            fdt = "fdt_ac5x";
+            ramdisk = "ramdisk_ac5x";
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        conf_7215_a1 {
+            description = "Boot Linux kernel with FDT blob + ramdisk for 7125_IXS_A1";
+            kernel = "kernel_2";
+            fdt = "fdt_7215_a1";
+            ramdisk = "ramdisk_2";
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        conf_cn9131 {
+            description = "Boot Linux kernel with FDT blob + ramdisk for CN9131";
+            kernel = "kernel_1";
+            fdt = "fdt_cn9131";
+            ramdisk = "ramdisk_1";
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+   };
+};

From 80b8b0bc0bf8fe0d26a90f7d0cfcb137a9dbe494 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 06:07:42 +0000
Subject: [PATCH 04/10] Add support for architecture specific platform.conf

Changed build_image.sh and onie-mk-demo.sh to read architecture
specific platform.conf.
Moved marvell-arm64/platform.conf to marvell/platform_arm64.conf.
Moved marvell-armhf/platform.conf to marvell/platform_armhf.conf.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 build_image.sh                       |   6 +-
 onie-mk-demo.sh                      |   2 +-
 platform/marvell/platform.conf       |   0
 platform/marvell/platform_arm64.conf | 248 ++++++++++++++++++++++
 platform/marvell/platform_armhf.conf | 303 +++++++++++++++++++++++++++
 5 files changed, 557 insertions(+), 2 deletions(-)
 delete mode 100644 platform/marvell/platform.conf
 create mode 100644 platform/marvell/platform_arm64.conf
 create mode 100644 platform/marvell/platform_armhf.conf

diff --git a/build_image.sh b/build_image.sh
index 7fafba29efd..e25a98a0027 100755
--- a/build_image.sh
+++ b/build_image.sh
@@ -82,10 +82,14 @@ generate_onie_installer_image()
         done
     done
 
+    platform_conf_file="platform/$TARGET_MACHINE/platform_${CONFIGURED_ARCH}.conf"
+    if [ ! -f $platform_conf_file ]; then
+        platform_conf_file="platform/$TARGET_MACHINE/platform.conf"
+    fi
     ## Generate an ONIE installer image
     ## Note: Don't leave blank between lines. It is single line command.
     ./onie-mk-demo.sh $CONFIGURED_ARCH $TARGET_MACHINE $TARGET_PLATFORM-$TARGET_MACHINE-$ONIEIMAGE_VERSION \
-          installer platform/$TARGET_MACHINE/platform.conf $output_file OS $IMAGE_VERSION $ONIE_IMAGE_PART_SIZE \
+          installer $platform_conf_file $output_file OS $IMAGE_VERSION $ONIE_IMAGE_PART_SIZE \
           $INSTALLER_PAYLOAD $SECURE_UPGRADE_SIGNING_CERT $SECURE_UPGRADE_DEV_SIGNING_KEY
 }
 
diff --git a/onie-mk-demo.sh b/onie-mk-demo.sh
index c197731faef..f8b0d999def 100755
--- a/onie-mk-demo.sh
+++ b/onie-mk-demo.sh
@@ -107,7 +107,7 @@ echo -n "."
 cp -r $onie_installer_payload $tmp_installdir || clean_up 1
 echo -n "."
 [ -r "$platform_conf" ] && {
-    cp $platform_conf $tmp_installdir || clean_up 1
+    cp $platform_conf $tmp_installdir/platform.conf || clean_up 1
 }
 echo "machine=$machine" > $tmp_installdir/machine.conf
 echo "platform=$platform" >> $tmp_installdir/machine.conf
diff --git a/platform/marvell/platform.conf b/platform/marvell/platform.conf
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/platform/marvell/platform_arm64.conf b/platform/marvell/platform_arm64.conf
new file mode 100644
index 00000000000..6332c9178f8
--- /dev/null
+++ b/platform/marvell/platform_arm64.conf
@@ -0,0 +1,248 @@
+#  Copyright (C) Marvell Inc
+
+# over ride default behaviour
+
+echo "Preparing for installation ... "
+
+# global defines
+VAR_LOG=512
+UBOOT_FW_DEFAULT=1
+
+kernel_addr=0x1100000
+kernel_version=6.1.0-11-2-arm64
+kernel_fname="/boot/vmlinuz-$kernel_version"
+initrd_fname="/boot/initrd.img-$kernel_version"
+fit_fname="/boot/sonic_arm64.fit"
+demo_volume_label=SONiC-OS
+
+# global mount defines
+demo_mnt=/tmp
+
+if [ "$install_env" = "onie" ]; then
+    MACH_FILE="/etc/machine.conf"
+else
+    MACH_FILE="/host/machine.conf"
+fi
+
+PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
+echo "Intalling SONiC from $install_env on Platform $PLATFORM"
+
+PLATFORM_AC5X=0
+PLATFORM_CN9131=0
+
+case $PLATFORM in
+    arm64-nokia_ixs7215_52xb-r0) PLATFORM_7215_A1=1;
+		fdt_fname="/usr/lib/linux-image-${kernel_version}/marvell/7215-ixs-a1.dtb";
+		fit_conf_name="#conf_7215_a1";;
+    arm64-marvell_rd98DX35xx-r0) PLATFORM_AC5X=1;
+		fdt_fname="/usr/lib/linux-image-$kernel_version/marvell/ac5-98dx35xx-rd.dtb";
+		fit_conf_name="#conf_ac5x";;
+    arm64-marvell_rd98DX35xx_cn9131-r0) PLATFORM_CN9131=1;
+		fdt_fname="/boot/cn9131-db-comexpress.dtb";
+		fit_conf_name="#conf_cn9131";;
+esac
+
+if [ $PLATFORM_AC5X -eq 1 ]; then
+    fdt_addr=0x201000000
+    fit_addr=0x210000000
+    initrd_addr=0x206000000
+
+    FW_ENV_DEFAULT='/dev/mtd0 0x400000 0x10000 0x10000'
+    demo_part=2
+    mmc_bus="mmc0:0001"
+elif [ $PLATFORM_7215_A1 -eq 1 ]; then
+    fit_addr=0x20000000
+    VAR_LOG=4096
+    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x10000'
+    demo_part=2
+    mmc_bus="mmc0:0001"
+elif [ $PLATFORM_CN9131 -eq 1 ]; then
+    fdt_addr=0x1000000
+    fit_addr=0x8000000
+    initrd_addr=0x2000000
+    demo_part=2
+    FW_ENV_DEFAULT='/dev/mtd1 0x1F0000 0x10000 0x10000'
+    mmc_bus="mmc0:0001"
+else
+    fdt_addr=0x1000000
+    fit_addr=0x8000000
+    initrd_addr=0x2000000
+
+    fdt_fname="/usr/lib/linux-image-$kernel_version/marvell/armada-7020-comexpress.dtb"
+
+    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x100000'
+    demo_part=1
+    mmc_bus="mmc0:aaaa"
+fi
+
+# Skip VID Header in UBIFS
+LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
+
+#Get block device
+#Default block device is eMMC, if not look for usb storage
+get_install_device()
+{
+    for i in 0 1 2 ; do
+        if $(ls -l /sys/block/mmcblk$i/device 2>/dev/null | grep -q "$mmc_bus") ; then
+            echo "/dev/mmcblk$i"
+            blk_dev=/dev/mmcblk$i
+            echo "Selected mmc $blk_dev"
+            return 0
+        fi
+    done
+
+    echo "ERROR storage not found"
+    return 1
+}
+
+get_install_device
+if [ $? -ne 0 ]; then
+    echo "Error: Unable to detect $blk_dev $demo_dev"
+    exit 1
+fi
+
+demo_dev=${blk_dev}p${demo_part}
+
+remove_dev_partitions() {
+    echo "Remove all existing partitions starting partnum: ${demo_part} from ${blk_dev}"
+    local dev_to_install=${blk_dev}p
+    for p in $(seq ${demo_part} 9) ; do
+        if [[ -e ${dev_to_install}${p} ]]; then
+            echo "Removing partition ${dev_to_install}${p}"
+            sgdisk -d ${p} ${blk_dev} || true
+        fi
+    done
+    partprobe ${blk_dev}
+}
+
+create_demo_partition() {
+    # SD CARD
+    remove_dev_partitions
+
+    # Create sonic partition
+    sgdisk --new ${demo_part}:: \
+        --change-name=${demo_part}:${demo_volume_label} \
+        --typecode=${demo_part}:8300 -p ${blk_dev}
+
+    partprobe
+}
+
+create_partition() {
+    get_install_device
+    if [ $? -ne 0 ]; then
+        echo "Error: Unable to detect $blk_dev $demo_dev"
+        exit 1
+    fi
+
+    # Platform specific partition 
+    create_demo_partition
+}
+
+mount_partition() {
+    # Make filesystem
+    echo "demo label: $demo_volume_label. $demo_dev..."
+    mkfs.ext4 -L $demo_volume_label $demo_dev
+
+    mount -t ext4 -o defaults,rw $demo_dev $demo_mnt || {
+        echo "Error: Unable to mount $demo_dev on $demo_mnt"
+        exit 1
+    }
+}
+
+prepare_boot_menu() {
+    echo "Sync up cache ..."
+    sync
+    echo "Setting up U-Boot environment..."
+
+    DTB_HAS_ENV_BLK=$(grep uboot-env /proc/mtd | sed -e 's/:.*$//')
+    if [ -c "/dev/$DTB_HAS_ENV_BLK" ]; then
+        PROC_ENV_FILE=$(find /proc/device-tree/ -name env_size)
+        if [ -n "$PROC_ENV_FILE" ]
+        then
+            UBOOT_ENV_SIZ="0x$(hd $PROC_ENV_FILE | awk 'FNR==1 {print $2 $3 $4 $5}')"
+            UBOOT_ENV_ERASE_SIZ="0x$(grep uboot-env /proc/mtd | awk '{print $3}')"
+            if [[ -n "$UBOOT_ENV_SIZ" && -n "$UBOOT_ENV_ERASE_SIZ" ]]
+            then
+                # Env info from DTB 
+                FW_ENV_DTB="/dev/$DTB_HAS_ENV_BLK 0x00000000 $UBOOT_ENV_SIZ $UBOOT_ENV_ERASE_SIZ"
+            fi
+        fi
+    fi
+    if [ $UBOOT_FW_DEFAULT -eq 1 ]
+    then
+        echo $FW_ENV_DEFAULT > /etc/fw_env.config
+        echo "Using pre-configured uboot env"
+    fi
+    image_name=${image_dir}${kernel_fname}
+    initrd_name=${image_dir}${initrd_fname}
+    fdt_name=${image_dir}${fdt_fname}
+    fit_name=${image_dir}${fit_fname}
+
+    if [ "$install_env" = "onie" ]; then
+        FW_ARG="-f"
+        image_dir_old=""
+        image_name_old=""
+        initrd_name_old=""
+        fdt_name_old=""
+        fit_name_old=""
+        sonic_version_2="None"
+    else
+        image_dir_old=$(fw_printenv -n image_dir || true)
+        image_name_old=$(fw_printenv -n image_name || true)
+        initrd_name_old=$(fw_printenv -n initrd_name || true)
+        fdt_name_old=$(fw_printenv -n fdt_name || true)
+        fit_name_old=$(fw_printenv -n fit_name || true)
+        sonic_version_2=$(fw_printenv -n sonic_version_1 || true)
+    fi
+
+    # Set boot variables
+    fw_setenv ${FW_ARG} image_dir $image_dir > /dev/null
+    fw_setenv ${FW_ARG} image_name $image_name > /dev/null
+    fw_setenv ${FW_ARG} initrd_name $initrd_name > /dev/null
+    fw_setenv ${FW_ARG} fdt_name $fdt_name > /dev/null
+    fw_setenv ${FW_ARG} fit_name $fit_name > /dev/null
+    fw_setenv ${FW_ARG} sonic_version_1 $demo_volume_revision_label > /dev/null
+    fw_setenv ${FW_ARG} image_dir_old $image_dir_old > /dev/null
+    fw_setenv ${FW_ARG} image_name_old $image_name_old > /dev/null
+    fw_setenv ${FW_ARG} initrd_name_old $initrd_name_old > /dev/null
+    fw_setenv ${FW_ARG} fdt_name_old $fdt_name_old > /dev/null
+    fw_setenv ${FW_ARG} fit_name_old $fit_name_old > /dev/null
+    fw_setenv ${FW_ARG} sonic_version_2 $sonic_version_2 > /dev/null
+    BOOT1='echo " > Boot1: $sonic_version_1 - run sonic_image_1";echo;'
+    BOOT2='echo " > Boot2: $sonic_version_2 - run sonic_image_2";echo;'
+    BOOT3='echo " > Boot3: ONIE - run onie_boot";echo;'
+    BORDER='echo "---------------------------------------------------";echo;'
+    fw_setenv ${FW_ARG} print_menu $BORDER $BOOT1 $BOOT2 $BOOT3 $BORDER > /dev/null
+
+    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG ${ONIE_PLATFORM_EXTRA_CMDLINE_LINUX}" > /dev/null
+    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG ${ONIE_PLATFORM_EXTRA_CMDLINE_LINUX}" > /dev/null
+    sonic_bootargs_old='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs_old}'
+    fw_setenv ${FW_ARG} sonic_bootargs_old $sonic_bootargs_old > /dev/null || true
+    sonic_boot_load_old=$(fw_printenv -n sonic_boot_load || true)
+    old_str="_old"
+    fw_setenv ${FW_ARG} sonic_boot_load_old "$sonic_boot_load_old$old_str" > /dev/null || true
+
+    fw_setenv ${FW_ARG} kernel_addr $kernel_addr > /dev/null
+    fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
+    fw_setenv ${FW_ARG} fit_addr $fit_addr > /dev/null
+    fw_setenv ${FW_ARG} fit_conf_name $fit_conf_name > /dev/null
+    fw_setenv ${FW_ARG} initrd_addr $initrd_addr > /dev/null
+    MMC_LOAD='ext4load mmc 0:'$demo_part' $fit_addr $fit_name'
+    fw_setenv ${FW_ARG} sonic_boot_load "$MMC_LOAD" > /dev/null
+    SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr${fit_conf_name}'
+    SONIC_BOOT_CMD_OLD='run sonic_bootargs_old; run sonic_boot_load_old; bootm $fit_addr${fit_conf_name}'
+    BOOTARGS='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs}'
+    fw_setenv ${FW_ARG} sonic_bootargs $BOOTARGS > /dev/null
+    fw_setenv ${FW_ARG} sonic_bootcmd $SONIC_BOOT_CMD > /dev/null
+    fw_setenv ${FW_ARG} sonic_image_2 $SONIC_BOOT_CMD_OLD > /dev/null
+    fw_setenv ${FW_ARG} sonic_image_1 "$SONIC_BOOT_CMD" > /dev/null
+    fw_setenv ${FW_ARG} boot_next  'run sonic_image_1'> /dev/null
+    fw_setenv ${FW_ARG} bootcmd 'run print_menu; usb start; test -n "$boot_once" && run boot_once; run boot_next' > /dev/null
+
+}
+
+bootloader_menu_config() {
+    # Update uboot Environment
+    prepare_boot_menu
+}
+
diff --git a/platform/marvell/platform_armhf.conf b/platform/marvell/platform_armhf.conf
new file mode 100644
index 00000000000..931cddd12a4
--- /dev/null
+++ b/platform/marvell/platform_armhf.conf
@@ -0,0 +1,303 @@
+#  Copyright (C) Marvell Inc
+
+# over ride default behaviour
+
+echo "Preparing for installation ... "
+
+# global defines
+kernel_addr=0x1100000
+fdt_addr=0x2800000
+fdt_high=0x28fffff
+initrd_addr=0x2900000
+
+kernel_fname="/boot/vmlinuz-6.1.0-11-2-armmp"
+initrd_fname="/boot/initrd.img-6.1.0-11-2-armmp"
+fdt_fname="/boot/armada-385-ET6448M_4G_Nand.dtb"
+
+if [ "$install_env" = "onie" ]; then
+    MACH_FILE="/etc/machine.conf"
+else
+    MACH_FILE="/host/machine.conf"
+fi
+# armhf-marvell_et6448m_52x-r0  - Platform = Et6448M
+# armhf-nokia_ixs7215_52x-r0 - Platform = Nokia IPD6448M
+PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
+echo "Intalling SONiC from $install_env on Platform $PLATFORM"
+
+# global mount defines
+if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
+    demo_dev=ubi0
+    mtd_dev=/dev/$(cat /proc/mtd | grep "SONIC" | grep -o "mtd[0-9]")
+    mtd_num=$(echo $mtd_dev | grep -o "[0-9]")
+
+    fdt_fname="/boot/armada-385-ET6448M_4G_Nand.dtb"
+
+    BOOTARGS='setenv bootargs root='$demo_dev' rw rootwait ubi.mtd='$mtd_num' rootfstype=ubifs panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs}'
+    UBI_LOAD='run ubi_sonic_boot_mount_ubi; ubifsload $kernel_addr $image_name;ubifsload $fdt_addr $fdt_name; ubifsload $initrd_addr $initrd_name'
+    BOOTARGS_OLD='setenv bootargs root='$demo_dev' rw rootwait ubi.mtd='$mtd_num' rootfstype=ubifs panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs_old}'
+    UBI_LOAD_OLD='run ubi_sonic_boot_mount_ubi; ubifsload $kernel_addr $image_name_old;ubifsload $fdt_addr $fdt_name_old; ubifsload $initrd_addr $initrd_name_old'
+    UBIBOOTCMD='run ubi_sonic_boot_bootargs; run ubi_sonic_boot_load; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
+    UBIBOOTCMD_OLD='run ubi_sonic_boot_bootargs_old; run ubi_sonic_boot_load_old; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
+    LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
+
+elif [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
+    demo_dev=sda2
+
+    fdt_fname="/boot/armada-385-ipd6448m.dtb"
+
+    BOOTARGS='setenv bootargs root=/dev/'$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs}'
+    UBI_LOAD='scsi init; ext4load scsi 0:2 $kernel_addr $image_name; ext4load scsi 0:2 $fdt_addr $fdt_name; ext4load scsi 0:2 $initrd_addr $initrd_name'
+    BOOTARGS_OLD='setenv bootargs root=/dev/'$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs_old}'
+    UBI_LOAD_OLD='scsi init; ext4load scsi 0:2 $kernel_addr $image_name_old; ext4load scsi 0:2 $fdt_addr $fdt_name_old; ext4load scsi 0:2 $initrd_addr $initrd_name_old'
+    UBIBOOTCMD='run ubi_sonic_boot_bootargs; run ubi_sonic_boot_load; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
+    UBIBOOTCMD_OLD='run ubi_sonic_boot_bootargs_old; run ubi_sonic_boot_load_old; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
+    LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
+
+else
+    echo "Unsupported Platform $PLAFORM"
+    exit 2
+fi
+demo_mnt=/tmp
+FW_ENV_DEFAULT='/dev/mtd0 0x00500000 0x80000 0x100000 8'
+UBOOT_FW_DEFAULT=1
+
+prepare_boot_menu() {
+    echo "Sync up cache ..."
+    sync
+    echo "Setting up U-Boot environment..."
+
+    DTB_HAS_ENV_BLK=$(grep uboot-env /proc/mtd | sed -e 's/:.*$//')
+    if [ -c "/dev/$DTB_HAS_ENV_BLK" ]; then
+        PROC_ENV_FILE=$(find /proc/device-tree/ -name env_size)
+        if [ -n "$PROC_ENV_FILE" ]
+        then
+            UBOOT_ENV_SIZ="0x$(hd $PROC_ENV_FILE | awk 'FNR==1 {print $2 $3 $4 $5}')"
+            UBOOT_ENV_ERASE_SIZ="0x$(grep uboot-env /proc/mtd | awk '{print $3}')"
+            if [[ -n "$UBOOT_ENV_SIZ" && -n "$UBOOT_ENV_ERASE_SIZ" ]]
+            then
+                # Env info from DTB 
+                FW_ENV_DTB="/dev/$DTB_HAS_ENV_BLK 0x00000000 $UBOOT_ENV_SIZ $UBOOT_ENV_ERASE_SIZ"
+            fi
+        fi
+    fi
+    if [ -n "$FW_ENV_DTB" ]
+    then
+                echo $FW_ENV_DTB > /etc/fw_env.config
+                echo "Found uboot env offset in device tree"
+                UBOOT_ENV_CRC=$(fw_printenv 2>&1 | grep -c 'Warning: Bad CRC') || true
+                if [ "$UBOOT_ENV_CRC" -eq 0 ]
+                then
+                    echo "Uboot env offset in device tree is valid"
+                    UBOOT_FW_DEFAULT=0
+                    fdt_fname="/boot/armada-385-ET6448M_4G_Nand_r2019.dtb"
+                else
+                    echo "Uboot env offset in device tree is NOT valid"
+                    UBOOT_FW_DEFAULT=1
+                fi
+    fi
+    if [ $UBOOT_FW_DEFAULT -eq 1 ]
+    then
+        echo $FW_ENV_DEFAULT > /etc/fw_env.config
+        echo "Using pre-configured uboot env"
+    fi
+    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
+        FW_ENV_DEFAULT='/dev/mtd0 0x00100000 0x10000 0x10000'
+        echo $FW_ENV_DEFAULT > /etc/fw_env.config
+        echo "Using pre-configured uboot env for armhf-nokia_ixs7215_52x-r0"
+    fi
+
+    image_name=${image_dir}${kernel_fname}
+    initrd_name=${image_dir}${initrd_fname}
+    fdt_name=${image_dir}${fdt_fname}
+
+    if [ "$install_env" = "onie" ]; then
+        FW_ARG="-f"
+        image_dir_old=""
+        image_name_old=""
+        initrd_name_old=""
+        fdt_name_old=""
+        sonic_version_2="None"
+    else
+        eval running_version="$(cat /proc/cmdline | sed -n 's/^.*loop=\/*image-\(\S\+\)\/.*$/\1/p')"
+        current_boot_next=$(fw_printenv -n boot_next || true)
+        running_sonic_image=1
+        if [ "$current_boot_next" = "run sonic_image_1" ]; then
+            # boot_next=run sonic_image_1
+            sonic_version_2=$(fw_printenv -n sonic_version_2 || true)
+            if test "${sonic_version_2#*$running_version}" != "$sonic_version_2"
+            then
+                running_sonic_image=2
+            else
+                running_sonic_image=1
+            fi
+        else
+            # boot_next=run sonic_image_2  
+            sonic_version_1=$(fw_printenv -n sonic_version_1 || true)
+            if test "${sonic_version_1#*$running_version}" != "$sonic_version_1"
+            then
+                running_sonic_image=1
+            else
+                running_sonic_image=2
+            fi
+        fi   
+        
+        if [ $running_sonic_image -eq 1 ]; then
+            image_dir_old=$(fw_printenv -n image_dir || true)
+            image_name_old=$(fw_printenv -n image_name || true)
+            initrd_name_old=$(fw_printenv -n initrd_name || true)
+            fdt_name_old=$(fw_printenv -n fdt_name || true)
+            sonic_version_2=$(fw_printenv -n sonic_version_1 || true)
+        else
+            image_dir_old=$(fw_printenv -n image_dir_old || true)
+            image_name_old=$(fw_printenv -n image_name_old || true)
+            initrd_name_old=$(fw_printenv -n initrd_name_old || true)
+            fdt_name_old=$(fw_printenv -n fdt_name_old || true)
+            sonic_version_2=$(fw_printenv -n sonic_version_2 || true)
+        fi
+    fi
+
+    # Set boot variables
+    fw_setenv ${FW_ARG} image_dir $image_dir > /dev/null
+    fw_setenv ${FW_ARG} image_name $image_name > /dev/null
+    fw_setenv ${FW_ARG} initrd_name $initrd_name > /dev/null
+    fw_setenv ${FW_ARG} fdt_name $fdt_name > /dev/null
+    fw_setenv ${FW_ARG} sonic_version_1 $demo_volume_revision_label > /dev/null
+    fw_setenv ${FW_ARG} image_dir_old $image_dir_old > /dev/null
+    fw_setenv ${FW_ARG} image_name_old $image_name_old > /dev/null
+    fw_setenv ${FW_ARG} initrd_name_old $initrd_name_old > /dev/null
+    fw_setenv ${FW_ARG} fdt_name_old $fdt_name_old > /dev/null
+    fw_setenv ${FW_ARG} sonic_version_2 $sonic_version_2 > /dev/null
+    BOOT1='echo " > Boot1: $sonic_version_1 - run sonic_image_1";echo;'
+    BOOT2='echo " > Boot2: $sonic_version_2 - run sonic_image_2";echo;'
+    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
+        BOOT3='echo " > Boot3: ONIE - run onie_bootcmd";echo;'
+    else
+        BOOT3='echo " > Boot3: ONIE - run onie_nand_boot";echo;'
+    fi
+    BORDER='echo "---------------------------------------------------";echo;'
+    fw_setenv ${FW_ARG} print_menu "$BORDER $BOOT1 $BOOT2 $BOOT3 $BORDER" > /dev/null
+
+    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG_SIZE loglevel=4 ${extra_cmdline_linux}" > /dev/null
+    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG_SIZE loglevel=4" > /dev/null
+
+    # Set boot configs
+    fw_setenv ${FW_ARG} kernel_addr $kernel_addr > /dev/null
+    fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
+    fw_setenv ${FW_ARG} fdt_high $fdt_high > /dev/null
+    fw_setenv ${FW_ARG} initrd_addr $initrd_addr > /dev/null
+    fw_setenv ${FW_ARG} mtdids 'nand0=armada-nand' > /dev/null
+    if [ $UBOOT_FW_DEFAULT -eq 1 ]
+    then
+        fw_setenv ${FW_ARG} mtdparts 'mtdparts=armada-nand:10m(U-Boot)ro,20m@10m(ONIE),-(SONIC)' > /dev/null
+    else
+        fw_setenv ${FW_ARG} mtdparts 'mtdparts=armada-nand:4m(uboot)ro,5m@5m(uboot-env),20m@10m(ONIE),-(SONIC)' > /dev/null
+    fi
+    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
+        fw_setenv ${FW_ARG} mtdparts 'mtdparts=spi0.0:4m(boot),-(spi-rootfs)' > /dev/null
+    fi
+    fw_setenv ${FW_ARG} ubi_sonic_boot_mount_ubi 'ubi part SONIC; ubifsmount ubi0' > /dev/null
+    fw_setenv ${FW_ARG} ubi_sonic_boot_bootargs "$BOOTARGS" > /dev/null
+    fw_setenv ${FW_ARG} ubi_sonic_boot_load "$UBI_LOAD" > /dev/null
+    fw_setenv ${FW_ARG} sonic_image_1 "$UBIBOOTCMD" > /dev/null
+    fw_setenv ${FW_ARG} ubi_sonic_boot_bootargs_old "$BOOTARGS_OLD" > /dev/null
+    fw_setenv ${FW_ARG} ubi_sonic_boot_load_old "$UBI_LOAD_OLD" > /dev/null
+    fw_setenv ${FW_ARG} sonic_image_2 "$UBIBOOTCMD_OLD" > /dev/null
+    fw_setenv ${FW_ARG} boot_next  'run sonic_image_1'> /dev/null
+    fw_setenv ${FW_ARG} bootcmd 'run print_menu; usb start; test -n "$boot_once" && run boot_once; run boot_next' > /dev/null
+
+}
+
+create_ubi_partition() {
+    ubidetach /dev/ubi_ctrl -d 0 2>/dev/null || true 
+
+    trap_push "${onie_bin} ubidetach -d 0 /dev/ubi_ctrl || true"
+    echo -en "Format mtd partition '$mtd_dev' "
+    ubiformat $mtd_dev -y -q || {
+        echo "Failed"
+    }
+
+    #attaches MTD devices (which describe raw flash) to UBI and creates corresponding UBI devices; ('-m 2' --> mtd2)
+    echo -en "ubiattach mtd '$mtd_num' "
+    ubiattach /dev/ubi_ctrl -m $mtd_num || {
+        echo "Failed"
+    }
+
+    #creates UBI volumes on UBI devices
+    ubimkvol  /dev/$demo_dev -N $demo_dev -s 3900MiB
+}
+
+create_gpt_partition() {
+    blk_dev="/dev/sda"
+    demo_part=$(sgdisk -p $blk_dev | grep -e "$demo_volume_label" | awk '{print $1}')
+    # ONIE partition size 168MB
+    onie_part_size=168
+
+    if [ -z "$demo_part" ] ; then
+        # Partition Does NOT Exists
+        echo "SONIC label [$demo_volume_label] is NOT found in Partition"
+        echo "Proceeding to create partition"
+
+        attr_bitmask="0x0"
+
+        sgdisk --new=${demo_part}::+${onie_part_size}MB \
+            --attributes=${demo_part}:=:$attr_bitmask \
+            --change-name=${demo_part}:$demo_volume_label $blk_dev \
+        || {
+            echo "Warning: The first trial of creating partition failed, trying the largest aligned available block of sectors on the disk"
+            begin=$(sgdisk -F $blk_dev)
+            end=$(sgdisk -E $blk_dev)
+            sgdisk --new=${demo_part}:$begin:$end \
+                --attributes=${demo_part}:=:$attr_bitmask \
+                --change-name=${demo_part}:$demo_volume_label $blk_dev
+        } || {
+            echo "Error: Unable to create partition $demo_part on $blk_dev"
+            exit 1
+        }
+        partprobe || true
+    else
+        # Partition Exists
+        echo "Partition exists $demo_part on $blk_dev"
+    fi
+
+    # Make filesystem
+    mkfs.ext4 -L $demo_volume_label /dev/$demo_dev
+}
+
+create_partition() {
+    # Platform speicific partition 
+    if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
+        echo "Doing UBI partition"
+        create_ubi_partition
+    else
+        echo "Doing GPT partition"
+        create_gpt_partition
+    fi
+}
+
+mount_partition() {
+
+    demo_mnt=$(mktemp -d) || {
+        echo "Error: Unable to create file sstem mount point"
+        exit 1
+    }
+
+    echo "Mounting $demo_dev on $demo_mnt "
+    if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
+        trap_push "${onie_bin} umount /dev/ubi0_0|| true"
+        mount -t ubifs /dev/ubi0_0 $demo_mnt || {
+            echo "mount -t ubifs /dev/ubi0_0 $demo_mnt Failed"
+            exit 1
+        }
+    else
+        trap_push "${onie_bin} umount /dev/sda2|| true"
+        mount -t ext4 /dev/sda2 $demo_mnt || {
+            echo "mount -t ext4 /dev/sda2 $demo_mnt Failed"
+            exit 1
+        }
+    fi
+}
+
+bootloader_menu_config() {
+    # Update uboot Environment
+    prepare_boot_menu
+}

From 5b7d3f42fee053c0b670acbf5f8945a73965d7db Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 06:13:55 +0000
Subject: [PATCH 05/10] [arm64] Adjust the path to read sonic_fit.its

Use CONFIGURED_PLATFORM based path while reading sonic_fit.its.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 build_debian.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/build_debian.sh b/build_debian.sh
index b9dfd47bb5a..d4b5511b788 100755
--- a/build_debian.sh
+++ b/build_debian.sh
@@ -781,7 +781,7 @@ if [[ $TARGET_BOOTLOADER == uboot ]]; then
             ## Overwriting the initrd image with uInitrd
             sudo LANG=C chroot $FILESYSTEM_ROOT mv /boot/u${INITRD_FILE} /boot/$INITRD_FILE
         else
-            sudo cp -v $PLATFORM_DIR/${sonic_asic_platform}-${CONFIGURED_ARCH}/sonic_fit.its $FILESYSTEM_ROOT/boot/
+            sudo cp -v $PLATFORM_DIR/$CONFIGURED_PLATFORM/sonic_fit.its $FILESYSTEM_ROOT/boot/
             sudo LANG=C chroot $FILESYSTEM_ROOT mkimage -f /boot/sonic_fit.its /boot/sonic_${CONFIGURED_ARCH}.fit
         fi
     fi

From f7a6b8564ce8960d0eb5670b3e94079f3e6e44a3 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 06:23:15 +0000
Subject: [PATCH 06/10] [arm64/armhf] Add architecture suffix for output image

This change is needed to generate the output image with
architecture suffix for arm64/armhf platform.
For arm64, defined a marvell specific file to avoid affect
on other vendors.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 build_image.sh                         |  6 ++-
 onie-image-armhf.conf                  |  8 ++--
 platform/marvell/onie-image-arm64.conf | 55 ++++++++++++++++++++++++++
 3 files changed, 64 insertions(+), 5 deletions(-)
 create mode 100644 platform/marvell/onie-image-arm64.conf

diff --git a/build_image.sh b/build_image.sh
index e25a98a0027..fe75bcaf332 100755
--- a/build_image.sh
+++ b/build_image.sh
@@ -9,7 +9,11 @@ set -x -e
 CONFIGURED_ARCH=$([ -f .arch ] && cat .arch || echo amd64)
 
 if [[ $CONFIGURED_ARCH == armhf || $CONFIGURED_ARCH == arm64 ]]; then
-    . ./onie-image-${CONFIGURED_ARCH}.conf
+    if [ -r ./platform/${CONFIGURED_PLATFORM}/onie-image-${CONFIGURED_ARCH}.conf ]; then
+        . ./platform/${CONFIGURED_PLATFORM}/onie-image-${CONFIGURED_ARCH}.conf
+    else
+        . ./onie-image-${CONFIGURED_ARCH}.conf
+    fi
 else
     . ./onie-image.conf
 fi
diff --git a/onie-image-armhf.conf b/onie-image-armhf.conf
index 2672187d95f..f3d88fc6f97 100644
--- a/onie-image-armhf.conf
+++ b/onie-image-armhf.conf
@@ -31,22 +31,22 @@ DOCKERFS_DIR=docker
 DOCKER_RAMFS_SIZE=2500M
 
 ## Output file name for onie installer
-OUTPUT_ONIE_IMAGE=target/sonic-$TARGET_MACHINE.bin
+OUTPUT_ONIE_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.bin
 
 ## Output file name for raw image
-OUTPUT_RAW_IMAGE=target/sonic-$TARGET_MACHINE.raw
+OUTPUT_RAW_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.raw
 
 ## Raw image size in MB
 RAW_IMAGE_DISK_SIZE=4096
 
 ## Output file name for kvm image
-OUTPUT_KVM_IMAGE=target/sonic-$TARGET_MACHINE.img
+OUTPUT_KVM_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.img
 
 ## Kvm image size in GB
 KVM_IMAGE_DISK_SIZE=16
 
 ## Output file name for aboot installer
-OUTPUT_ABOOT_IMAGE=target/sonic-aboot-$TARGET_MACHINE.swi
+OUTPUT_ABOOT_IMAGE=target/sonic-aboot-$TARGET_MACHINE-$CONFIGURED_ARCH.swi
 
 ## Aboot boot image name
 ABOOT_BOOT_IMAGE=.sonic-boot.swi
diff --git a/platform/marvell/onie-image-arm64.conf b/platform/marvell/onie-image-arm64.conf
new file mode 100644
index 00000000000..69d93d72298
--- /dev/null
+++ b/platform/marvell/onie-image-arm64.conf
@@ -0,0 +1,55 @@
+## DESCRIPTION:
+##   config for ONIE image
+##
+
+## Partition size in MB
+## The default size is 32GB
+: ${ONIE_IMAGE_PART_SIZE:=32768}
+
+## Target hardware information
+: ${TARGET_PLATFORM:=arm64}
+: ${TARGET_MACHINE:=generic}
+
+ONIEIMAGE_VERSION=r0
+
+## Filesystem root
+FILESYSTEM_ROOT=./fsroot-${TARGET_MACHINE}
+
+## Filename for squashfs file system
+FILESYSTEM_SQUASHFS=fs.squashfs
+
+## Filename for onie installer payload, will be the main part of onie installer
+INSTALLER_PAYLOAD=fs.zip
+
+## Filename for docker file system
+FILESYSTEM_DOCKERFS=dockerfs.tar.gz
+
+## docker directory on the root filesystem
+DOCKERFS_DIR=docker
+
+## docker ramfs disk space
+DOCKER_RAMFS_SIZE=2500M
+
+## Output file name for onie installer
+OUTPUT_ONIE_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.bin
+
+## Output file name for raw image
+OUTPUT_RAW_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.raw
+
+## Raw image size in MB
+RAW_IMAGE_DISK_SIZE=4096
+
+## Output file name for kvm image
+OUTPUT_KVM_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.img
+
+## Kvm image size in GB
+KVM_IMAGE_DISK_SIZE=16
+
+## Output file name for aboot installer
+OUTPUT_ABOOT_IMAGE=target/sonic-aboot-$TARGET_MACHINE-$CONFIGURED_ARCH.swi
+
+## Aboot boot image name
+ABOOT_BOOT_IMAGE=.sonic-boot.swi
+
+## Output file name for dsc installer
+OUTPUT_DSC_IMAGE=target/sonic-$TARGET_MACHINE-$CONFIGURED_ARCH.tar

From 43a397fa1ca642451fcf61730d1365d1e6d42485 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 06:32:54 +0000
Subject: [PATCH 07/10] Change platform_asic name to marvell

Change 'marvell-arm64' and 'marvell-armhf' platform_asic name
to 'marvell'.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 device/marvell/arm64-marvell_rd98DX35xx-r0/platform_asic        | 2 +-
 device/marvell/arm64-marvell_rd98DX35xx_cn9131-r0/platform_asic | 2 +-
 device/nokia/arm64-nokia_ixs7215_52xb-r0/platform_asic          | 2 +-
 device/nokia/armhf-nokia_ixs7215_52x-r0/platform_asic           | 2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/device/marvell/arm64-marvell_rd98DX35xx-r0/platform_asic b/device/marvell/arm64-marvell_rd98DX35xx-r0/platform_asic
index 558e01e1845..a554752878b 100644
--- a/device/marvell/arm64-marvell_rd98DX35xx-r0/platform_asic
+++ b/device/marvell/arm64-marvell_rd98DX35xx-r0/platform_asic
@@ -1 +1 @@
-marvell-arm64
+marvell
diff --git a/device/marvell/arm64-marvell_rd98DX35xx_cn9131-r0/platform_asic b/device/marvell/arm64-marvell_rd98DX35xx_cn9131-r0/platform_asic
index 558e01e1845..a554752878b 100644
--- a/device/marvell/arm64-marvell_rd98DX35xx_cn9131-r0/platform_asic
+++ b/device/marvell/arm64-marvell_rd98DX35xx_cn9131-r0/platform_asic
@@ -1 +1 @@
-marvell-arm64
+marvell
diff --git a/device/nokia/arm64-nokia_ixs7215_52xb-r0/platform_asic b/device/nokia/arm64-nokia_ixs7215_52xb-r0/platform_asic
index 558e01e1845..a554752878b 100644
--- a/device/nokia/arm64-nokia_ixs7215_52xb-r0/platform_asic
+++ b/device/nokia/arm64-nokia_ixs7215_52xb-r0/platform_asic
@@ -1 +1 @@
-marvell-arm64
+marvell
diff --git a/device/nokia/armhf-nokia_ixs7215_52x-r0/platform_asic b/device/nokia/armhf-nokia_ixs7215_52x-r0/platform_asic
index 64b1d7dbb42..a554752878b 100644
--- a/device/nokia/armhf-nokia_ixs7215_52x-r0/platform_asic
+++ b/device/nokia/armhf-nokia_ixs7215_52x-r0/platform_asic
@@ -1 +1 @@
-marvell-armhf
+marvell

From a8d57a0d7ce8eeb3f13f7f042a5c1903d2544633 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 06:35:23 +0000
Subject: [PATCH 08/10] Remove marvell-armhf and marvell-arm64 folders

Removed 'marvell-armhf' and 'marvell-arm64' as infra is
combined with 'marvell' folder.

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 .../marvell-arm64/docker-saiserver-mrvl.dep   |   8 -
 .../marvell-arm64/docker-saiserver-mrvl.mk    |  14 -
 .../marvell-arm64/docker-syncd-mrvl-rpc.dep   |   8 -
 .../marvell-arm64/docker-syncd-mrvl-rpc.mk    |  27 -
 .../docker-syncd-mrvl-rpc/99-syncd.conf       |   1 -
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |  56 --
 .../docker-syncd-mrvl-rpc/ptf_nn_agent.conf   |  10 -
 platform/marvell-arm64/docker-syncd-mrvl.dep  |  10 -
 platform/marvell-arm64/docker-syncd-mrvl.mk   |  16 -
 .../docker-syncd-mrvl/Dockerfile.j2           |  37 --
 .../docker-syncd-mrvl/critical_processes      |   1 -
 .../docker-syncd-mrvl/supervisord.conf        |  39 --
 .../marvell-arm64/docker-syncd-mrvl/syncd.sh  |  12 -
 platform/marvell-arm64/libsaithrift-dev.dep   |  11 -
 platform/marvell-arm64/libsaithrift-dev.mk    |  20 -
 platform/marvell-arm64/mrvl-prestera          |   1 -
 platform/marvell-arm64/mrvl-prestera.dep      |   9 -
 platform/marvell-arm64/mrvl-prestera.mk       |   8 -
 platform/marvell-arm64/one-image.dep          |   1 -
 platform/marvell-arm64/one-image.mk           |  17 -
 platform/marvell-arm64/platform-marvell.dep   |   9 -
 platform/marvell-arm64/platform-marvell.mk    |  18 -
 platform/marvell-arm64/platform-nokia.dep     |   8 -
 platform/marvell-arm64/platform-nokia.mk      |  23 -
 platform/marvell-arm64/platform.conf          | 248 -------
 platform/marvell-arm64/rules.dep              |   9 -
 platform/marvell-arm64/rules.mk               |  26 -
 platform/marvell-arm64/sai.dep                |   8 -
 platform/marvell-arm64/sai.mk                 |   9 -
 platform/marvell-arm64/sai/Makefile           |   9 -
 platform/marvell-arm64/sonic-platform-marvell |   1 -
 .../7215/modules/Makefile                     |   1 -
 .../7215/modules/cn9130_cpu_thermal_sensor.c  | 242 -------
 .../7215/modules/nokia_7215_ixs_a1_cpld.c     | 615 ------------------
 .../7215/scripts/cpu_wdt.py                   |  46 --
 .../7215/scripts/nokia-7215-init.sh           | 110 ----
 .../7215/service/cpu_wdt.service              |   8 -
 .../7215/service/nokia-7215init.service       |  11 -
 .../sonic-platform-nokia/7215/setup.py        |  15 -
 .../7215/sonic_platform/__init__.py           |   3 -
 .../7215/sonic_platform/chassis.py            | 440 -------------
 .../7215/sonic_platform/component.py          | 219 -------
 .../7215/sonic_platform/eeprom.py             | 174 -----
 .../7215/sonic_platform/fan.py                | 332 ----------
 .../7215/sonic_platform/fan_drawer.py         | 102 ---
 .../7215/sonic_platform/platform.py           |  22 -
 .../7215/sonic_platform/psu.py                | 321 ---------
 .../7215/sonic_platform/sfp.py                | 214 ------
 .../7215/sonic_platform/sfp_event.py          | 119 ----
 .../7215/sonic_platform/test/README           |   1 -
 .../7215/sonic_platform/test/test-chassis.py  |  72 --
 .../sonic_platform/test/test-component.py     |  22 -
 .../7215/sonic_platform/test/test-eeprom.py   |  25 -
 .../7215/sonic_platform/test/test-fan.py      |  32 -
 .../7215/sonic_platform/test/test-psu.py      |  40 --
 .../7215/sonic_platform/test/test-sfp.py      |  56 --
 .../7215/sonic_platform/test/test-thermal.py  |  50 --
 .../7215/sonic_platform/test/test-watchdog.py |  22 -
 .../7215/sonic_platform/thermal.py            | 265 --------
 .../7215/sonic_platform/thermal_actions.py    | 222 -------
 .../7215/sonic_platform/thermal_conditions.py |  81 ---
 .../7215/sonic_platform/thermal_infos.py      | 270 --------
 .../7215/sonic_platform/thermal_manager.py    |  49 --
 .../7215/sonic_platform/watchdog.py           | 231 -------
 .../7215/utils/sonic_ssd.py                   |  47 --
 .../sonic-platform-nokia/debian/changelog     |   5 -
 .../sonic-platform-nokia/debian/compat        |   1 -
 .../sonic-platform-nokia/debian/control       |  13 -
 .../sonic-platform-nokia/debian/rules         |  84 ---
 .../debian/sonic-platform-nokia-7215.install  |   6 -
 .../debian/sonic-platform-nokia-7215.postinst |  48 --
 platform/marvell-arm64/sonic_fit.its          | 151 -----
 .../marvell-armhf/docker-saiserver-mrvl.dep   |   8 -
 .../marvell-armhf/docker-saiserver-mrvl.mk    |  15 -
 .../marvell-armhf/docker-syncd-mrvl-rpc.dep   |   8 -
 .../marvell-armhf/docker-syncd-mrvl-rpc.mk    |  25 -
 .../docker-syncd-mrvl-rpc/99-syncd.conf       |   1 -
 .../docker-syncd-mrvl-rpc/Dockerfile.j2       |  56 --
 .../docker-syncd-mrvl-rpc/ptf_nn_agent.conf   |  10 -
 platform/marvell-armhf/docker-syncd-mrvl.dep  |  10 -
 platform/marvell-armhf/docker-syncd-mrvl.mk   |  16 -
 .../docker-syncd-mrvl/Dockerfile.j2           |  37 --
 .../docker-syncd-mrvl/critical_processes      |   1 -
 .../docker-syncd-mrvl/supervisord.conf        |  39 --
 platform/marvell-armhf/libsaithrift-dev.dep   |  11 -
 platform/marvell-armhf/libsaithrift-dev.mk    |  20 -
 platform/marvell-armhf/one-image.dep          |   1 -
 platform/marvell-armhf/one-image.mk           |  16 -
 platform/marvell-armhf/platform-et6448m.dep   |   8 -
 platform/marvell-armhf/platform-et6448m.mk    |   8 -
 platform/marvell-armhf/platform-nokia.dep     |   8 -
 platform/marvell-armhf/platform-nokia.mk      |  10 -
 platform/marvell-armhf/platform.conf          | 303 ---------
 platform/marvell-armhf/prestera.dep           |   8 -
 platform/marvell-armhf/prestera.mk            |  11 -
 .../marvell-armhf/prestera/debian/changelog   |   5 -
 platform/marvell-armhf/prestera/debian/compat |   1 -
 .../marvell-armhf/prestera/debian/control     |  15 -
 .../debian/mrvlprestera.install.template      |   2 -
 platform/marvell-armhf/prestera/debian/rules  |  56 --
 platform/marvell-armhf/rules.dep              |   9 -
 platform/marvell-armhf/rules.mk               |  28 -
 platform/marvell-armhf/sai.dep                |   9 -
 platform/marvell-armhf/sai.mk                 |   9 -
 platform/marvell-armhf/sai/Makefile           |   9 -
 .../sonic-platform-et6448m/.gitignore         |  50 --
 .../sonic-platform-et6448m/debian/changelog   |   5 -
 .../sonic-platform-et6448m/debian/compat      |   1 -
 .../sonic-platform-et6448m/debian/control     |  15 -
 .../sonic-platform-et6448m/debian/install     |   3 -
 .../sonic-platform-et6448m/debian/postinst    |  40 --
 .../sonic-platform-et6448m/debian/rules       |  25 -
 .../sonic-platform-et6448m/entropy.py         |  22 -
 .../et6448m_plt_setup.sh                      |  60 --
 .../sonic-platform-et6448m/inband_mgmt.sh     |  40 --
 .../7215/scripts/cpu_wdt.py                   |  46 --
 .../7215/scripts/nokia-7215init.sh            |  68 --
 .../7215/service/cpu_wdt.service              |   8 -
 .../service/fstrim.timer/timer-override.conf  |   5 -
 .../7215/service/nokia-7215init.service       |  14 -
 .../sonic-platform-nokia/7215/setup.py        |  15 -
 .../7215/sonic_platform/__init__.py           |   4 -
 .../7215/sonic_platform/chassis.py            | 415 ------------
 .../7215/sonic_platform/component.py          | 175 -----
 .../7215/sonic_platform/eeprom.py             | 284 --------
 .../7215/sonic_platform/fan.py                | 384 -----------
 .../7215/sonic_platform/fan_drawer.py         | 102 ---
 .../7215/sonic_platform/platform.py           |  22 -
 .../7215/sonic_platform/psu.py                | 317 ---------
 .../7215/sonic_platform/sfp.py                | 216 ------
 .../7215/sonic_platform/sfp_event.py          | 112 ----
 .../7215/sonic_platform/test/README           |   1 -
 .../7215/sonic_platform/test/test-chassis.py  |  72 --
 .../sonic_platform/test/test-component.py     |  22 -
 .../7215/sonic_platform/test/test-eeprom.py   |  25 -
 .../7215/sonic_platform/test/test-fan.py      |  32 -
 .../7215/sonic_platform/test/test-psu.py      |  40 --
 .../7215/sonic_platform/test/test-sfp.py      |  56 --
 .../7215/sonic_platform/test/test-thermal.py  |  50 --
 .../7215/sonic_platform/test/test-watchdog.py |  22 -
 .../7215/sonic_platform/thermal.py            | 259 --------
 .../7215/sonic_platform/thermal_actions.py    | 192 ------
 .../7215/sonic_platform/thermal_conditions.py |  81 ---
 .../7215/sonic_platform/thermal_infos.py      | 210 ------
 .../7215/sonic_platform/thermal_manager.py    |  49 --
 .../7215/sonic_platform/watchdog.py           | 209 ------
 .../sonic-platform-nokia/debian/changelog     |   5 -
 .../sonic-platform-nokia/debian/compat        |   1 -
 .../sonic-platform-nokia/debian/control       |  15 -
 .../sonic-platform-nokia/debian/rules         |  64 --
 .../debian/sonic-platform-nokia-7215.install  |   8 -
 .../debian/sonic-platform-nokia-7215.postinst |  14 -
 .../sonic-platform-nokia/inband_mgmt.sh       |  28 -
 .../nokia-7215_plt_setup.sh                   |  31 -
 154 files changed, 10168 deletions(-)
 delete mode 100644 platform/marvell-arm64/docker-saiserver-mrvl.dep
 delete mode 100644 platform/marvell-arm64/docker-saiserver-mrvl.mk
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl-rpc.dep
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl-rpc.mk
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl-rpc/99-syncd.conf
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl.dep
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl.mk
 delete mode 100755 platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl/critical_processes
 delete mode 100644 platform/marvell-arm64/docker-syncd-mrvl/supervisord.conf
 delete mode 100755 platform/marvell-arm64/docker-syncd-mrvl/syncd.sh
 delete mode 100644 platform/marvell-arm64/libsaithrift-dev.dep
 delete mode 100644 platform/marvell-arm64/libsaithrift-dev.mk
 delete mode 160000 platform/marvell-arm64/mrvl-prestera
 delete mode 100644 platform/marvell-arm64/mrvl-prestera.dep
 delete mode 100644 platform/marvell-arm64/mrvl-prestera.mk
 delete mode 100644 platform/marvell-arm64/one-image.dep
 delete mode 100644 platform/marvell-arm64/one-image.mk
 delete mode 100644 platform/marvell-arm64/platform-marvell.dep
 delete mode 100644 platform/marvell-arm64/platform-marvell.mk
 delete mode 100644 platform/marvell-arm64/platform-nokia.dep
 delete mode 100644 platform/marvell-arm64/platform-nokia.mk
 delete mode 100644 platform/marvell-arm64/platform.conf
 delete mode 100644 platform/marvell-arm64/rules.dep
 delete mode 100644 platform/marvell-arm64/rules.mk
 delete mode 100644 platform/marvell-arm64/sai.dep
 delete mode 100644 platform/marvell-arm64/sai.mk
 delete mode 100644 platform/marvell-arm64/sai/Makefile
 delete mode 160000 platform/marvell-arm64/sonic-platform-marvell
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/modules/Makefile
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/modules/cn9130_cpu_thermal_sensor.c
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/modules/nokia_7215_ixs_a1_cpld.c
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/scripts/cpu_wdt.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/scripts/nokia-7215-init.sh
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/service/cpu_wdt.service
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/service/nokia-7215init.service
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/setup.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/__init__.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/chassis.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/component.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/eeprom.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/platform.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/psu.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/README
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/watchdog.py
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/7215/utils/sonic_ssd.py
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/debian/changelog
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/debian/compat
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/debian/control
 delete mode 100755 platform/marvell-arm64/sonic-platform-nokia/debian/rules
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
 delete mode 100644 platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
 delete mode 100644 platform/marvell-arm64/sonic_fit.its
 delete mode 100644 platform/marvell-armhf/docker-saiserver-mrvl.dep
 delete mode 100644 platform/marvell-armhf/docker-saiserver-mrvl.mk
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl-rpc.dep
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl-rpc.mk
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl-rpc/99-syncd.conf
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl.dep
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl.mk
 delete mode 100755 platform/marvell-armhf/docker-syncd-mrvl/Dockerfile.j2
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl/critical_processes
 delete mode 100644 platform/marvell-armhf/docker-syncd-mrvl/supervisord.conf
 delete mode 100644 platform/marvell-armhf/libsaithrift-dev.dep
 delete mode 100644 platform/marvell-armhf/libsaithrift-dev.mk
 delete mode 100644 platform/marvell-armhf/one-image.dep
 delete mode 100644 platform/marvell-armhf/one-image.mk
 delete mode 100644 platform/marvell-armhf/platform-et6448m.dep
 delete mode 100644 platform/marvell-armhf/platform-et6448m.mk
 delete mode 100644 platform/marvell-armhf/platform-nokia.dep
 delete mode 100644 platform/marvell-armhf/platform-nokia.mk
 delete mode 100644 platform/marvell-armhf/platform.conf
 delete mode 100644 platform/marvell-armhf/prestera.dep
 delete mode 100644 platform/marvell-armhf/prestera.mk
 delete mode 100644 platform/marvell-armhf/prestera/debian/changelog
 delete mode 100644 platform/marvell-armhf/prestera/debian/compat
 delete mode 100755 platform/marvell-armhf/prestera/debian/control
 delete mode 100644 platform/marvell-armhf/prestera/debian/mrvlprestera.install.template
 delete mode 100755 platform/marvell-armhf/prestera/debian/rules
 delete mode 100644 platform/marvell-armhf/rules.dep
 delete mode 100644 platform/marvell-armhf/rules.mk
 delete mode 100644 platform/marvell-armhf/sai.dep
 delete mode 100644 platform/marvell-armhf/sai.mk
 delete mode 100644 platform/marvell-armhf/sai/Makefile
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/.gitignore
 delete mode 100755 platform/marvell-armhf/sonic-platform-et6448m/debian/changelog
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/debian/compat
 delete mode 100755 platform/marvell-armhf/sonic-platform-et6448m/debian/control
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/debian/install
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/debian/postinst
 delete mode 100755 platform/marvell-armhf/sonic-platform-et6448m/debian/rules
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/entropy.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-et6448m/et6448m_plt_setup.sh
 delete mode 100644 platform/marvell-armhf/sonic-platform-et6448m/inband_mgmt.sh
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/scripts/cpu_wdt.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/service/cpu_wdt.service
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/service/nokia-7215init.service
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/setup.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/__init__.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/eeprom.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/platform.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/README
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/watchdog.py
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/debian/changelog
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/debian/compat
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/debian/control
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/debian/rules
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
 delete mode 100644 platform/marvell-armhf/sonic-platform-nokia/inband_mgmt.sh
 delete mode 100755 platform/marvell-armhf/sonic-platform-nokia/nokia-7215_plt_setup.sh

diff --git a/platform/marvell-arm64/docker-saiserver-mrvl.dep b/platform/marvell-arm64/docker-saiserver-mrvl.dep
deleted file mode 100644
index 3ded7bc916e..00000000000
--- a/platform/marvell-arm64/docker-saiserver-mrvl.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-DPATH       := $($(DOCKER_SAISERVER_MRVL)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-saiserver-mrvl.mk $(PLATFORM_PATH)/docker-saiserver-mrvl.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SAISERVER_MRVL)_CACHE_MODE  := GIT_CONTENT_SHA
-$(DOCKER_SAISERVER_MRVL)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SAISERVER_MRVL)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-arm64/docker-saiserver-mrvl.mk b/platform/marvell-arm64/docker-saiserver-mrvl.mk
deleted file mode 100644
index 498f35ffa32..00000000000
--- a/platform/marvell-arm64/docker-saiserver-mrvl.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-# docker image for mrvl saiserver
-
-DOCKER_SAISERVER_MRVL = docker-saiserver-mrvl.gz
-$(DOCKER_SAISERVER_MRVL)_PATH = $(PLATFORM_PATH)/docker-saiserver-mrvl
-$(DOCKER_SAISERVER_MRVL)_DEPENDS += $(SAISERVER)
-$(DOCKER_SAISERVER_MRVL)_LOAD_DOCKERS += $(DOCKER_CONFIG_ENGINE_BULLSEYE)
-SONIC_DOCKER_IMAGES += $(DOCKER_SAISERVER_MRVL)
-
-$(DOCKER_SAISERVER_MRVL)_CONTAINER_NAME = saiserver
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += --privileged -t
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /var/run/docker-saiserver:/var/run/sswsyncd
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc.dep b/platform/marvell-arm64/docker-syncd-mrvl-rpc.dep
deleted file mode 100644
index 3ab0dec8eb5..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-DPATH       := $($(DOCKER_SYNCD_MRVL_RPC)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SYNCD_MRVL_RPC)_CACHE_MODE  := GIT_CONTENT_SHA
-$(DOCKER_SYNCD_MRVL_RPC)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SYNCD_MRVL_RPC)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc.mk b/platform/marvell-arm64/docker-syncd-mrvl-rpc.mk
deleted file mode 100644
index 5879023364e..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc.mk
+++ /dev/null
@@ -1,27 +0,0 @@
-# docker image for mrvl syncd with rpc
-
-DOCKER_SYNCD_MRVL_RPC = docker-syncd-mrvl-rpc.gz
-$(DOCKER_SYNCD_MRVL_RPC)_PATH = $(PLATFORM_PATH)/docker-syncd-mrvl-rpc
-$(DOCKER_SYNCD_MRVL_RPC)_DEPENDS += $(SYNCD_RPC) $(LIBTHRIFT) $(PTF)
-$(DOCKER_SYNCD_MRVL_RPC)_FILES += $(SUPERVISOR_PROC_EXIT_LISTENER_SCRIPT)
-ifeq ($(INSTALL_DEBUG_TOOLS), y)
-$(DOCKER_SYNCD_MRVL_RPC)_DEPENDS += $(SYNCD_RPC_DBG) \
-                                    $(LIBSWSSCOMMON_DBG) \
-                                    $(LIBSAIMETADATA_DBG) \
-                                    $(LIBSAIREDIS_DBG)
-endif
-$(DOCKER_SYNCD_MRVL_RPC)_LOAD_DOCKERS += $(DOCKER_SYNCD_BASE)
-SONIC_DOCKER_IMAGES += $(DOCKER_SYNCD_MRVL_RPC)
-ifeq ($(ENABLE_SYNCD_RPC),y)
-SONIC_INSTALL_DOCKER_IMAGES += $(DOCKER_SYNCD_MRVL_RPC)
-endif
-
-$(DOCKER_SYNCD_MRVL_RPC)_CONTAINER_NAME = syncd
-$(DOCKER_SYNCD_MRVL_RPC)_VERSION = 1.0.0+rpc
-$(DOCKER_SYNCD_MRVL_RPC)_PACKAGE_NAME = syncd
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += --privileged -t
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/warmboot:/var/warmboot
-
-SONIC_BULLSEYE_DOCKERS += $(DOCKER_SYNCD_MRVL_RPC)
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc/99-syncd.conf b/platform/marvell-arm64/docker-syncd-mrvl-rpc/99-syncd.conf
deleted file mode 100644
index 3fabe208d81..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc/99-syncd.conf
+++ /dev/null
@@ -1 +0,0 @@
-sysctl -w net.core.rmem_max=509430500
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
deleted file mode 100644
index 6bd7fb9c7f6..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ /dev/null
@@ -1,56 +0,0 @@
-FROM docker-syncd-mrvl-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
-
-## Make apt-get non-interactive
-ENV DEBIAN_FRONTEND=noninteractive
-
-COPY \
-{% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor -%}
-debs/
-
-RUN apt-get purge -y syncd
-
-## Pre-install the fundamental packages
-RUN apt-get update \
- && apt-get -y install  \
-    net-tools           \
-    python3-pip		\
-    python3-setuptools	\
-    build-essential     \
-    libssl-dev          \
-    libffi-dev          \
-    python-dev          \
-    wget                \
-    cmake               \
-    libqt5core5a        \
-    libqt5network5      \
-    libboost-atomic1.74.0
-
-RUN dpkg_apt() { [ -f $1 ] && { dpkg -i $1 || apt-get -y install -f; } || return 1; } ; \
-{% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
-dpkg_apt debs/{{ deb }}{{'; '}}
-{%- endfor %}
-
-RUN wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
- && tar xvfz 1.0.0.tar.gz \
- && cd nanomsg-1.0.0    \
- && mkdir -p build      \
- && cmake .             \
- && make install        \
- && ldconfig            \
- && cd ..               \
- && rm -fr nanomsg-1.0.0 \
- && rm -f 1.0.0.tar.gz  \
- && pip3 install cffi==1.7.0    \
- && pip3 install --upgrade cffi==1.7.0 \
- && pip3 install nnpy    \
- && mkdir -p /opt       \
- && cd /opt             \
- && wget https://raw.githubusercontent.com/p4lang/ptf/master/ptf_nn/ptf_nn_agent.py \
- && apt-get clean -y; apt-get autoclean -y; apt-get autoremove -y \
- && rm -rf /root/deps
-
-COPY ["ptf_nn_agent.conf", "/etc/supervisor/conf.d/"]
-
-ENTRYPOINT ["/usr/local/bin/supervisord"]
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc/ptf_nn_agent.conf b/platform/marvell-arm64/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
deleted file mode 100644
index fa1ed0eb162..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
+++ /dev/null
@@ -1,10 +0,0 @@
-[program:ptf_nn_agent]
-command=/usr/bin/python /opt/ptf_nn_agent.py --device-socket 1@tcp://0.0.0.0:10900 -i 1-3@Ethernet12 --set-iface-rcv-buffer=109430400
-process_name=ptf_nn_agent
-stdout_logfile=/tmp/ptf_nn_agent.out.log
-stderr_logfile=/tmp/ptf_nn_agent.err.log
-redirect_stderr=false
-autostart=true
-autorestart=true
-startsecs=1
-numprocs=1
diff --git a/platform/marvell-arm64/docker-syncd-mrvl.dep b/platform/marvell-arm64/docker-syncd-mrvl.dep
deleted file mode 100644
index d3f213a2da8..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl.dep
+++ /dev/null
@@ -1,10 +0,0 @@
-DPATH       := $($(DOCKER_SYNCD_BASE)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-syncd-mrvl.mk $(PLATFORM_PATH)/docker-syncd-mrvl.dep $(PLATFORM_PATH)/sai.mk
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SYNCD_BASE)_CACHE_MODE  := GIT_CONTENT_SHA
-$(DOCKER_SYNCD_BASE)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SYNCD_BASE)_DEP_FILES   := $(DEP_FILES)
-
-$(eval $(call add_dbg_docker,$(DOCKER_SYNCD_BASE),$(DOCKER_SYNCD_BASE_DBG)))
diff --git a/platform/marvell-arm64/docker-syncd-mrvl.mk b/platform/marvell-arm64/docker-syncd-mrvl.mk
deleted file mode 100644
index 236f8a437b4..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-# docker image for mrvl syncd
-
-DOCKER_SYNCD_PLATFORM_CODE = mrvl
-include $(PLATFORM_PATH)/../template/docker-syncd-bullseye.mk
-
-$(DOCKER_SYNCD_BASE)_DEPENDS += $(SYNCD)
-
-$(DOCKER_SYNCD_BASE)_DBG_DEPENDS += $(SYNCD_DBG) \
-                                $(LIBSWSSCOMMON_DBG) \
-                                $(LIBSAIMETADATA_DBG) \
-                                $(LIBSAIREDIS_DBG)
-
-$(DOCKER_SYNCD_BASE)_VERSION = 1.0.0
-$(DOCKER_SYNCD_BASE)_PACKAGE_NAME = syncd
-
-#$(DOCKER_SYNCD_BASE)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2 b/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
deleted file mode 100755
index 84e3d5bde2f..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
+++ /dev/null
@@ -1,37 +0,0 @@
-{% from "dockers/dockerfile-macros.j2" import install_debian_packages %}
-FROM docker-config-engine-bullseye-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
-
-ARG docker_container_name
-
-## Make apt-get non-interactive
-ENV DEBIAN_FRONTEND=noninteractive
-
-RUN apt-get update
-
-COPY \
-{% for deb in docker_syncd_mrvl_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor -%}
-debs/
-
-RUN apt-get update \
- && apt-get -y install  \
-    net-tools           \
-    iputils-ping
-
-RUN apt-get -y install libpcap-dev libxml2-dev python-dev swig libsensors4-dev nfs-common
-
-RUN dpkg -i \
-{% for deb in docker_syncd_mrvl_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor %}
-
-COPY ["supervisord.conf", "/etc/supervisor/conf.d/"]
-COPY ["files/supervisor-proc-exit-listener", "/usr/bin/"]
-COPY ["critical_processes", "/etc/supervisor/"]
-
-## Clean up
-RUN apt-get clean -y; apt-get autoclean -y; apt-get autoremove -y
-RUN rm -rf /debs
-
-ENTRYPOINT ["/usr/local/bin/supervisord"]
diff --git a/platform/marvell-arm64/docker-syncd-mrvl/critical_processes b/platform/marvell-arm64/docker-syncd-mrvl/critical_processes
deleted file mode 100644
index bdd6903c569..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl/critical_processes
+++ /dev/null
@@ -1 +0,0 @@
-program:syncd
diff --git a/platform/marvell-arm64/docker-syncd-mrvl/supervisord.conf b/platform/marvell-arm64/docker-syncd-mrvl/supervisord.conf
deleted file mode 100644
index 62a28387248..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl/supervisord.conf
+++ /dev/null
@@ -1,39 +0,0 @@
-[supervisord]
-logfile_maxbytes=1MB
-logfile_backups=2
-nodaemon=true
-
-[eventlistener:dependent-startup]
-command=python3 -m supervisord_dependent_startup
-autostart=true
-autorestart=unexpected
-startretries=0
-exitcodes=0,3
-events=PROCESS_STATE
-buffer_size=1024
-
-[eventlistener:supervisor-proc-exit-listener]
-command=python3 /usr/bin/supervisor-proc-exit-listener --container-name syncd
-events=PROCESS_STATE_EXITED,PROCESS_STATE_RUNNING
-autostart=true
-autorestart=unexpected
-buffer_size=1024
-
-[program:rsyslogd]
-command=/usr/sbin/rsyslogd -n -iNONE
-priority=1
-autostart=false
-autorestart=false
-stdout_logfile=syslog
-stderr_logfile=syslog
-dependent_startup=true
-
-[program:syncd]
-command=/usr/bin/syncd_start.sh
-priority=3
-autostart=false
-autorestart=false
-stdout_logfile=syslog
-stderr_logfile=syslog
-dependent_startup=true
-dependent_startup_wait_for=rsyslogd:running
diff --git a/platform/marvell-arm64/docker-syncd-mrvl/syncd.sh b/platform/marvell-arm64/docker-syncd-mrvl/syncd.sh
deleted file mode 100755
index 993cf100f2f..00000000000
--- a/platform/marvell-arm64/docker-syncd-mrvl/syncd.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/usr/bin/env bash
-
-function clean_up {
-    service syncd stop
-    exit
-}
-
-trap clean_up SIGTERM SIGKILL
-
-service syncd start
-
-read
diff --git a/platform/marvell-arm64/libsaithrift-dev.dep b/platform/marvell-arm64/libsaithrift-dev.dep
deleted file mode 100644
index d7d08f14a31..00000000000
--- a/platform/marvell-arm64/libsaithrift-dev.dep
+++ /dev/null
@@ -1,11 +0,0 @@
-SPATH       := $($(LIBSAITHRIFT_DEV)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/libsaithrift-dev.mk $(PLATFORM_PATH)/libsaithrift-dev.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-SMDEP_PATHS := $(SPATH)  $(SPATH)/bm/behavioral-model  $(SPATH)/test/ptf  $(SPATH)/test/saithrift/ctypesgen
-$(foreach path, $(SMDEP_PATHS), $(eval $(path) :=$(filter-out $(SMDEP_PATHS),$(addprefix $(path)/, $(shell cd $(path) &&  git ls-files | grep -Ev " " )))))
-
-$(LIBSAITHRIFT_DEV)_CACHE_MODE  := GIT_CONTENT_SHA
-$(LIBSAITHRIFT_DEV)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(LIBSAITHRIFT_DEV)_DEP_FILES   := $(DEP_FILES)
-$(LIBSAITHRIFT_DEV)_SMDEP_FILES := $(foreach path, $(SMDEP_PATHS), $($(path)))
-$(LIBSAITHRIFT_DEV)_SMDEP_PATHS := $(SMDEP_PATHS)
diff --git a/platform/marvell-arm64/libsaithrift-dev.mk b/platform/marvell-arm64/libsaithrift-dev.mk
deleted file mode 100644
index e1c3da156ec..00000000000
--- a/platform/marvell-arm64/libsaithrift-dev.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-# libsaithrift-dev package
-
-SAI_VER = 0.9.4
-
-LIBSAITHRIFT_DEV = libsaithrift-dev_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(LIBSAITHRIFT_DEV)_SRC_PATH = $(SRC_PATH)/sonic-sairedis/SAI
-$(LIBSAITHRIFT_DEV)_DEPENDS += $(LIBTHRIFT) $(LIBTHRIFT_DEV) $(PYTHON_THRIFT) $(THRIFT_COMPILER) $(MRVL_FPA) $(MRVL_SAI)
-$(LIBSAITHRIFT_DEV)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
-SONIC_DPKG_DEBS += $(LIBSAITHRIFT_DEV)
-
-PYTHON_SAITHRIFT = python-saithrift_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(PYTHON_SAITHRIFT)))
-
-SAISERVER = saiserver_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(SAISERVER)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER)))
-
-SAISERVER_DBG = saiserver-dbg_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(SAISERVER_DBG)_RDEPENDS += $(SAISERVER)
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER_DBG)))
diff --git a/platform/marvell-arm64/mrvl-prestera b/platform/marvell-arm64/mrvl-prestera
deleted file mode 160000
index 8f9bcdaf584..00000000000
--- a/platform/marvell-arm64/mrvl-prestera
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit 8f9bcdaf58406c71a9038aea834fc8255de59848
diff --git a/platform/marvell-arm64/mrvl-prestera.dep b/platform/marvell-arm64/mrvl-prestera.dep
deleted file mode 100644
index 3ee32c3cbcd..00000000000
--- a/platform/marvell-arm64/mrvl-prestera.dep
+++ /dev/null
@@ -1,9 +0,0 @@
-MPATH       := $($(MRVL_PRESTERA_DEB)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/mrvl-prestera.mk $(PLATFORM_PATH)/mrvl-prestera.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-SMDEP_FILES := $(addprefix $(MPATH)/,$(shell cd $(MPATH) && git ls-files))
-
-$(MRVL_PRESTERA_DEB)_CACHE_MODE  := GIT_CONTENT_SHA
-$(MRVL_PRESTERA_DEB)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(MRVL_PRESTERA_DEB)_DEP_FILES   := $(DEP_FILES)
-$(MRVL_PRESTERA_DEB)_SMDEP_FILES := $(SMDEP_FILES)
diff --git a/platform/marvell-arm64/mrvl-prestera.mk b/platform/marvell-arm64/mrvl-prestera.mk
deleted file mode 100644
index 6a3f4df2a54..00000000000
--- a/platform/marvell-arm64/mrvl-prestera.mk
+++ /dev/null
@@ -1,8 +0,0 @@
-# Marvell Prestera platform package
-export MRVL_PRESTERA_VER = 1.0
-export MRVL_PRESTERA = mrvlprestera_$(MRVL_PRESTERA_VER)_$(PLATFORM_ARCH)
-export MRVL_PRESTERA_DEB = $(MRVL_PRESTERA).deb
-
-$(MRVL_PRESTERA_DEB)_SRC_PATH = $(PLATFORM_PATH)/mrvl-prestera
-$(MRVL_PRESTERA_DEB)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
-SONIC_DPKG_DEBS += $(MRVL_PRESTERA_DEB)
diff --git a/platform/marvell-arm64/one-image.dep b/platform/marvell-arm64/one-image.dep
deleted file mode 100644
index 154112a82ab..00000000000
--- a/platform/marvell-arm64/one-image.dep
+++ /dev/null
@@ -1 +0,0 @@
-$(SONIC_ONE_IMAGE)_CACHE_MODE  := none
diff --git a/platform/marvell-arm64/one-image.mk b/platform/marvell-arm64/one-image.mk
deleted file mode 100644
index 1aa36f2b1dc..00000000000
--- a/platform/marvell-arm64/one-image.mk
+++ /dev/null
@@ -1,17 +0,0 @@
-# sonic marvell one image installer
-
-SONIC_ONE_IMAGE = sonic-marvell-arm64.bin
-$(SONIC_ONE_IMAGE)_MACHINE = marvell-arm64
-$(SONIC_ONE_IMAGE)_IMAGE_TYPE = onie
-$(SONIC_ONE_IMAGE)_INSTALLS += $(SYSTEMD_SONIC_GENERATOR)
-$(SONIC_ONE_IMAGE)_INSTALLS += $(MRVL_PRESTERA_DEB)
-$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(NOKIA_7215_PLATFORM) \
-				$(AC5X_RD98DX35xx_PLATFORM) \
-				$(AC5X_RD98DX35xxCN9131_PLATFORM)
-ifeq ($(INSTALL_DEBUG_TOOLS),y)
-$(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
-$(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
-else
-$(SONIC_ONE_IMAGE)_DOCKERS = $(SONIC_INSTALL_DOCKER_IMAGES)
-endif
-SONIC_INSTALLERS += $(SONIC_ONE_IMAGE)
diff --git a/platform/marvell-arm64/platform-marvell.dep b/platform/marvell-arm64/platform-marvell.dep
deleted file mode 100644
index f906215e3c0..00000000000
--- a/platform/marvell-arm64/platform-marvell.dep
+++ /dev/null
@@ -1,9 +0,0 @@
-MPATH       := $($(AC5X_RD98DX35xx_PLATFORM)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/platform-marvell.dep $(PLATFORM_PATH)/platform-marvell.mk
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-SMDEP_FILES := $(addprefix $(MPATH)/,$(shell cd $(MPATH) && git ls-files))
-
-$(AC5X_RD98DX35xx_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
-$(AC5X_RD98DX35xx_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(AC5X_RD98DX35xx_PLATFORM)_DEP_FILES   := $(DEP_FILES)
-$(AC5X_RD98DX35xx_PLATFORM)_SMDEP_FILES := $(SMDEP_FILES)
diff --git a/platform/marvell-arm64/platform-marvell.mk b/platform/marvell-arm64/platform-marvell.mk
deleted file mode 100644
index 3f2ba3df09f..00000000000
--- a/platform/marvell-arm64/platform-marvell.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-# Marvell Platform modules
-
-AC5X_RD98DX35xx_PLATFORM_MODULE_VERSION = 1.0
-AC5X_RD98DX35xxCN9131_PLATFORM_MODULE_VERSION = 1.0
-
-export AC5X_RD98DX35xx_PLATFORM_MODULE_VERSION
-export AC5X_RD98DX35xxCN9131_PLATFORM_MODULE_VERSION
-
-AC5X_RD98DX35xx_PLATFORM = sonic-platform-rd98dx35xx_$(AC5X_RD98DX35xx_PLATFORM_MODULE_VERSION)_$(CONFIGURED_ARCH).deb
-$(AC5X_RD98DX35xx_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-marvell
-$(AC5X_RD98DX35xx_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
-$(AC5X_RD98DX35xx_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx-r0
-SONIC_DPKG_DEBS += $(AC5X_RD98DX35xx_PLATFORM)
-
-AC5X_RD98DX35xxCN9131_PLATFORM = sonic-platform-rd98dx35xx-cn9131_$(AC5X_RD98DX35xxCN9131_PLATFORM_MODULE_VERSION)_$(CONFIGURED_ARCH).deb
-$(AC5X_RD98DX35xxCN9131_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx_cn9131-r0
-$(eval $(call add_extra_package,$(AC5X_RD98DX35xx_PLATFORM),$(AC5X_RD98DX35xxCN9131_PLATFORM)))
-
diff --git a/platform/marvell-arm64/platform-nokia.dep b/platform/marvell-arm64/platform-nokia.dep
deleted file mode 100644
index 603feb645eb..00000000000
--- a/platform/marvell-arm64/platform-nokia.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-MPATH       := $($(NOKIA_7215_PLATFORM)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/platform-nokia.mk $(PLATFORM_PATH)/platform-nokia.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(MPATH))
-
-$(NOKIA_7215_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
-$(NOKIA_7215_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(NOKIA_7215_PLATFORM)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-arm64/platform-nokia.mk b/platform/marvell-arm64/platform-nokia.mk
deleted file mode 100644
index 7d89c1190ec..00000000000
--- a/platform/marvell-arm64/platform-nokia.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-# Nokia Platform
-
-NOKIA_7215_PLATFORM_VERSION = 1.0
-export NOKIA_7215_PLATFORM_VERSION
-SONIC_KERNEL_DEB_PKG = $(LINUX_KERNEL)
-export SONIC_KERNEL_DEB_PKG
-
-NOKIA_7215_PLATFORM = sonic-platform-nokia-7215_$(NOKIA_7215_PLATFORM_VERSION)_$(CONFIGURED_ARCH).deb
-$(NOKIA_7215_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-nokia
-$(NOKIA_7215_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
-$(NOKIA_7215_PLATFORM)_PLATFORM = arm64-nokia_ixs7215_52xb-r0
-
-MPATH       := $($(NOKIA_7215_PLATFORM)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-arm64/platform-nokia.mk
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(MPATH))
-
-$(NOKIA_7215_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA
-$(NOKIA_7215_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(NOKIA_7215_PLATFORM)_DEP_FILES   := $(DEP_FILES)
-
-SONIC_DPKG_DEBS += $(NOKIA_7215_PLATFORM)
-
diff --git a/platform/marvell-arm64/platform.conf b/platform/marvell-arm64/platform.conf
deleted file mode 100644
index 6332c9178f8..00000000000
--- a/platform/marvell-arm64/platform.conf
+++ /dev/null
@@ -1,248 +0,0 @@
-#  Copyright (C) Marvell Inc
-
-# over ride default behaviour
-
-echo "Preparing for installation ... "
-
-# global defines
-VAR_LOG=512
-UBOOT_FW_DEFAULT=1
-
-kernel_addr=0x1100000
-kernel_version=6.1.0-11-2-arm64
-kernel_fname="/boot/vmlinuz-$kernel_version"
-initrd_fname="/boot/initrd.img-$kernel_version"
-fit_fname="/boot/sonic_arm64.fit"
-demo_volume_label=SONiC-OS
-
-# global mount defines
-demo_mnt=/tmp
-
-if [ "$install_env" = "onie" ]; then
-    MACH_FILE="/etc/machine.conf"
-else
-    MACH_FILE="/host/machine.conf"
-fi
-
-PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
-echo "Intalling SONiC from $install_env on Platform $PLATFORM"
-
-PLATFORM_AC5X=0
-PLATFORM_CN9131=0
-
-case $PLATFORM in
-    arm64-nokia_ixs7215_52xb-r0) PLATFORM_7215_A1=1;
-		fdt_fname="/usr/lib/linux-image-${kernel_version}/marvell/7215-ixs-a1.dtb";
-		fit_conf_name="#conf_7215_a1";;
-    arm64-marvell_rd98DX35xx-r0) PLATFORM_AC5X=1;
-		fdt_fname="/usr/lib/linux-image-$kernel_version/marvell/ac5-98dx35xx-rd.dtb";
-		fit_conf_name="#conf_ac5x";;
-    arm64-marvell_rd98DX35xx_cn9131-r0) PLATFORM_CN9131=1;
-		fdt_fname="/boot/cn9131-db-comexpress.dtb";
-		fit_conf_name="#conf_cn9131";;
-esac
-
-if [ $PLATFORM_AC5X -eq 1 ]; then
-    fdt_addr=0x201000000
-    fit_addr=0x210000000
-    initrd_addr=0x206000000
-
-    FW_ENV_DEFAULT='/dev/mtd0 0x400000 0x10000 0x10000'
-    demo_part=2
-    mmc_bus="mmc0:0001"
-elif [ $PLATFORM_7215_A1 -eq 1 ]; then
-    fit_addr=0x20000000
-    VAR_LOG=4096
-    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x10000'
-    demo_part=2
-    mmc_bus="mmc0:0001"
-elif [ $PLATFORM_CN9131 -eq 1 ]; then
-    fdt_addr=0x1000000
-    fit_addr=0x8000000
-    initrd_addr=0x2000000
-    demo_part=2
-    FW_ENV_DEFAULT='/dev/mtd1 0x1F0000 0x10000 0x10000'
-    mmc_bus="mmc0:0001"
-else
-    fdt_addr=0x1000000
-    fit_addr=0x8000000
-    initrd_addr=0x2000000
-
-    fdt_fname="/usr/lib/linux-image-$kernel_version/marvell/armada-7020-comexpress.dtb"
-
-    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x100000'
-    demo_part=1
-    mmc_bus="mmc0:aaaa"
-fi
-
-# Skip VID Header in UBIFS
-LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
-
-#Get block device
-#Default block device is eMMC, if not look for usb storage
-get_install_device()
-{
-    for i in 0 1 2 ; do
-        if $(ls -l /sys/block/mmcblk$i/device 2>/dev/null | grep -q "$mmc_bus") ; then
-            echo "/dev/mmcblk$i"
-            blk_dev=/dev/mmcblk$i
-            echo "Selected mmc $blk_dev"
-            return 0
-        fi
-    done
-
-    echo "ERROR storage not found"
-    return 1
-}
-
-get_install_device
-if [ $? -ne 0 ]; then
-    echo "Error: Unable to detect $blk_dev $demo_dev"
-    exit 1
-fi
-
-demo_dev=${blk_dev}p${demo_part}
-
-remove_dev_partitions() {
-    echo "Remove all existing partitions starting partnum: ${demo_part} from ${blk_dev}"
-    local dev_to_install=${blk_dev}p
-    for p in $(seq ${demo_part} 9) ; do
-        if [[ -e ${dev_to_install}${p} ]]; then
-            echo "Removing partition ${dev_to_install}${p}"
-            sgdisk -d ${p} ${blk_dev} || true
-        fi
-    done
-    partprobe ${blk_dev}
-}
-
-create_demo_partition() {
-    # SD CARD
-    remove_dev_partitions
-
-    # Create sonic partition
-    sgdisk --new ${demo_part}:: \
-        --change-name=${demo_part}:${demo_volume_label} \
-        --typecode=${demo_part}:8300 -p ${blk_dev}
-
-    partprobe
-}
-
-create_partition() {
-    get_install_device
-    if [ $? -ne 0 ]; then
-        echo "Error: Unable to detect $blk_dev $demo_dev"
-        exit 1
-    fi
-
-    # Platform specific partition 
-    create_demo_partition
-}
-
-mount_partition() {
-    # Make filesystem
-    echo "demo label: $demo_volume_label. $demo_dev..."
-    mkfs.ext4 -L $demo_volume_label $demo_dev
-
-    mount -t ext4 -o defaults,rw $demo_dev $demo_mnt || {
-        echo "Error: Unable to mount $demo_dev on $demo_mnt"
-        exit 1
-    }
-}
-
-prepare_boot_menu() {
-    echo "Sync up cache ..."
-    sync
-    echo "Setting up U-Boot environment..."
-
-    DTB_HAS_ENV_BLK=$(grep uboot-env /proc/mtd | sed -e 's/:.*$//')
-    if [ -c "/dev/$DTB_HAS_ENV_BLK" ]; then
-        PROC_ENV_FILE=$(find /proc/device-tree/ -name env_size)
-        if [ -n "$PROC_ENV_FILE" ]
-        then
-            UBOOT_ENV_SIZ="0x$(hd $PROC_ENV_FILE | awk 'FNR==1 {print $2 $3 $4 $5}')"
-            UBOOT_ENV_ERASE_SIZ="0x$(grep uboot-env /proc/mtd | awk '{print $3}')"
-            if [[ -n "$UBOOT_ENV_SIZ" && -n "$UBOOT_ENV_ERASE_SIZ" ]]
-            then
-                # Env info from DTB 
-                FW_ENV_DTB="/dev/$DTB_HAS_ENV_BLK 0x00000000 $UBOOT_ENV_SIZ $UBOOT_ENV_ERASE_SIZ"
-            fi
-        fi
-    fi
-    if [ $UBOOT_FW_DEFAULT -eq 1 ]
-    then
-        echo $FW_ENV_DEFAULT > /etc/fw_env.config
-        echo "Using pre-configured uboot env"
-    fi
-    image_name=${image_dir}${kernel_fname}
-    initrd_name=${image_dir}${initrd_fname}
-    fdt_name=${image_dir}${fdt_fname}
-    fit_name=${image_dir}${fit_fname}
-
-    if [ "$install_env" = "onie" ]; then
-        FW_ARG="-f"
-        image_dir_old=""
-        image_name_old=""
-        initrd_name_old=""
-        fdt_name_old=""
-        fit_name_old=""
-        sonic_version_2="None"
-    else
-        image_dir_old=$(fw_printenv -n image_dir || true)
-        image_name_old=$(fw_printenv -n image_name || true)
-        initrd_name_old=$(fw_printenv -n initrd_name || true)
-        fdt_name_old=$(fw_printenv -n fdt_name || true)
-        fit_name_old=$(fw_printenv -n fit_name || true)
-        sonic_version_2=$(fw_printenv -n sonic_version_1 || true)
-    fi
-
-    # Set boot variables
-    fw_setenv ${FW_ARG} image_dir $image_dir > /dev/null
-    fw_setenv ${FW_ARG} image_name $image_name > /dev/null
-    fw_setenv ${FW_ARG} initrd_name $initrd_name > /dev/null
-    fw_setenv ${FW_ARG} fdt_name $fdt_name > /dev/null
-    fw_setenv ${FW_ARG} fit_name $fit_name > /dev/null
-    fw_setenv ${FW_ARG} sonic_version_1 $demo_volume_revision_label > /dev/null
-    fw_setenv ${FW_ARG} image_dir_old $image_dir_old > /dev/null
-    fw_setenv ${FW_ARG} image_name_old $image_name_old > /dev/null
-    fw_setenv ${FW_ARG} initrd_name_old $initrd_name_old > /dev/null
-    fw_setenv ${FW_ARG} fdt_name_old $fdt_name_old > /dev/null
-    fw_setenv ${FW_ARG} fit_name_old $fit_name_old > /dev/null
-    fw_setenv ${FW_ARG} sonic_version_2 $sonic_version_2 > /dev/null
-    BOOT1='echo " > Boot1: $sonic_version_1 - run sonic_image_1";echo;'
-    BOOT2='echo " > Boot2: $sonic_version_2 - run sonic_image_2";echo;'
-    BOOT3='echo " > Boot3: ONIE - run onie_boot";echo;'
-    BORDER='echo "---------------------------------------------------";echo;'
-    fw_setenv ${FW_ARG} print_menu $BORDER $BOOT1 $BOOT2 $BOOT3 $BORDER > /dev/null
-
-    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG ${ONIE_PLATFORM_EXTRA_CMDLINE_LINUX}" > /dev/null
-    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG ${ONIE_PLATFORM_EXTRA_CMDLINE_LINUX}" > /dev/null
-    sonic_bootargs_old='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs_old}'
-    fw_setenv ${FW_ARG} sonic_bootargs_old $sonic_bootargs_old > /dev/null || true
-    sonic_boot_load_old=$(fw_printenv -n sonic_boot_load || true)
-    old_str="_old"
-    fw_setenv ${FW_ARG} sonic_boot_load_old "$sonic_boot_load_old$old_str" > /dev/null || true
-
-    fw_setenv ${FW_ARG} kernel_addr $kernel_addr > /dev/null
-    fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
-    fw_setenv ${FW_ARG} fit_addr $fit_addr > /dev/null
-    fw_setenv ${FW_ARG} fit_conf_name $fit_conf_name > /dev/null
-    fw_setenv ${FW_ARG} initrd_addr $initrd_addr > /dev/null
-    MMC_LOAD='ext4load mmc 0:'$demo_part' $fit_addr $fit_name'
-    fw_setenv ${FW_ARG} sonic_boot_load "$MMC_LOAD" > /dev/null
-    SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr${fit_conf_name}'
-    SONIC_BOOT_CMD_OLD='run sonic_bootargs_old; run sonic_boot_load_old; bootm $fit_addr${fit_conf_name}'
-    BOOTARGS='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs}'
-    fw_setenv ${FW_ARG} sonic_bootargs $BOOTARGS > /dev/null
-    fw_setenv ${FW_ARG} sonic_bootcmd $SONIC_BOOT_CMD > /dev/null
-    fw_setenv ${FW_ARG} sonic_image_2 $SONIC_BOOT_CMD_OLD > /dev/null
-    fw_setenv ${FW_ARG} sonic_image_1 "$SONIC_BOOT_CMD" > /dev/null
-    fw_setenv ${FW_ARG} boot_next  'run sonic_image_1'> /dev/null
-    fw_setenv ${FW_ARG} bootcmd 'run print_menu; usb start; test -n "$boot_once" && run boot_once; run boot_next' > /dev/null
-
-}
-
-bootloader_menu_config() {
-    # Update uboot Environment
-    prepare_boot_menu
-}
-
diff --git a/platform/marvell-arm64/rules.dep b/platform/marvell-arm64/rules.dep
deleted file mode 100644
index b14b76ef03d..00000000000
--- a/platform/marvell-arm64/rules.dep
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(PLATFORM_PATH)/docker-saiserver-mrvl.dep
-include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep
-include $(PLATFORM_PATH)/docker-syncd-mrvl.dep
-include $(PLATFORM_PATH)/libsaithrift-dev.dep
-include $(PLATFORM_PATH)/mrvl-prestera.dep
-include $(PLATFORM_PATH)/one-image.dep
-include $(PLATFORM_PATH)/platform-marvell.dep
-include $(PLATFORM_PATH)/platform-nokia.dep
-include $(PLATFORM_PATH)/sai.dep
diff --git a/platform/marvell-arm64/rules.mk b/platform/marvell-arm64/rules.mk
deleted file mode 100644
index 882a9451e99..00000000000
--- a/platform/marvell-arm64/rules.mk
+++ /dev/null
@@ -1,26 +0,0 @@
-#include $(PLATFORM_PATH)/sdk.mk
-include $(PLATFORM_PATH)/sai.mk
-include $(PLATFORM_PATH)/docker-syncd-mrvl.mk
-include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk
-include $(PLATFORM_PATH)/docker-saiserver-mrvl.mk
-include $(PLATFORM_PATH)/libsaithrift-dev.mk
-include $(PLATFORM_PATH)/one-image.mk
-include $(PLATFORM_PATH)/mrvl-prestera.mk
-include $(PLATFORM_PATH)/platform-nokia.mk
-include $(PLATFORM_PATH)/platform-marvell.mk
-
-SONIC_ALL += $(SONIC_ONE_IMAGE) \
-             $(DOCKER_FPM) 	\
-             $(DOCKER_PTF_MRVL) \
-             $(DOCKER_SYNCD_MRVL_RPC)
-
-# Inject mrvl sai into syncd
-$(SYNCD)_DEPENDS += $(MRVL_SAI)
-$(SYNCD)_UNINSTALLS += $(MRVL_SAI)
-
-ifeq ($(ENABLE_SYNCD_RPC),y)
-$(SYNCD)_DEPENDS += $(LIBSAITHRIFT_DEV)
-endif
-
-# Runtime dependency on mrvl sai is set only for syncd
-$(SYNCD)_RDEPENDS += $(MRVL_SAI)
diff --git a/platform/marvell-arm64/sai.dep b/platform/marvell-arm64/sai.dep
deleted file mode 100644
index 618babe65ac..00000000000
--- a/platform/marvell-arm64/sai.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-SPATH       := $($(MRVL_SAI)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/sai.mk $(PLATFORM_PATH)/sai.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(SPATH))
-
-$(MRVL_SAI)_CACHE_MODE  := GIT_CONTENT_SHA
-$(MRVL_SAI)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(MRVL_SAI)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-arm64/sai.mk b/platform/marvell-arm64/sai.mk
deleted file mode 100644
index fe4f91b8393..00000000000
--- a/platform/marvell-arm64/sai.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-# Marvell SAI
-
-export MRVL_SAI_VERSION = 1.12.0-2
-export MRVL_SAI = mrvllibsai_$(MRVL_SAI_VERSION)_$(PLATFORM_ARCH).deb
-
-$(MRVL_SAI)_SRC_PATH = $(PLATFORM_PATH)/sai
-$(eval $(call add_conflict_package,$(MRVL_SAI),$(LIBSAIVS_DEV)))
-
-SONIC_MAKE_DEBS += $(MRVL_SAI)
diff --git a/platform/marvell-arm64/sai/Makefile b/platform/marvell-arm64/sai/Makefile
deleted file mode 100644
index 07048e0141e..00000000000
--- a/platform/marvell-arm64/sai/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-.ONESHELL:
-SHELL = /bin/bash
-.SHELLFLAGS += -e
-
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/sai-plugin/$(MRVL_SAI)
-
-$(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
-	# get deb package
-	wget -O $(DEST)/$(MRVL_SAI) $(MRVL_SAI_URL) || rm -f $(DEST)/$(MRVL_SAI)
diff --git a/platform/marvell-arm64/sonic-platform-marvell b/platform/marvell-arm64/sonic-platform-marvell
deleted file mode 160000
index f6b5e6cc8f3..00000000000
--- a/platform/marvell-arm64/sonic-platform-marvell
+++ /dev/null
@@ -1 +0,0 @@
-Subproject commit f6b5e6cc8f382275e9d1647321ecd27e87038b90
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/Makefile b/platform/marvell-arm64/sonic-platform-nokia/7215/modules/Makefile
deleted file mode 100644
index d82a871c1cc..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-m:= nokia_7215_ixs_a1_cpld.o cn9130_cpu_thermal_sensor.o
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/cn9130_cpu_thermal_sensor.c b/platform/marvell-arm64/sonic-platform-nokia/7215/modules/cn9130_cpu_thermal_sensor.c
deleted file mode 100644
index e11e281579f..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/cn9130_cpu_thermal_sensor.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- * HWMON Driver for CN9130 thermal sensor
- *
- * Author: Natarajan Subbiramani <nataraja.subbiramani.ext@nokia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/miscdevice.h>
-#include <linux/hwmon.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-
-#define CN9130_DEFAULT_TEMP_CRIT 100000
-#define CN9130_DEFAULT_TEMP_MAX  106000
-
-#define CN9130_TEMP_BASE_ADDR 0xF06F8080
-#define CN9130_TSEN_REG_CTRL_0_OFFSET 0x4
-#define CN9130_TSEN_REG_CTRL_1_OFFSET 0x8
-#define CN9130_TSEN_REG_STATUS_OFFSET 0xC
-#define CN9130_TSEN_SENSOR_MAX_ID 6
-static unsigned long thermal_base_addr=CN9130_TEMP_BASE_ADDR;
-module_param(thermal_base_addr, ulong, 0444);
-MODULE_PARM_DESC(thermal_base_addr,
-        "Initialize the base address of the thermal sensor");
-
-struct cn9130_thermal_data {
-    struct device *dev;
-    struct device *hwmon_dev;
-    uint8_t * __iomem temp_base;
-    int temp_input;
-    int temp_crit;
-    int temp_max;
-};
-
-static long cn9130_thermal_read_reg_in_mcelcius(struct device *dev, struct cn9130_thermal_data *data)
-{
-    volatile uint8_t * __iomem temp_base = data->temp_base;
-    uint32_t regval;
-    uint32_t status_regval=0;
-    uint32_t output=data->temp_max;
-
-    //STOP MEASUREMENT
-    regval = readl(temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-    regval &= ~( 1 << 0); //TSEN_STOP
-    writel(regval, temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-
-    //delay for 1ms
-    mdelay(1);
-
-    //Read thermal value
-    status_regval = readl(temp_base+CN9130_TSEN_REG_STATUS_OFFSET);
-    dev_dbg(dev, "%s: cn9130_thermal_read_reg_in_mcelcius: addr: 0x%lx value:0x%x\n", dev_name(data->hwmon_dev), temp_base+CN9130_TSEN_REG_STATUS_OFFSET, status_regval);
-
-    //START MEASUREMENT
-    regval = readl(temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-    regval |= 1 << 0; //TSEN_START
-    writel(regval, temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-
-    //Validate data
-    if(status_regval &= 0x3ff) {
-        //Convert it to milli-celcius
-        output = 150000 - (~(status_regval-1) & 0x3ff) * 423;
-    }
-
-    return output;
-}
-static int cn9130_thermal_read(struct device *dev, enum hwmon_sensor_types type,
-        u32 attr, int channel, long *val)
-{
-    struct cn9130_thermal_data *data = dev_get_drvdata(dev);
-
-    switch (type) {
-        case hwmon_temp:
-            switch (attr) {
-                case hwmon_temp_input:
-                    *val = cn9130_thermal_read_reg_in_mcelcius(dev, data);
-                    break;
-                case hwmon_temp_crit:
-                    *val = data->temp_crit;
-                    break;
-                case hwmon_temp_max:
-                    *val = data->temp_max;
-                    break;
-                default:
-                    return -EINVAL;
-            }
-            break;
-        default:
-            return -EINVAL;
-    }
-    return 0;
-}
-
-static int cn9130_thermal_write(struct device *dev, enum hwmon_sensor_types type,
-        u32 attr, int channel, long val)
-{
-    struct cn9130_thermal_data *data = dev_get_drvdata(dev);
-    switch (type) {
-        case hwmon_temp:
-            switch (attr) {
-                case hwmon_temp_crit:
-                    data->temp_crit = val;
-                    break;
-                case hwmon_temp_max:
-                    data->temp_max = val;
-                    break;
-                default:
-                    return -EINVAL;
-            }
-            break;
-        default:
-            return -EINVAL;
-    }
-    return 0;
-}
-
-
-static umode_t cn9130_thermal_is_visible(const void *data, enum hwmon_sensor_types type,
-        u32 attr, int channel)
-{
-    switch (type) {
-        case hwmon_temp:
-            switch (attr) {
-                case hwmon_temp_input:
-                    return 0444;
-                case hwmon_temp_crit:
-                case hwmon_temp_max:
-                    return 0644;
-            }
-            break;
-        default:
-            break;
-    }
-    return 0;
-}
-
-static const struct hwmon_channel_info *cn9130_thermal_info[] = {
-    HWMON_CHANNEL_INFO(temp,
-            HWMON_T_INPUT | HWMON_T_MAX | HWMON_T_CRIT),
-    NULL
-};
-
-static const struct hwmon_ops cn9130_thermal_hwmon_ops = {
-    .is_visible = cn9130_thermal_is_visible,
-    .read = cn9130_thermal_read,
-    .write = cn9130_thermal_write,
-};
-
-static const struct hwmon_chip_info cn9130_thermal_chip_info = {
-    .ops = &cn9130_thermal_hwmon_ops,
-    .info = cn9130_thermal_info,
-};
-
-static const struct file_operations fops = {
-    .owner          = THIS_MODULE,
-};
-
-struct miscdevice cn9130_thermal_device = {
-    .minor = TEMP_MINOR,
-    .name = "cn9130_thermal",
-    .fops = &fops,
-};
-
-static int __init cn9130_thermal_init_driver(void)
-{
-    struct device *dev;
-    struct cn9130_thermal_data *thermal_data;
-    int err;
-    void * __iomem reg;
-    uint32_t regval=0;
-
-    err = misc_register(&cn9130_thermal_device);
-    if (err) {
-        pr_err("cn9130_thermal misc_register failed!!!\n");
-        return err;
-    }
-
-    dev = cn9130_thermal_device.this_device;
-    thermal_data = devm_kzalloc(dev, sizeof(struct cn9130_thermal_data), GFP_KERNEL);
-    if (!thermal_data)
-        return -ENOMEM;
-
-    thermal_data->dev = dev;
-    thermal_data->temp_crit  = CN9130_DEFAULT_TEMP_CRIT;
-    thermal_data->temp_max   = CN9130_DEFAULT_TEMP_MAX;
-
-    thermal_data->hwmon_dev = devm_hwmon_device_register_with_info(dev, cn9130_thermal_device.name,
-            thermal_data, &cn9130_thermal_chip_info,
-            NULL);
-    if (IS_ERR(thermal_data->hwmon_dev)) {
-        dev_err(dev, "%s: hwmon registration failed.\n", cn9130_thermal_device.name);
-        return PTR_ERR(thermal_data->hwmon_dev);
-    }
-
-    reg = devm_ioremap(dev, thermal_base_addr, 16);
-    if (IS_ERR(reg)) {
-        dev_err(dev, "%s: base addr remap failed\n", cn9130_thermal_device.name);
-        return PTR_ERR(reg);
-    }
-    thermal_data->temp_base = reg;
-
-    /*Enable measurement*/
-    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-    regval |= 1 << 2; //TSEN_EN
-    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-    mdelay(10);
-
-    // Set temperature reading zone as max reading
-    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_1_OFFSET);
-    regval &= ~(0x7 << 21);
-    regval |= (CN9130_TSEN_SENSOR_MAX_ID & 0x7) << 21;
-    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_1_OFFSET);
-
-    //START MEASUREMENT
-    regval = readl(thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-    regval |= 1 << 0; //TSEN_START
-    writel(regval, thermal_data->temp_base+CN9130_TSEN_REG_CTRL_0_OFFSET);
-
-    dev_info(dev, "%s: initialized. base_addr: 0x%lx virt_addr:0x%lx\n", dev_name(thermal_data->hwmon_dev), thermal_base_addr, thermal_data->temp_base);
-
-    return 0;
-}
-
-static void __exit cn9101_thermal_exit_driver(void)
-{
-    misc_deregister(&cn9130_thermal_device);
-}
-
-module_init(cn9130_thermal_init_driver);
-module_exit(cn9101_thermal_exit_driver);
-
-MODULE_AUTHOR("Natarajan Subbiramani <natarajan.subbiramani.ext@nokia.com>");
-MODULE_DESCRIPTION("CN9130 CPU Thermal sensor Driver");
-MODULE_LICENSE("GPL");
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/nokia_7215_ixs_a1_cpld.c b/platform/marvell-arm64/sonic-platform-nokia/7215/modules/nokia_7215_ixs_a1_cpld.c
deleted file mode 100644
index 3c063977026..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/modules/nokia_7215_ixs_a1_cpld.c
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * CPLD driver for Nokia-7215-IXS-A1 Router
- *
- * Copyright (C) 2023 Nokia Corporation.
- * Natarajan Subbiramani <natarajan.subbiramani.ext@nokia.com>
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * see <http://www.gnu.org/licenses/>
- *
- * Based on ad7414.c
- * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/i2c.h>
-#include <linux/kernel.h>
-#include <linux/err.h>
-#include <linux/hwmon.h>
-#include <linux/hwmon-sysfs.h>
-#include <linux/of_device.h>
-#include <linux/of.h>
-#include <linux/mutex.h>
-
-#define DRIVER_NAME "nokia_7215_a1_cpld"
-
-// REG ADDRESS-MAP
-#define BOARD_ID_REG                  0x00
-#define RESET_CAUSE_REG               0x01
-#define CPLD_VERSION_REG              0x02
-#define SFP_PRESENCE_REG              0x03
-#define SFP_LOS_REG                   0x04
-#define SFP_TX_DISABLE_REG            0x05
-#define MAC_INIT_STATUS_REG           0x06
-#define SYSTEM_STATUS_LED_CONTROL_REG 0x07
-#define POWER_AND_FAN_LED_CONTROL_REG 0x08
-#define SFP_TX_FAULT_STATUS_REG       0x09
-#define TEMP_EVENT_STATUS_REG         0x0D
-#define TEMP_EVENT_MASK_REG           0x0E 
-#define SFP_LED_TEST_REG              0x0F
-#define RESET_REG                     0x10
-#define MISC_IRQ_LIVE_STATE_REG       0x12
-#define INTERRUPT_REG                 0x13
-#define INTERRUPT_MASK_REG            0x14
-#define MISC_INT_STATUS_REG           0x16
-#define MISC_INT_MASK_REG             0x18
-#define GPIO_DIRECTION_REG            0x19
-#define GPIO_DATA_IN_REG              0x1A
-#define GPIO_DATA_OUT_REG             0x1B
-#define SCRATCH_REG                   0xFE
-
-//REG BIT FIELD POSITIONS
-#define RESET_CAUSE_REG_COLD_RESET    0x1
-#define RESET_CAUSE_REG_WARM_RESET    0x2
-#define RESET_CAUSE_REG_WDOG_RESET    0x4
-#define RESET_CAUSE_REG_SYS_RESET     0x8
-#define RESET_CAUSE_REG_THERMAL_OL    0x10
-
-#define SFP_PRESENCE_REG_SFP49        0x0
-#define SFP_PRESENCE_REG_SFP50        0x1
-#define SFP_PRESENCE_REG_SFP51        0x2
-#define SFP_PRESENCE_REG_SFP52        0x3
-
-#define SFP_LOS_REG_SFP49             0x0
-#define SFP_LOS_REG_SFP50             0x1
-#define SFP_LOS_REG_SFP51             0x2
-#define SFP_LOS_REG_SFP52             0x3
-
-#define SFP_TX_DISABLE_REG_SFP49      0x0
-#define SFP_TX_DISABLE_REG_SFP50      0x1
-#define SFP_TX_DISABLE_REG_SFP51      0x2
-#define SFP_TX_DISABLE_REG_SFP52      0x3
-#define SFP_TX_DISABLE_REG_LED_MUX    0x4
-
-#define TS1_ALERT_EVENT               0x2
-#define TS2_ALERT_EVENT               0x4
-#define TS3_ALERT_EVENT               0x8
-#define CPU_TEMP_EVENT                0x10
-#define AC5X_HIGHTEMP_EVENT           0x20  
-#define DIMM_TEMP_EVENT               0x40     
-
-#define MAC_INIT_STATUS_REG_INIT_DONE 0x2
-
-enum system_status_led_mode {
-    SYSTEM_STATUS_LED_OFF,
-    SYSTEM_STATUS_LED_AMBER,
-    SYSTEM_STATUS_LED_GREEN,
-    SYSTEM_STATUS_LED_AMBERBLINK8,
-    SYSTEM_STATUS_LED_GREENBLINK4,
-    SYSTEM_STATUS_LED_AMBERBLINK4,
-    SYSTEM_STATUS_LED_GREENBLINK1,
-    SYSTEM_STATUS_LED_COLORTOGGLE,
-    SYSTEM_STATUS_LED_INVALID
-};
-
-char *system_status_led_mode_str[]={"off", "amber", "green", "blink8-amber", "blink4-green",
-                                    "blink4-amber", "blink1-green", "toggle", "invalid"};
-
-#define POWER_LED_OFFSET  6
-#define FAN_LED_OFFSET    4
-enum power_fan_led_mode {
-    POWER_FAN_LED_OFF,
-    POWER_FAN_LED_GREEN,
-    POWER_FAN_LED_AMBER,
-    POWER_FAN_LED_GREEN_BLINK,
-    POWER_FAN_INVALID
-};
-char *power_fan_led_mode_str[]={"off", "green", "amber", "blink-green", "invalid"};
-
-#define SFP_TX_FAULT_STATUS_SFP49  0x0
-#define SFP_TX_FAULT_STATUS_SFP50  0x1
-#define SFP_TX_FAULT_STATUS_SFP51  0x2
-#define SFP_TX_FAULT_STATUS_SFP52  0x3
-
-#define RESET_REG_WARM_RESET   0x0
-#define RESET_REG_COLD_RESET   0x4
-#define RESET_REG_I2CMUX_RESET 0x6
-#define RESET_REG_ZL_RESET     0x7
-
-static const unsigned short cpld_address_list[] = {0x41, I2C_CLIENT_END};
-
-struct cpld_data {
-    struct i2c_client *client;
-    struct mutex  update_lock;
-    int mb_hw_version;
-    int cpld_version;
-};
-
-static int nokia_7215_ixs_a1_cpld_read(struct cpld_data *data, u8 reg)
-{
-    int val=0;
-    struct i2c_client *client=data->client;
-
-    mutex_lock(&data->update_lock);
-    val = i2c_smbus_read_byte_data(client, reg);
-    if (val < 0) {
-         dev_err(&client->dev, "CPLD READ ERROR: reg(0x%02x) err %d\n", reg, val);
-    }
-    mutex_unlock(&data->update_lock);
-
-    return val;
-}
-
-static void nokia_7215_ixs_a1_cpld_write(struct cpld_data *data, u8 reg, u8 value)
-{
-    int res=0;
-    struct i2c_client *client=data->client;
-
-    mutex_lock(&data->update_lock);
-    res = i2c_smbus_write_byte_data(client, reg, value);
-    if (res < 0) {
-        dev_err(&client->dev, "CPLD WRITE ERROR: reg(0x%02x) err %d\n", reg, res);
-    }
-    mutex_unlock(&data->update_lock);
-}
-
-static ssize_t show_mainboard_hwversion(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    return sprintf(buf,"0x%02x\n",data->mb_hw_version);
-}
-
-static ssize_t show_last_reset_cause(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 val=0;
-    char *reason=NULL;
-    val = nokia_7215_ixs_a1_cpld_read(data, RESET_CAUSE_REG);
-    switch (val) {
-    case RESET_CAUSE_REG_COLD_RESET:
-        reason="cold_reset";
-        break;
-    case RESET_CAUSE_REG_WARM_RESET:
-        reason="warm_reset";
-        break;
-    case RESET_CAUSE_REG_WDOG_RESET:
-        reason="wdog_reset";
-        break;
-    case RESET_CAUSE_REG_SYS_RESET:
-        reason="sys_reset";
-        break;
-    case RESET_CAUSE_REG_THERMAL_OL:
-        reason="thermal_reset";
-        break;
-        
-    default:
-        reason="unknown";
-        break;
-    }
-    return sprintf(buf,"%s\n",reason);
-}
-
-static ssize_t show_cpld_version(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    return sprintf(buf,"0x%02x\n",data->cpld_version);
-}
-
-static ssize_t show_sfp_present(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, SFP_PRESENCE_REG);
-    
-    /* If the bit is set, SFP is not present. So, we are toggling intentionally */
-    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 0:1);
-}
-
-static ssize_t show_sfp_los(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, SFP_LOS_REG);
-    
-    /* If the bit is set, LOS condition */
-    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
-}
-
-static ssize_t show_sfp_tx_disable(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_DISABLE_REG);
-    
-    /* If the bit is set, Tx is disabled */
-    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
-}
-
-static ssize_t set_sfp_tx_disable(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 reg_val=0, usr_val=0, mask;
-    int ret=kstrtou8(buf,10, &usr_val);
-    if (ret != 0) {
-        return ret; 
-    }
-    if (usr_val > 1) {
-        return -EINVAL;
-    }
-
-    mask = (~(1 << sda->index)) & 0xFF;
-    reg_val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_DISABLE_REG);
-    reg_val = reg_val & mask;
-
-    usr_val = usr_val << sda->index;
-
-    nokia_7215_ixs_a1_cpld_write(data, SFP_TX_DISABLE_REG, (reg_val|usr_val));
-
-    return count;
-
-}
-
-static ssize_t show_system_led_status(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, SYSTEM_STATUS_LED_CONTROL_REG);
-    if (val > SYSTEM_STATUS_LED_INVALID) {
-        val = SYSTEM_STATUS_LED_INVALID;
-    }
-    return sprintf(buf,"%s\n",system_status_led_mode_str[val]);
-}
-
-static ssize_t set_system_led_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    int mode;
-
-    for(mode=SYSTEM_STATUS_LED_OFF; mode<SYSTEM_STATUS_LED_INVALID; mode++) {
-        if(strncmp(buf, system_status_led_mode_str[mode],strlen(system_status_led_mode_str[mode]))==0) {
-            nokia_7215_ixs_a1_cpld_write(data, SYSTEM_STATUS_LED_CONTROL_REG, mode);
-            break;
-        }
-    }
-
-    return count;
-}
-
-static ssize_t show_power_fan_led_status(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val = nokia_7215_ixs_a1_cpld_read(data, POWER_AND_FAN_LED_CONTROL_REG);
-    val = (val >> sda->index) & 0x3;
-    return sprintf(buf,"%s\n",power_fan_led_mode_str[val]);
-}
-
-static ssize_t set_power_fan_led_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 reg_val=0, mask=0, usr_val=0;
-    int i;
-
-    mask = (~(0x3 << sda->index)) & 0xFF;
-    reg_val = nokia_7215_ixs_a1_cpld_read(data, POWER_AND_FAN_LED_CONTROL_REG);
-    reg_val = reg_val & mask;
-
-    for(i=POWER_FAN_LED_OFF; i<POWER_FAN_INVALID; i++) {
-        if(strncmp(buf, power_fan_led_mode_str[i],strlen(power_fan_led_mode_str[i]))==0) {
-            usr_val = i << sda->index;
-            nokia_7215_ixs_a1_cpld_write(data, POWER_AND_FAN_LED_CONTROL_REG, reg_val|usr_val);
-            break;
-        }
-    }
-
-    return count;
-}
-
-static ssize_t show_sfp_tx_fault(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, SFP_TX_FAULT_STATUS_REG);
-    
-    /* If the bit is set, TX fault condition */
-    return sprintf(buf,"%d\n",(val>>sda->index) & 0x1 ? 1:0);
-}
-
-static ssize_t show_temp_event_status(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 val=0;
-    char *reason=NULL;
-    val = nokia_7215_ixs_a1_cpld_read(data, TEMP_EVENT_STATUS_REG);
-    switch (val) {
-    case TS1_ALERT_EVENT:
-        reason="ts1";
-        break;
-    case TS2_ALERT_EVENT:
-        reason="ts2";
-        break;
-    case TS3_ALERT_EVENT:
-        reason="ts3";
-        break;
-    case CPU_TEMP_EVENT:
-        reason="cpu";
-        break;
-    case AC5X_HIGHTEMP_EVENT:
-        reason="ac5x";
-        break;
-    case DIMM_TEMP_EVENT:
-        reason="dimm";
-        break;
- 
-    default:
-        reason="none";
-        break;
-    }
-    return sprintf(buf,"0x%02x %s\n",val, reason);
-
-}
-
-static ssize_t show_sfp_ledtest_status(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 val = nokia_7215_ixs_a1_cpld_read(data, SFP_LED_TEST_REG);
-    return sprintf(buf,"0x%02x\n",val);
-}
-
-static ssize_t set_sfp_ledtest_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 usr_val=0;
-    int ret=kstrtou8(buf,16, &usr_val);
-    if (ret != 0) {
-        return ret; 
-    }
-
-    nokia_7215_ixs_a1_cpld_write(data, SFP_LED_TEST_REG, usr_val);
-    return count;
-}
-
-static ssize_t show_temp_event_mask_status(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 val = nokia_7215_ixs_a1_cpld_read(data, TEMP_EVENT_MASK_REG);
-    return sprintf(buf,"0x%02x\n",val);
-}
-
-static ssize_t set_temp_event_mask_status(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    u8 usr_val=0;
-    int ret=kstrtou8(buf,16, &usr_val);
-    if (ret != 0) {
-        return ret; 
-    }
-
-    nokia_7215_ixs_a1_cpld_write(data, TEMP_EVENT_MASK_REG, usr_val);
-    return count;
-}
-
-static ssize_t show_reset_reg(struct device *dev, struct device_attribute *devattr, char *buf) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 val=0;
-    val = nokia_7215_ixs_a1_cpld_read(data, RESET_REG);
-
-    return sprintf(buf,"0x%02x\n",(val>>sda->index) & 0x1 ? 1:0);
-}
-
-static ssize_t set_reset_reg(struct device *dev, struct device_attribute *devattr, const char *buf, size_t count) 
-{
-    struct cpld_data *data = dev_get_drvdata(dev);
-    struct sensor_device_attribute *sda = to_sensor_dev_attr(devattr);
-    u8 reg_val=0, usr_val=0, mask;
-    int ret=kstrtou8(buf,10, &usr_val);
-    if (ret != 0) {
-        return ret; 
-    }
-    if (usr_val > 1) {
-        return -EINVAL;
-    }
-
-    mask = (~(1 << sda->index)) & 0xFF;
-    reg_val = nokia_7215_ixs_a1_cpld_read(data, RESET_REG);
-    reg_val = reg_val & mask;
-
-    usr_val = usr_val << sda->index;
-
-    nokia_7215_ixs_a1_cpld_write(data, RESET_REG, (reg_val|usr_val));
-
-    return count;
-}
-
-
-/* sysfs attributes */
-static SENSOR_DEVICE_ATTR(mbhwversion, S_IRUGO, show_mainboard_hwversion, NULL, 0);
-static SENSOR_DEVICE_ATTR(last_reset_cause, S_IRUGO, show_last_reset_cause, NULL, 0);
-static SENSOR_DEVICE_ATTR(cpldversion, S_IRUGO, show_cpld_version, NULL, 0);
-static SENSOR_DEVICE_ATTR(sfp49_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP49);
-static SENSOR_DEVICE_ATTR(sfp50_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP50);
-static SENSOR_DEVICE_ATTR(sfp51_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP51);
-static SENSOR_DEVICE_ATTR(sfp52_present, S_IRUGO, show_sfp_present, NULL, SFP_PRESENCE_REG_SFP52);
-static SENSOR_DEVICE_ATTR(sfp49_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP49);
-static SENSOR_DEVICE_ATTR(sfp50_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP50);
-static SENSOR_DEVICE_ATTR(sfp51_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP51);
-static SENSOR_DEVICE_ATTR(sfp52_los, S_IRUGO, show_sfp_los, NULL, SFP_LOS_REG_SFP52);
-static SENSOR_DEVICE_ATTR(sfp49_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP49);
-static SENSOR_DEVICE_ATTR(sfp50_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP50);
-static SENSOR_DEVICE_ATTR(sfp51_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP51);
-static SENSOR_DEVICE_ATTR(sfp52_tx_disable, S_IRUGO | S_IWUSR, show_sfp_tx_disable, set_sfp_tx_disable, SFP_LOS_REG_SFP52);
-static SENSOR_DEVICE_ATTR(system_led, S_IRUGO | S_IWUSR, show_system_led_status, set_system_led_status, 0);
-static SENSOR_DEVICE_ATTR(psu_led, S_IRUGO | S_IWUSR, show_power_fan_led_status, set_power_fan_led_status, POWER_LED_OFFSET);
-static SENSOR_DEVICE_ATTR(fan_led, S_IRUGO | S_IWUSR, show_power_fan_led_status, set_power_fan_led_status, FAN_LED_OFFSET);
-static SENSOR_DEVICE_ATTR(sfp49_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP49);
-static SENSOR_DEVICE_ATTR(sfp50_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP50);
-static SENSOR_DEVICE_ATTR(sfp51_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP51);
-static SENSOR_DEVICE_ATTR(sfp52_tx_fault, S_IRUGO, show_sfp_tx_fault, NULL, SFP_TX_FAULT_STATUS_SFP52);
-static SENSOR_DEVICE_ATTR(temp_event_status, S_IRUGO, show_temp_event_status, NULL, 0);
-static SENSOR_DEVICE_ATTR(sfp_led_test, S_IRUGO | S_IWUSR, show_sfp_ledtest_status, set_sfp_ledtest_status, 0);
-static SENSOR_DEVICE_ATTR(temp_event_mask, S_IRUGO | S_IWUSR, show_temp_event_mask_status, set_temp_event_mask_status, 0);
-static SENSOR_DEVICE_ATTR(warm_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_WARM_RESET);
-static SENSOR_DEVICE_ATTR(cold_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_COLD_RESET);
-static SENSOR_DEVICE_ATTR(i2cmux_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_I2CMUX_RESET);
-static SENSOR_DEVICE_ATTR(zarlink_reset, S_IRUGO | S_IWUSR, show_reset_reg, set_reset_reg, RESET_REG_ZL_RESET);
-
-static struct attribute *nokia_7215_ixs_a1_cpld_attributes[] = {
-    &sensor_dev_attr_mbhwversion.dev_attr.attr,
-    &sensor_dev_attr_last_reset_cause.dev_attr.attr,
-    &sensor_dev_attr_cpldversion.dev_attr.attr,
-    &sensor_dev_attr_sfp49_present.dev_attr.attr,
-    &sensor_dev_attr_sfp50_present.dev_attr.attr,
-    &sensor_dev_attr_sfp51_present.dev_attr.attr,
-    &sensor_dev_attr_sfp52_present.dev_attr.attr,
-    &sensor_dev_attr_sfp49_los.dev_attr.attr,
-    &sensor_dev_attr_sfp50_los.dev_attr.attr,
-    &sensor_dev_attr_sfp51_los.dev_attr.attr,
-    &sensor_dev_attr_sfp52_los.dev_attr.attr,
-    &sensor_dev_attr_sfp49_tx_disable.dev_attr.attr,
-    &sensor_dev_attr_sfp50_tx_disable.dev_attr.attr,
-    &sensor_dev_attr_sfp51_tx_disable.dev_attr.attr,
-    &sensor_dev_attr_sfp52_tx_disable.dev_attr.attr,
-    &sensor_dev_attr_temp_event_status.dev_attr.attr,
-    &sensor_dev_attr_system_led.dev_attr.attr,
-    &sensor_dev_attr_psu_led.dev_attr.attr,
-    &sensor_dev_attr_fan_led.dev_attr.attr,
-    &sensor_dev_attr_sfp49_tx_fault.dev_attr.attr,
-    &sensor_dev_attr_sfp50_tx_fault.dev_attr.attr,
-    &sensor_dev_attr_sfp51_tx_fault.dev_attr.attr,
-    &sensor_dev_attr_sfp52_tx_fault.dev_attr.attr,
-    &sensor_dev_attr_sfp_led_test.dev_attr.attr,
-    &sensor_dev_attr_temp_event_mask.dev_attr.attr,
-    &sensor_dev_attr_warm_reset.dev_attr.attr,
-    &sensor_dev_attr_cold_reset.dev_attr.attr,
-    &sensor_dev_attr_i2cmux_reset.dev_attr.attr,
-    &sensor_dev_attr_zarlink_reset.dev_attr.attr,
-    NULL
-};
-
-static const struct attribute_group nokia_7215_ixs_a1_cpld_group = {
-    .attrs = nokia_7215_ixs_a1_cpld_attributes,
-};
-
-
-static int nokia_7215_ixs_a1_cpld_probe(struct i2c_client *client,
-        const struct i2c_device_id *dev_id)
-{
-    int status;
-     struct cpld_data *data=NULL;
-
-    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
-        dev_err(&client->dev, "CPLD PROBE ERROR: i2c_check_functionality failed (0x%x)\n", client->addr);
-        status = -EIO;
-        goto exit;
-    }
-
-    dev_info(&client->dev, "Nokia-7215-IXS-A1 CPLD chip found.\n");
-    data = kzalloc(sizeof(struct cpld_data), GFP_KERNEL);
-
-    if (!data) {
-        dev_err(&client->dev, "CPLD PROBE ERROR: Can't allocate memory\n");
-        status = -ENOMEM;
-        goto exit;
-    }
-
-    data->client = client;
-    i2c_set_clientdata(client, data);
-    mutex_init(&data->update_lock);
-
-    status = sysfs_create_group(&client->dev.kobj, &nokia_7215_ixs_a1_cpld_group);
-    if (status) {
-        dev_err(&client->dev, "CPLD INIT ERROR: Cannot create sysfs\n");
-        goto exit;
-    }
-
-    data->mb_hw_version = nokia_7215_ixs_a1_cpld_read(data, BOARD_ID_REG);
-    data->cpld_version = nokia_7215_ixs_a1_cpld_read(data, CPLD_VERSION_REG);
-
-    return 0;
-
-exit:
-    return status;
-}
-
-static void nokia_7215_ixs_a1_cpld_remove(struct i2c_client *client)
-{
-    struct cpld_data *data = i2c_get_clientdata(client);
-    sysfs_remove_group(&client->dev.kobj, &nokia_7215_ixs_a1_cpld_group);
-    kfree(data);
-    return;
-}
-
-static const struct of_device_id nokia_7215_ixs_a1_cpld_of_ids[] = {
-    {
-        .compatible = "nokia,7215_a1_cpld",
-        .data = (void *) 0,
-    },
-    { },
-};
-MODULE_DEVICE_TABLE(of, nokia_7215_ixs_a1_cpld_of_ids);
-
-static const struct i2c_device_id nokia_7215_ixs_a1_cpld_ids[] = {
-    { DRIVER_NAME, 0 },
-    {}
-};
-MODULE_DEVICE_TABLE(i2c, nokia_7215_ixs_a1_cpld_ids);
-
-static struct i2c_driver nokia_7215_ixs_a1_cpld_driver = {
-    .driver = {
-        .name     = DRIVER_NAME,
-        .of_match_table = of_match_ptr(nokia_7215_ixs_a1_cpld_of_ids),
-    },
-    .probe        = nokia_7215_ixs_a1_cpld_probe,
-    .remove       = nokia_7215_ixs_a1_cpld_remove,
-    .id_table     = nokia_7215_ixs_a1_cpld_ids,
-    .address_list = cpld_address_list,
-};
-
-
-
-static int __init nokia_7215_ixs_a1_cpld_init(void)
-{
-    return i2c_add_driver(&nokia_7215_ixs_a1_cpld_driver);
-}
-
-static void __exit nokia_7215_ixs_a1_cpld_exit(void)
-{
-    i2c_del_driver(&nokia_7215_ixs_a1_cpld_driver);
-}
-
-MODULE_AUTHOR("Nokia");
-MODULE_DESCRIPTION("NOKIA-7215-IXS-A1 CPLD driver");
-MODULE_LICENSE("GPL");
-
-module_init(nokia_7215_ixs_a1_cpld_init);
-module_exit(nokia_7215_ixs_a1_cpld_exit);
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/cpu_wdt.py b/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/cpu_wdt.py
deleted file mode 100755
index b23cd46566e..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/cpu_wdt.py
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-from sonic_py_common import logger
-import time
-import os
-import signal
-import sys
-
-
-TIMEOUT=180
-KEEPALIVE=60
-sonic_logger = logger.Logger('Watchdog')
-sonic_logger.set_min_log_priority_info()
-time.sleep(60)
-chassis = Chassis()
-watchdog = chassis.get_watchdog()
-
-def stopWdtService(signal, frame):
-    watchdog._disablewatchdog()
-    sonic_logger.log_notice("CPUWDT Disabled: watchdog armed=%s" % watchdog.is_armed() )
-    sys.exit()
-
-def main():
-
-    signal.signal(signal.SIGHUP, signal.SIG_IGN)
-    signal.signal(signal.SIGINT, stopWdtService)
-    signal.signal(signal.SIGTERM, stopWdtService)
-    
-    watchdog.arm(TIMEOUT)
-    sonic_logger.log_notice("CPUWDT Enabled: watchdog armed=%s" % watchdog.is_armed() )
-
-
-    while True:
-        time.sleep(KEEPALIVE)
-        watchdog._keepalive()
-        sonic_logger.log_info("CPUWDT keepalive")
-    done
-
-    stopWdtService
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/nokia-7215-init.sh b/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/nokia-7215-init.sh
deleted file mode 100644
index a69c871b028..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/scripts/nokia-7215-init.sh
+++ /dev/null
@@ -1,110 +0,0 @@
-#!/bin/bash
-
-# Platform init script
-
-# Load required kernel-mode drivers
-load_kernel_drivers() {
-    echo "Loading Kernel Drivers"
-    sudo insmod /lib/modules/6.1.0-11-2-arm64/kernel/extra/nokia_7215_ixs_a1_cpld.ko
-    sudo insmod /lib/modules/6.1.0-11-2-arm64/kernel/extra/cn9130_cpu_thermal_sensor.ko
-}
-
-fw_uboot_env_cfg()
-{
-    echo "Setting up U-Boot environment for Nokia-7215-A1"
-    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x10000'
-    echo $FW_ENV_DEFAULT > /etc/fw_env.config
-}
-
-nokia_7215_profile()
-{
-    MAC_ADDR=$(sudo decode-syseeprom -m)
-    sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g" /usr/share/sonic/device/arm64-nokia_ixs7215_52xb-r0/Nokia-7215-A1/profile.ini
-    sudo ifconfig eth0 hw ether $MAC_ADDR
-    echo "Nokia-7215-A1: Updating switch mac address ${MAC_ADDR}"
-}
-file_exists() {
-    # Wait 10 seconds max till file exists
-    for((i=0; i<10; i++));
-    do
-        if [ -f $1 ]; then
-            return 1
-        fi
-        sleep 1
-    done
-    return 0
- }
-
-# - Main entry
-
-# Install kernel drivers required for i2c bus access
-load_kernel_drivers
-
-#setting up uboot environment
-fw_uboot_env_cfg
-
-# Enumerate the SFP eeprom device on each mux channel
-echo pca9546 0x70> /sys/bus/i2c/devices/i2c-1/new_device
-
-# Enumerate power monitor
-echo ina230 0x40 > /sys/bus/i2c/devices/i2c-0/new_device
-
-# Enumerate fan
-echo emc2305 0x2f > /sys/bus/i2c/devices/i2c-0/new_device
-
-# Enumerate Thermals
-echo tmp75 0x48 > /sys/bus/i2c/devices/i2c-0/new_device
-echo tmp75 0x49 > /sys/bus/i2c/devices/i2c-0/new_device
-echo tmp75 0x4A > /sys/bus/i2c/devices/i2c-0/new_device
-
-#Enumerate CPLD
-echo nokia_7215_a1_cpld 0x41 > /sys/bus/i2c/devices/i2c-0/new_device
-
-# Enumerate system eeprom
-echo 24c64 0x53 > /sys/class/i2c-adapter/i2c-0/new_device
-
-file_exists /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
-status=$?
-if [ "$status" == "1" ]; then
-    chmod 644 /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
-else
-    echo "SYSEEPROM file not foud"
-fi
-
-#Enumurate GPIO
-echo 41 > /sys/class/gpio/export
-echo 61 > /sys/class/gpio/export
-echo 62 > /sys/class/gpio/export
-chmod 666 /sys/class/gpio/gpio41/value
-
-# Get list of the mux channels
-for((i=0; i<10; i++));
-    do  
-        ismux_bus=$(i2cdetect -l|grep mux|cut -f1)
-        if [[ $ismux_bus ]]; then
-            break;
-        fi
-        sleep 1
-    done
-
-# Enumerate the SFP eeprom device on each mux channel
-for mux in ${ismux_bus}
-do
-    echo optoe2 0x50 > /sys/class/i2c-adapter/${mux}/new_device
-done
-
-# Enable optical SFP Tx
-for i in {49..52}
-do
-    echo 0 > /sys/bus/i2c/devices/0-0041/sfp${i}_tx_disable
-done
-
-#slow down fan speed to 50% untill thermal algorithm kicks in
-i2c_path="/sys/bus/i2c/devices/0-002f/hwmon/hwmon?"  
-echo 128 > $i2c_path/pwm1
-echo 128 > $i2c_path/pwm2 
-
-# Ensure switch is programmed with base MAC addr
-nokia_7215_profile
-
-exit 0
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/service/cpu_wdt.service b/platform/marvell-arm64/sonic-platform-nokia/7215/service/cpu_wdt.service
deleted file mode 100644
index 761deec569c..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/service/cpu_wdt.service
+++ /dev/null
@@ -1,8 +0,0 @@
-[Unit]
-Description=CPU WDT
-After=nokia-7215init.service
-[Service]
-ExecStart=/usr/local/bin/cpu_wdt.py
-
-[Install]
-WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/service/nokia-7215init.service b/platform/marvell-arm64/sonic-platform-nokia/7215/service/nokia-7215init.service
deleted file mode 100644
index 61e0545e73b..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/service/nokia-7215init.service
+++ /dev/null
@@ -1,11 +0,0 @@
-[Unit]
-Description=Nokia-7215 Platform Service
-After=sysinit.target
-Before=pmon.service
-
-[Service]
-ExecStart=/usr/local/bin/nokia-7215-init.sh
-StandardOutput=tty
-
-[Install]
-WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/setup.py b/platform/marvell-arm64/sonic-platform-nokia/7215/setup.py
deleted file mode 100755
index 65f4853bec8..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/setup.py
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env python
-
-import os
-from setuptools import setup
-os.listdir
-
-setup(
-   name='sonic_platform',
-   version='1.0',
-   description='Module to initialize Nokia IXS 7215 platforms',
-
-   packages=['sonic_platform','sonic_platform.test'],
-   package_dir={'sonic_platform': '7215/sonic_platform'},
-)
-
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/__init__.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/__init__.py
deleted file mode 100644
index 4bfefa0fb63..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/__init__.py
+++ /dev/null
@@ -1,3 +0,0 @@
-__all__ = ["platform", "chassis"]
-from sonic_platform import *
-
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/chassis.py
deleted file mode 100644
index 19007a3b4de..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/chassis.py
+++ /dev/null
@@ -1,440 +0,0 @@
-#############################################################################
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the platform information
-#
-#############################################################################
-
-try:
-    import os
-    import time
-    import sys
-    import glob
-    from sonic_platform_base.chassis_base import ChassisBase
-    from sonic_platform.sfp import Sfp
-    from sonic_platform.eeprom import Eeprom
-    from sonic_platform.fan import Fan
-    from .fan_drawer import RealDrawer
-    from sonic_platform.psu import Psu
-    from sonic_platform.thermal import Thermal
-    from sonic_platform.component import Component
-    from sonic_py_common import logger
-    from sonic_py_common.general import getstatusoutput_noshell
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-MAX_SELECT_DELAY = 3600
-COPPER_PORT_START = 1
-COPPER_PORT_END = 48
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-PORT_END = 52
-MAX_7215_COMPONENT=2
-
-# Device counts
-MAX_7215_FAN_DRAWERS = 2
-MAX_7215_FANS_PER_DRAWER = 1
-MAX_7215_PSU = 2
-MAX_7215_THERMAL = 5
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-
-SYSLOG_IDENTIFIER = "chassis"
-sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
-
-
-class Chassis(ChassisBase):
-    """
-    Nokia platform-specific Chassis class
-        Derived from Dell S6000 platform.
-        customized for the 7215 platform.
-    """
-
-    def __init__(self):
-        ChassisBase.__init__(self)
-        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']
-        # Port numbers for SFP List Initialization
-        self.COPPER_PORT_START = COPPER_PORT_START
-        self.COPPER_PORT_END = COPPER_PORT_END
-        self.SFP_PORT_START = SFP_PORT_START
-        self.SFP_PORT_END = SFP_PORT_END
-        self.PORT_END = PORT_END
-
-        # for non-sfp ports create dummy objects for copper / non-sfp ports
-        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
-            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
-            self._sfp_list.append(sfp_node)
-
-        # Verify optoe2 driver SFP eeprom devices were enumerated and exist
-        # then create the sfp nodes
-        eeprom_path = "/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom"
-        mux_dev = sorted(glob.glob("/sys/class/i2c-adapter/i2c-1/i2c-[0-9]"))
-        y = 0
-        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
-            mux_dev_num = mux_dev[y]
-            port_i2c_map = mux_dev_num[-1]
-            y = y + 1
-            port_eeprom_path = eeprom_path.format(port_i2c_map)
-            if not os.path.exists(port_eeprom_path):
-                sonic_logger.log_info("path %s didnt exist" % port_eeprom_path)
-            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)
-            self._sfp_list.append(sfp_node)
-        self.sfp_event_initialized = False
-
-        # Instantiate system eeprom object
-        self._eeprom = Eeprom()
-
-        # Construct lists fans, power supplies, thermals & components
-        drawer_num = MAX_7215_FAN_DRAWERS
-        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER
-        drawer_ctor = RealDrawer
-        fan_index = 0
-        for drawer_index in range(drawer_num):
-            drawer = drawer_ctor(drawer_index)
-            self._fan_drawer_list.append(drawer)
-            for index in range(fan_num_per_drawer):
-                fan = Fan(fan_index, drawer, self.get_model())
-                fan_index += 1
-                drawer._fan_list.append(fan)
-                self._fan_list.append(fan)
-
-        for i in range(MAX_7215_PSU):
-            psu = Psu(i)
-            self._psu_list.append(psu)
-
-        for i in range(MAX_7215_THERMAL):
-            thermal = Thermal(i)
-            self._thermal_list.append(thermal)
-
-        for i in range(MAX_7215_COMPONENT):
-            component = Component(i)
-            self._component_list.append(component)
-  
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _write_sysfs_file(self, sysfs_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if ((self._read_sysfs_file(sysfs_file)) != value ):
-            time.sleep(3)
-            if ((self._read_sysfs_file(sysfs_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-  
-    def get_sfp(self, index):
-        """
-        Retrieves sfp represented by (1-based) index <index>
-        Args:
-            index: An integer, the index (1-based) of the sfp to retrieve.
-            The index should be the sequence of physical SFP ports in a
-            chassis starting from 1.
-
-        Returns:
-            An object dervied from SfpBase representing the specified sfp
-        """
-        sfp = None
-
-        try:
-            # The index will start from 1
-            sfp = self._sfp_list[index-1]
-        except IndexError:
-            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
-                             index, len(self._sfp_list)))
-        return sfp
-
-    def get_name(self):
-        """
-        Retrieves the name of the chassis
-        Returns:
-            string: The name of the chassis
-        """
-        return self._eeprom.modelstr()
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the chassis
-        Returns:
-            bool: True if chassis is present, False if not
-        """
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the model number (or part number) of the chassis
-        Returns:
-            string: Model/part number of chassis
-        """
-        return self._eeprom.part_number_str()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the chassis
-        Returns:
-            string: Serial number of chassis
-        """
-        return self._eeprom.serial_number_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the chassis
-        Returns:
-            bool: A boolean value, True if chassis is operating properly
-            False if not
-        """
-        return True
-
-    def get_base_mac(self):
-        """
-        Retrieves the base MAC address for the chassis
-
-        Returns:
-            A string containing the MAC address in the format
-            'XX:XX:XX:XX:XX:XX'
-        """
-        return self._eeprom.base_mac_addr()
-
-    def get_service_tag(self):
-        """
-        Retrieves the Service Tag of the chassis
-        Returns:
-            string: Service Tag of chassis
-        """
-        return self._eeprom.service_tag_str()
-
-    def get_revision(self):
-        """
-        Retrieves the hardware revision of the chassis
-
-        Returns:
-            string: Revision value of chassis
-        """
-        #Revision is always 0 for 7215-IXS-A1
-        return str(0)
-
-    def get_system_eeprom_info(self):
-        """
-        Retrieves the full content of system EEPROM information for the
-        chassis
-
-        Returns:
-            A dictionary where keys are the type code defined in
-            OCP ONIE TlvInfo EEPROM format and values are their
-            corresponding values.
-        """
-        return self._eeprom.system_eeprom_info()
-
-    def get_reboot_cause(self):
-        """
-        Retrieves the cause of the previous reboot
-        Returns:
-            A tuple (string, string) where the first element is a string
-            containing the cause of the previous reboot. This string must be
-            one of the predefined strings in this class. If the first string
-            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
-            to pass a description of the reboot cause.
-        """
-        value = self._read_sysfs_file(CPLD_DIR+"last_reset_cause")
-        thermal = self._read_sysfs_file(CPLD_DIR+"temp_event_status")
-        if (value == 'cold_reset'):
-            reboot_cause=(ChassisBase.REBOOT_CAUSE_POWER_LOSS, "Cold Reset")
-        elif (value == 'warm_reset'):
-            reboot_cause=(ChassisBase.REBOOT_CAUSE_HARDWARE_OTHER, "Warm Reset")
-        elif (value == 'wdog_reset'):
-            reboot_cause=(ChassisBase.REBOOT_CAUSE_WATCHDOG, None)
-        elif (value == 'thermal_reset'):
-            reboot_cause=(ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_OTHER, thermal)
-        else:
-            reboot_cause=(ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
-        #unmask temperature event    
-        self._write_sysfs_file(CPLD_DIR+"temp_event_mask", 0)
-        return reboot_cause
-
-    def get_watchdog(self):
-        """
-        Retrieves hardware watchdog device on this chassis
-
-        Returns:
-            An object derived from WatchdogBase representing the hardware
-            watchdog device
-
-        Note:
-            We overload this method to ensure that watchdog is only initialized
-            when it is referenced. Currently, only one daemon can open the
-            watchdog. To initialize watchdog in the constructor causes multiple
-            daemon try opening watchdog when loading and constructing a chassis
-            object and fail. By doing so we can eliminate that risk.
-        """
-        try:
-            if self._watchdog is None:
-                from sonic_platform.watchdog import WatchdogImplBase
-                watchdog_device_path = "/dev/watchdog0"
-                self._watchdog = WatchdogImplBase(watchdog_device_path)
-        except Exception as e:
-            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
-
-        return self._watchdog
-
-    def get_change_event(self, timeout=0):
-        """
-        Returns a nested dictionary containing all devices which have
-        experienced a change at chassis level
-
-        Args:
-            timeout: Timeout in milliseconds (optional). If timeout == 0,
-                this method will block until a change is detected.
-
-        Returns:
-            (bool, dict):
-                - True if call successful, False if not;
-                - A nested dictionary where key is a device type,
-                  value is a dictionary with key:value pairs in the format of
-                  {'device_id':'device_event'},
-                  where device_id is the device ID for this device and
-                        device_event,
-                             status='1' represents device inserted,
-                             status='0' represents device removed.
-                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
-                      indicates that fan 0 has been removed, fan 2
-                      has been inserted and sfp 11 has been removed.
-        """
-        # Initialize SFP event first
-        if not self.sfp_event_initialized:
-            from sonic_platform.sfp_event import sfp_event
-            self.sfp_event = sfp_event()
-            self.sfp_event.initialize()
-            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
-            self.sfp_event_initialized = True
-
-        wait_for_ever = (timeout == 0)
-        port_dict = {}
-        if wait_for_ever:
-            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
-            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
-            timeout = MAX_SELECT_DELAY
-            while True:
-                status = self.sfp_event.check_sfp_status(port_dict, timeout)
-                if not port_dict == {}:
-                    break
-        else:
-            # At boot up and in "INIT" state call from xrcvd will have timeout
-            # value return true without change after timeout and will
-            # transition to "SYSTEM_READY"
-            status = self.sfp_event.check_sfp_status(port_dict, timeout)
-
-        if status:
-            return True, {'sfp': port_dict}
-        else:
-            return True, {'sfp': {}}
-
-    def get_thermal_manager(self):
-        from .thermal_manager import ThermalManager
-        return ThermalManager
-
-    def initizalize_system_led(self):
-        return True
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the system LED
-
-        Args:
-            color: A string representing the color with which to set the
-                   system LED
-
-        Returns:
-            bool: True if system LED state is set successfully, False if not
-        """
-        if color not in self.system_led_supported_color:
-            return False
-
-        if (color == 'off'):
-            value = 'off'
-        elif (color == 'amber'):
-            value ='amber'
-        elif (color == 'green'):
-            value ='green'
-        elif (color == 'amber_blink'):
-            value = 'blink4-amber'
-        elif (color == 'green_blink'):
-            value = 'blink4-green'
-        else:
-            return False
-        # Write sys led
-        status = self._write_sysfs_file(CPLD_DIR+"system_led", value)
-        
-        if status == "ERR":
-            return False
-
-        return True
-
-    def get_status_led(self):
-        """
-        Gets the state of the system LED
-
-        Returns:
-            A string, one of the valid LED color strings which could be vendor
-            specified.
-        """
-        # Read sys led
-        value = self._read_sysfs_file(CPLD_DIR+"system_led")
-
-        if value == 'off':
-            color = 'off'
-        elif value == 'amber':
-            color = 'amber'
-        elif value == 'green':
-            color = 'green'
-        elif value == 'blink4-amber':
-            color = 'amber_blink'
-        elif value == 'blink4-green':
-            color = 'green_blink'
-        else:
-            return None
-
-        return color
-
-    def get_position_in_parent(self):
-        """
-		Retrieves 1-based relative physical position in parent device. If the agent 
-        cannot determine the parent-relative position
-        for some reason, or if the associated value of entPhysicalContainedIn is '0', 
-        then the value '-1' is returned
-		Returns:
-		    integer: The 1-based relative physical position in parent device or -1 if 
-            cannot determine the position
-		"""
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/component.py
deleted file mode 100644
index f4d01291193..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/component.py
+++ /dev/null
@@ -1,219 +0,0 @@
-########################################################################
-# NOKIA IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
-# the platform
-#
-########################################################################
-
-try:
-    import sys
-    import os
-    import time
-    import subprocess
-    import ntpath
-    from sonic_platform_base.component_base import ComponentBase
-    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-if sys.version_info[0] < 3:
-    import commands as cmd
-else:
-    import subprocess as cmd
-
-
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-
-class Component(ComponentBase):
-    """Nokia platform-specific Component class"""
-
-    CHASSIS_COMPONENTS = [
-        ["System-CPLD", "Used for managing SFPs, LEDs, PSUs and FANs "],
-        ["U-Boot", "Performs initialization during booting"],
-    ]
-    CPLD_UPDATE_COMMAND = ['./cpldupd_A1', '']
-
-    def __init__(self, component_index):
-        self.index = component_index
-        self.name = self.CHASSIS_COMPONENTS[self.index][0]
-        self.description = self.CHASSIS_COMPONENTS[self.index][1]
-
-    def _get_command_result(self, cmdline):
-        try:
-            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
-                                    stderr=subprocess.STDOUT)
-            stdout = proc.communicate()[0]
-            proc.wait()
-            result = stdout.rstrip('\n')
-        except OSError:
-            result = None
-
-        return result
-    
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _write_sysfs_file(self, sysfs_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if (int(self._read_sysfs_file(sysfs_file)) != value ):
-            time.sleep(3)
-            if (int(self._read_sysfs_file(sysfs_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-
-    def _get_cpld_version(self, cpld_number):
-
-        cpld_version = self._read_sysfs_file(CPLD_DIR+"cpldversion")
-
-        return str(int(cpld_version, 16))
-
-    def get_name(self):
-        """
-        Retrieves the name of the component
-
-        Returns:
-            A string containing the name of the component
-        """
-        return self.name
-
-    def get_model(self):
-        """
-        Retrieves the part number of the component
-        Returns:
-            string: Part number of component
-        """
-        return 'NA'
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the component
-        Returns:
-            string: Serial number of component
-        """
-        return 'NA'
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the component
-        Returns:
-            bool: True if  present, False if not
-        """
-        return True
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the component
-        Returns:
-            bool: True if component is operating properly, False if not
-        """
-        return True
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device.
-        Returns:
-            integer: The 1-based relative physical position in parent
-            device or -1 if cannot determine the position
-        """
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether component is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
-
-    def get_description(self):
-        """
-        Retrieves the description of the component
-
-        Returns:
-            A string containing the description of the component
-        """
-        return self.description
-
-    def get_firmware_version(self):
-        """
-        Retrieves the firmware version of the component
-
-        Returns:
-            A string containing the firmware version of the component
-        """
-        if self.index == 0:
-            return self._get_cpld_version(self.index)
-
-        if self.index == 1:
-            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data ^U-Boot /dev/mtd0ro | cut -d" " -f4')
-            return uboot_version
-
-    def install_firmware(self, image_path):
-        """
-        Installs firmware to the component
-
-        Args:
-            image_path: A string, path to firmware image
-
-        Returns:
-            A boolean, True if install was successful, False if not
-        """
-        image_name = ntpath.basename(image_path)
-        print(" ixs-7215-A1 - install cpld {}".format(image_name))
-
-        # check whether the image file exists
-        if not os.path.isfile(image_path):
-            print("ERROR: the cpld image {} doesn't exist ".format(image_path))
-            return False
-
-        # check whether the cpld exe exists
-        if not os.path.isfile('/tmp/cpldupd_A1'):
-            print("ERROR: the cpld exe {} doesn't exist ".format('/tmp/cpldupd_A1'))
-            return False
-
-        self.CPLD_UPDATE_COMMAND[1] = image_name
-
-        success_flag = False
- 
-        try:   
-            subprocess.check_call(self.CPLD_UPDATE_COMMAND, stderr=subprocess.STDOUT)
-
-            success_flag = True
-        except subprocess.CalledProcessError as e:
-            print("ERROR: Failed to upgrade CPLD: rc={}".format(e.returncode))
-
-        if success_flag:
-            print("INFO: Refresh or power cycle is required to finish CPLD installation")
-
-        return success_flag
-
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/eeprom.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/eeprom.py
deleted file mode 100644
index b9f770abf90..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/eeprom.py
+++ /dev/null
@@ -1,174 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains platform specific implementation of SONiC Platform
-# Base API and provides the EEPROMs' information.
-#
-# The different EEPROMs available are as follows:
-# - System EEPROM : Contains Serial number, Service tag, Base MA
-#                   address, etc. in ONIE TlvInfo EEPROM format.
-########################################################################
-
-
-try:
-    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('eeprom')
-
-class Eeprom(TlvInfoDecoder):
-    """Nokia platform-specific EEPROM class"""
-
-    I2C_DIR = "/sys/class/i2c-adapter/"
-
-    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
-        self.is_psu_eeprom = is_psu
-        self.is_fan_eeprom = is_fan
-        self.is_sys_eeprom = not (is_psu | is_fan)
-        
-        if self.is_sys_eeprom:
-            self.start_offset = 0
-            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0053/eeprom"
-            # System EEPROM is in ONIE TlvInfo EEPROM format
-            super(Eeprom, self).__init__(self.eeprom_path,
-                                         self.start_offset, '', True)
-            self._load_system_eeprom()
-        
-        else:
-            if self.is_psu_eeprom:
-                self.index = psu_index
-                self.part_number = '1'
-                self.model_str = 'PJT-12V100WBBA'
-                self.serial_number = 'NA'               
-
-            if self.is_fan_eeprom:
-                self.index = fan_index
-                self.part_number = '1'
-                self.model_str = 'FFB0412UHN-BC2EA12'
-                self.serial_number = 'NA'                
-
-
-    def _load_system_eeprom(self):
-        """
-        Reads the system EEPROM and retrieves the values corresponding
-        to the codes defined as per ONIE TlvInfo EEPROM format and fills
-        them in a dictionary.
-        """
-        try:
-            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
-            self.eeprom_data = self.read_eeprom()
-        except Exception as e:
-            sonic_logger.log_warning("Unable to read system eeprom")
-            self.base_mac = 'NA'
-            self.serial_number = 'NA'
-            self.part_number = 'NA'
-            self.model_str = 'NA'
-            self.service_tag = 'NA'
-            self.eeprom_tlv_dict = dict()
-        else:
-            eeprom = self.eeprom_data
-            self.eeprom_tlv_dict = dict()
-
-            if not self.is_valid_tlvinfo_header(eeprom):
-                sonic_logger.log_warning("Invalid system eeprom TLV header")
-                self.base_mac = 'NA'
-                self.serial_number = 'NA'
-                self.part_number = 'NA'
-                self.model_str = 'NA'
-                self.service_tag = 'NA'
-                return
-
-            total_length = (eeprom[9] << 8) | eeprom[10]
-            tlv_index = self._TLV_INFO_HDR_LEN
-            tlv_end = self._TLV_INFO_HDR_LEN + total_length
-
-            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
-                if not self.is_valid_tlv(eeprom[tlv_index:]):
-                    break
-
-                tlv = eeprom[tlv_index:tlv_index + 2
-                             + eeprom[tlv_index + 1]]
-                code = "0x%02X" % (tlv[0])
-
-                name, value = self.decoder(None, tlv)
-
-                self.eeprom_tlv_dict[code] = value
-                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
-                    break
-
-                tlv_index += eeprom[tlv_index+1] + 2
-
-            self.base_mac = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
-            self.serial_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
-            self.part_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
-            self.model_str = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
-            self.service_tag = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
-
-    def _get_eeprom_field(self, field_name):
-        """
-        For a field name specified in the EEPROM format, returns the
-        presence of the field and the value for the same.
-        """
-        field_start = 0
-        for field in self.format:
-            field_end = field_start + field[2]
-            if field[0] == field_name:
-                return (True, self.eeprom_data[field_start:field_end])
-            field_start = field_end
-
-        return (False, None)
-
-    def serial_number_str(self):
-        """
-        Returns the serial number.
-        """
-        return self.serial_number
-
-    def part_number_str(self):
-        """
-        Returns the part number.
-        """
-        return self.part_number
-
-    def airflow_fan_type(self):
-        """
-        Returns the airflow fan type.
-        """
-        if self.is_psu_eeprom:
-            return int(self.psu_type.encode('hex'), 16)
-        if self.is_fan_eeprom:
-            return int(self.fan_type.encode('hex'), 16)
-
-    # System EEPROM specific methods
-    def base_mac_addr(self):
-        """
-        Returns the base MAC address found in the system EEPROM.
-        """
-        return self.base_mac
-
-    def modelstr(self):
-        """
-        Returns the Model name.
-        """
-        return self.model_str
-
-    def service_tag_str(self):
-        """
-        Returns the servicetag number.
-        """
-        return self.service_tag
-
-    def system_eeprom_info(self):
-        """
-        Returns a dictionary, where keys are the type code defined in
-        ONIE EEPROM format and values are their corresponding values
-        found in the system EEPROM.
-        """
-        return self.eeprom_tlv_dict
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan.py
deleted file mode 100644
index b86370dc0ee..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan.py
+++ /dev/null
@@ -1,332 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Fans' information which are available in the platform
-#
-########################################################################
-
-
-try:
-    import os
-    import time
-    from sonic_platform_base.fan_base import FanBase
-    from sonic_platform.eeprom import Eeprom
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-MAX_IXS7215_FAN_SPEED = 23000
-WORKING_IXS7215_FAN_SPEED = 2300
-
-
-sonic_logger = logger.Logger('fan')
-
-
-class Fan(FanBase):
-    """Nokia platform-specific Fan class"""
-
-    def __init__(self, fan_index, fan_drawer, chassis_model, psu_fan=False, dependency=None):
-        self.is_psu_fan = psu_fan
-        EMC2302_DIR = " "
-        i2c_path = "/sys/bus/i2c/devices/0-002f/hwmon/"
-        if(os.path.exists(i2c_path)):
-            hwmon_node = os.listdir(i2c_path)[0]
-            EMC2302_DIR = i2c_path + hwmon_node + '/'
-
-        if not self.is_psu_fan:
-            # Fan is 1-based in Nokia platforms
-            self.index = fan_index + 1
-            self.fan_drawer = fan_drawer
-            self.chassis_model = chassis_model
-            self.set_fan_speed_reg = EMC2302_DIR+"pwm{}".format(self.index)
-            self.get_fan_speed_reg = EMC2302_DIR+"fan{}_input".format(self.index)
-            self.max_fan_speed = MAX_IXS7215_FAN_SPEED
-
-            # Fan eeprom
-            self.eeprom = Eeprom(is_fan=True, fan_index=self.index)
-        else:
-            # this is a PSU Fan
-            self.index = fan_index
-            self.dependency = dependency
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _write_sysfs_file(self, sysfs_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if (int(self._read_sysfs_file(sysfs_file)) != value ):
-            time.sleep(3)
-            if (int(self._read_sysfs_file(sysfs_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-
-    def get_name(self):
-        """
-        Retrieves the name of the Fan
-
-        Returns:
-            string: The name of the Fan
-        """
-        if not self.is_psu_fan:
-            return "Fan{}".format(self.index)
-        else:
-            return "PSU{} Fan".format(self.index)
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the Fan Unit
-
-        Returns:
-            bool: True if Fan is present, False if not
-        """
-        #Fixed Fan's on 7215-IXS-A1, Always return True
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the model number of the Fan
-
-        Returns:
-            string: Model number of Fan. Use part number for this.
-        """
-        return self.eeprom.modelstr()
-    
-    def get_chassis_model(self):
-        """
-        Retrieves the model number of the Fan
-
-        Returns:
-            string: Model number of Fan. Use part number for this.
-        """
-        return self.chassis_model
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Fan
-
-        Returns:
-            string: Serial number of Fan
-        """
-        return self.eeprom.serial_number_str()
-
-    def get_part_number(self):
-        """
-        Retrieves the part number of the Fan
-
-        Returns:
-            string: Part number of Fan
-        """
-        return self.eeprom.part_number_str()
-
-    def get_service_tag(self):
-        """
-        Retrieves the service tag of the Fan
-
-        Returns:
-            string: Service Tag of Fan
-        """
-        return self.eeprom.service_tag_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the Fan
-
-        Returns:
-            bool: True if Fan is operating properly, False if not
-        """
-        status = False
-
-        fan_speed = self._read_sysfs_file(self.get_fan_speed_reg)
-        if (fan_speed != 'ERR'):
-            if (int(fan_speed) > WORKING_IXS7215_FAN_SPEED):
-                status = True
-
-        return status
-
-    def get_direction(self):
-        """
-        Retrieves the fan airflow direction
-        Possible fan directions (relative to port-side of device)
-        Returns:
-            A string, either FAN_DIRECTION_INTAKE or
-            FAN_DIRECTION_EXHAUST depending on fan direction
-        """
-        ch_model=self.get_chassis_model()
-        #compare first 8 characters of chassis molel string
-        if(ch_model[:8]=='3HE18723'):
-            direction = 'intake'
-        else:
-            direction = 'exhaust'
-
-        return direction
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
-
-
-    def get_speed(self):
-        """
-        Retrieves the speed of a Front FAN in the tray in revolutions per
-                 minute defined by 1-based index
-        :param index: An integer, 1-based index of the FAN to query speed
-        :return: integer, denoting front FAN speed
-        """
-        speed = 0
-
-        fan_speed = self._read_sysfs_file(self.get_fan_speed_reg)
-        if (fan_speed != 'ERR'):
-            speed_in_rpm = int(fan_speed)
-        else:
-            speed_in_rpm = 0
-
-        speed = 100*speed_in_rpm//MAX_IXS7215_FAN_SPEED
-        if speed > 100:
-            speed = 100
-
-        return speed
-
-    def get_speed_tolerance(self):
-        """
-        Retrieves the speed tolerance of the fan
-
-        Returns:
-            An integer, the percentage of variance from target speed
-            which is considered tolerable
-        """
-        if self.get_presence():
-            if self.get_target_speed()<50:
-                tolerance=60
-            else:
-                tolerance = 25
-        else:
-            tolerance = 0
-
-        return tolerance
-
-    def set_speed(self, speed):
-        """
-        Set fan speed to expected value
-        Args:
-            speed: An integer, the percentage of full fan speed to set
-            fan to, in the range 0 (off) to 100 (full speed)
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        if self.is_psu_fan:
-            return False
-
-        if speed in range(0, 6):
-            fandutycycle = 0x00
-        elif speed in range(6, 26):
-            fandutycycle = 64
-        elif speed in range(26, 41):
-            fandutycycle = 102
-        elif speed in range(41, 52):
-            fandutycycle = 128
-        elif speed in range(52, 76):
-            fandutycycle = 192
-        elif speed in range(76, 101):
-            fandutycycle = 255
-        else:
-            return False
-
-        rv = self._write_sysfs_file(self.set_fan_speed_reg, fandutycycle)
-        if (rv != 'ERR'):
-            return True
-        else:
-            return False
-
-    def set_status_led(self, color):
-        """
-        Set led to expected color
-        Args:
-            color: A string representing the color with which to set the
-                   fan module status LED
-        Returns:
-            bool: True if set success, False if fail.
-
-            off , red and green are the only settings 7215 fans
-        """
-        # No Individual Status LED for 7215-IXS-A1
-        return False
-
-    def get_status_led(self):
-        """
-        Gets the state of the fan status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-        if self.get_status():
-            return self.STATUS_LED_COLOR_GREEN
-        else:
-            return self.STATUS_LED_COLOR_OFF
-
-    def get_target_speed(self):
-        """
-        Retrieves the target (expected) speed of the fan
-
-        Returns:
-            An integer, the percentage of full fan speed, in the range 0
-            (off) to 100 (full speed)
-        """
-        speed = 0
-
-        fan_duty = self._read_sysfs_file(self.set_fan_speed_reg)
-        if (fan_duty != 'ERR'):
-            dutyspeed = int(fan_duty)
-            if dutyspeed == 0:
-                speed = 0
-            elif dutyspeed == 64:
-                speed = 25
-            elif dutyspeed == 102:
-                speed = 40
-            elif dutyspeed == 128:
-                speed = 50
-            elif dutyspeed == 192:
-                speed = 75
-            elif dutyspeed == 255:
-                speed = 100
-
-        return speed
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
deleted file mode 100644
index 3683b4a22b8..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
+++ /dev/null
@@ -1,102 +0,0 @@
-#############################################################################
-# Nokia
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Fan Drawer status which is available in the platform
-#
-#############################################################################
-
-try:
-    from sonic_platform_base.fan_drawer_base import FanDrawerBase
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('fan_drawer')
-
-class NokiaFanDrawer(FanDrawerBase):
-    def __init__(self, index):
-        super(NokiaFanDrawer, self).__init__()
-        self._index = index + 1
-        self._led = None
-
-    def get_index(self):
-        return self._index
-
-    def get_presence(self):
-        return self._fan_list[0].get_presence()
-
-    def get_model(self):
-        """
-        Retrieves the model number of the Fan Drawer
-        Returns:
-            string: Part number of Fan Drawer
-        """
-        return self._fan_list[0].get_model()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Fan Drawer
-        Returns:
-            string: Serial number of Fan
-        """
-        return self._fan_list[0].get_serial()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the Fan Drawer
-        Returns:
-            bool: True if Fan is operating properly, False if not
-        """
-        return self._fan_list[0].get_status()
-
-    def get_direction(self):
-        return 'intake'
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the fan drawer status LED
-
-        Args:
-            color: A string representing the color with which to set the
-                   fan drawer status LED
-
-        Returns:
-            bool: True if status LED state is set successfully, False if not
-        """
-        return self._fan_list[0].set_status_led(color)
-
-    def get_status_led(self):
-        """
-        Gets the state of the fan drawer LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings
-        """
-        return self._fan_list[0].get_status_led()
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self._index
-
-
-# For Nokia platforms with fan drawer(s)
-class RealDrawer(NokiaFanDrawer):
-    def __init__(self, index):
-        super(RealDrawer, self).__init__(index)
-        self._name = 'drawer{}'.format(self._index)
-
-    def get_name(self):
-        return self._name
\ No newline at end of file
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/platform.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/platform.py
deleted file mode 100644
index 7a3046bc739..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/platform.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#############################################################################
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the platform information
-#
-#############################################################################
-
-try:
-    from sonic_platform_base.platform_base import PlatformBase
-    from sonic_platform.chassis import Chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-class Platform(PlatformBase):
-    """
-    Nokia platform-specific class
-    """
-
-    def __init__(self):
-        PlatformBase.__init__(self)
-        self._chassis = Chassis()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/psu.py
deleted file mode 100644
index 8249954932f..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/psu.py
+++ /dev/null
@@ -1,321 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the PSUs' information which are available in the platform
-#
-########################################################################
-
-try:
-    import os
-    import time
-    from sonic_platform_base.psu_base import PsuBase
-    from sonic_py_common import logger
-    from sonic_platform.eeprom import Eeprom
-    from sonic_py_common.general import getstatusoutput_noshell
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('psu')
-INA230_DIR = "/sys/bus/i2c/devices/0-0040/iio:device0/"
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-PSU_GPIO_DIR = ["/sys/class/gpio/gpio61/value", "/sys/class/gpio/gpio62/value"]
-
-
-class Psu(PsuBase):
-    """Nokia platform-specific PSU class for 7215 """
-
-    def __init__(self, psu_index):
-        PsuBase.__init__(self)
-        # PSU is 1-based in Nokia platforms
-        self.index = psu_index + 1
-        self._fan_list = []
-        
-
-        # PSU eeprom
-        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)
-        self.MAX_VOLTAGE = 14
-        self.MIN_VOLTAGE = 10
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _write_sysfs_file(self, sysfs_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if ((self._read_sysfs_file(sysfs_file)) != value ):
-            time.sleep(3)
-            if ((self._read_sysfs_file(sysfs_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-    
-    def _get_active_psus(self):
-        """
-        Retrieves the operational status of the PSU and
-        calculates number of active PSU's
-
-        Returns:
-            Integer: Number of active PSU's
-        """  
-        active_psus = 0
-        psu1_good = self._read_sysfs_file(PSU_GPIO_DIR[0])
-        psu2_good = self._read_sysfs_file(PSU_GPIO_DIR[1])
-
-        active_psus = int(psu1_good) + int(psu2_good)
-        
-        return active_psus
-
-    def get_name(self):
-        """
-        Retrieves the name of the device
-
-        Returns:
-            string: The name of the device
-        """
-        return "PSU{}".format(self.index)
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the Power Supply Unit (PSU)
-
-        Returns:
-            bool: True if PSU is present, False if not
-        """
-        #Fixed PSU's on 7215-IXS-A1, Always return True
-
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the part number of the PSU
-
-        Returns:
-            string: Part number of PSU
-        """
-        return self.eeprom.modelstr()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the PSU
-
-        Returns:
-            string: Serial number of PSU
-        """
-        return self.eeprom.serial_number_str()
-
-    def get_revision(self):
-        """
-        Retrieves the HW revision of the PSU
-
-        Returns:
-            string: HW revision of PSU
-        """
-        return self.eeprom.part_number_str()
-
-    def get_part_number(self):
-        """
-        Retrieves the part number of the PSU
-
-        Returns:
-            string: Part number of PSU
-        """
-        return self.eeprom.part_number_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the PSU
-
-        Returns:
-            bool: True if PSU is operating properly, False if not
-        """
-        psu_sysfs_str=PSU_GPIO_DIR[self.index-1]
-        psu_status = self._read_sysfs_file(psu_sysfs_str)
-
-        if psu_status == '1':
-            return True
-
-        return False
-
-    def get_voltage(self):
-        """
-        Retrieves current PSU voltage output
-
-        Returns:
-            A float number, the output voltage in volts,
-            e.g. 12.1
-        """
-        if(self.get_status()):
-            psu_voltage = self._read_sysfs_file(INA230_DIR+"in_voltage1_raw")
-        else:
-            psu_voltage = 0.0
-        
-        psu_voltage = (float(psu_voltage)*1.25)/1000
-
-        return psu_voltage
-    
-    def get_current(self):
-        """
-        Retrieves present electric current supplied by PSU
-
-        Returns:
-            A float number, the electric current in amperes, e.g 15.4
-        """
-        num_psus = self._get_active_psus()
-        if(self.get_status()):
-            psu_current = self._read_sysfs_file(INA230_DIR+"in_current3_raw")
-            psu_current = ((float(psu_current)*0.5)/1000)/num_psus
-        else:
-            psu_current = 0.0
-
-        return psu_current
-    
-    def get_power(self):
-        """
-        Retrieves current energy supplied by PSU
-
-        Returns:
-            A float number, the power in watts, e.g. 302.6
-        """
-        psu_voltage = self.get_voltage()
-        psu_current = self.get_current()
-        psu_power = psu_voltage * psu_current
-
-        return psu_power
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def get_voltage_high_threshold(self):
-        """
-        Retrieves the high threshold PSU voltage output
-
-        Returns:
-            A float number, the high threshold output voltage in volts,
-            e.g. 12.1
-        """
-        return self.MAX_VOLTAGE
-
-    def get_voltage_low_threshold(self):
-        """
-        Retrieves the low threshold PSU voltage output
-
-        Returns:
-            A float number, the low threshold output voltage in volts,
-            e.g. 12.1
-        """
-        return self.MIN_VOLTAGE
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
-
-    def get_powergood_status(self):
-        """
-        Retrieves the powergood status of PSU
-        Returns:
-            A boolean, True if PSU has stablized its output voltages and
-            passed all its internal self-tests, False if not.
-        """
-        psu_sysfs_str=PSU_GPIO_DIR[self.index-1]
-        psu_pg_status = self._read_sysfs_file(psu_sysfs_str)
-
-        if psu_pg_status == '1':
-            return True
-
-        return False
-
-    def get_status_led(self):
-        """
-        Gets the state of the PSU status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-        if self.get_powergood_status():
-            return self.STATUS_LED_COLOR_GREEN
-        else:
-            return self.STATUS_LED_COLOR_OFF
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the PSU status LED
-        Args:
-            color: A string representing the color with which to set the
-                   PSU status LED
-        Returns:
-            bool: True if status LED state is set successfully, False if
-                  not
-        """
-        # No Individual Status LED for 7215-IXS-A1
-        return False
-
-    def get_status_master_led(self):
-        """
-        Gets the state of the front panel PSU status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-        psu_led = self._read_sysfs_file(CPLD_DIR+"psu_led")
-
-        if psu_led == "green":
-            return self.STATUS_LED_COLOR_GREEN
-        elif psu_led == "amber":
-            return self.STATUS_LED_COLOR_AMBER
-        else:
-            return None
-
-    def set_status_master_led(self, color):
-        """
-        Sets the state of the front panel PSU status LED
-
-        Returns:
-            bool: True if status LED state is set successfully, False if
-                  not
-        """
-        if color == self.STATUS_LED_COLOR_GREEN:
-            status = self._write_sysfs_file(CPLD_DIR+"psu_led", "green")
-        elif color == self.STATUS_LED_COLOR_AMBER:
-            status = self._write_sysfs_file(CPLD_DIR+"psu_led", "amber")
-        else:
-            return False
-
-        if status == "ERR":
-            return False
-
-        return True
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp.py
deleted file mode 100644
index b682080e18d..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp.py
+++ /dev/null
@@ -1,214 +0,0 @@
-# Name: sfp.py, version: 1.0
-#
-# Description: Module contains the definitions of SFP related APIs
-# for Nokia IXS 7215 platform.
-#
-# Copyright (c) 2023, Nokia
-# All rights reserved.
-#
-
-try:
-    import os
-    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase
-    from sonic_py_common.logger import Logger
-    from sonic_py_common import device_info
-    from sonic_py_common.general import getstatusoutput_noshell
-
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-import subprocess as cmd
-
-COPPER_TYPE = "COPPER"
-SFP_TYPE = "SFP"
-
-# SFP PORT numbers
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-logger = Logger()
-
-class Sfp(SfpOptoeBase):
-    """
-    Nokia IXS-7215 Platform-specific Sfp refactor class
-    """
-    instances = []
-
-    # Paths
-    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
-    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
-    HOST_CHK_CMD = "docker > /dev/null 2>&1"
-
-    PLATFORM = "armhf-nokia_ixs7215_52x-r0"
-    HWSKU = "Nokia-7215"
-
-    port_to_i2c_mapping = 0
-
-    # def __init__(self, index, sfp_type, stub):
-    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
-        SfpOptoeBase.__init__(self)
-
-        self.index = index
-        self.port_num = index
-        self.sfp_type = sfp_type
-        self.eeprom_path = eeprom_path
-        self.port_to_i2c_mapping = port_i2c_map
-        self.name = sfp_type + str(index-1)
-        self.port_name = sfp_type + str(index)
-        self.port_to_eeprom_mapping = {}
-
-        self.port_to_eeprom_mapping[index] = eeprom_path
-
-        self._version_info = device_info.get_sonic_version_info()
-        self.lastPresence = False
-
-        logger.log_debug("Sfp __init__ index {} setting name to {} and eeprom_path to {}".format(index, self.name, self.eeprom_path))
-
-        Sfp.instances.append(self)
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
- 
-    def get_eeprom_path(self):
-        return self.eeprom_path
-
-    def get_presence(self):
-        """
-        Retrieves the presence
-        Returns:
-            bool: True if is present, False if not
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        sfpstatus = self._read_sysfs_file(CPLD_DIR+"sfp{}_present".format(self.index))      
-        if sfpstatus == '1':
-            return True
-
-        return False
-
-    def get_name(self):
-        """
-        Retrieves the name of the device
-            Returns:
-            string: The name of the device
-        """
-        return self.name
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device.
-        Returns:
-            integer: The 1-based relative physical position in parent device or
-                     -1 if cannot determine the position
-        """
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-
-        if self.sfp_type == "SFP":
-            return True
-        else:
-            return False
-
-    def _get_error_code(self):
-        """
-        Get error code of the SFP module
-
-        Returns:
-            The error code
-        """
-        return NotImplementedError
-
-    def get_error_description(self):
-        """
-        Get error description
-
-        Args:
-            error_code: The error code returned by _get_error_code
-
-        Returns:
-            The error description
-        """
-        if not self.get_presence():
-            error_description = self.SFP_STATUS_UNPLUGGED
-        else:
-            error_description = self.SFP_STATUS_OK
-
-        return error_description
-
-    def get_reset_status(self):
-        """
-        Retrieves the reset status of SFP
-        Returns:
-            A Boolean, True if reset enabled, False if disabled
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the device
-        """
-        reset = self.get_reset_status()
-
-        if reset is True:
-            status = False
-        else:
-            status = True
-
-        return status
-
-    def reset(self):
-        """
-        Reset SFP.
-        Returns:
-            A boolean, True if successful, False if not
-        """
-        # RJ45 and SFP ports not resettable
-        return False
-
-    def set_lpmode(self, lpmode):
-        """
-        Sets the lpmode (low power mode) of SFP
-        Args:
-            lpmode: A Boolean, True to enable lpmode, False to disable it
-            Note  : lpmode can be overridden by set_power_override
-        Returns:
-            A boolean, True if lpmode is set successfully, False if not
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
-
-    def get_lpmode(self):
-        """
-        Retrieves the lpmode (low power mode) status of this SFP
-        Returns:
-            A Boolean, True if lpmode is enabled, False if disabled
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
deleted file mode 100644
index 92f759b9789..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
+++ /dev/null
@@ -1,119 +0,0 @@
-'''
-listen for the SFP change event and return to chassis.
-'''
-import os
-import time
-from sonic_py_common import logger
-from sonic_py_common.general import getstatusoutput_noshell
-
-# system level event/error
-EVENT_ON_ALL_SFP = '-1'
-SYSTEM_NOT_READY = 'system_not_ready'
-SYSTEM_READY = 'system_become_ready'
-SYSTEM_FAIL = 'system_fail'
-
-# SFP PORT numbers
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-
-SYSLOG_IDENTIFIER = "sfp_event"
-sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
-
-
-class sfp_event:
-    ''' Listen to plugin/plugout cable events '''
-
-    def __init__(self):
-        self.handle = None
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-    
-    def initialize(self):
-        self.modprs_register = 0
-        # Get Transceiver status
-        time.sleep(5)
-        self.modprs_register = self._get_transceiver_status()
-        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
-
-    def deinitialize(self):
-        if self.handle is None:
-            return
-
-    def _get_transceiver_status(self):
-
-        pos = [1, 2, 4, 8]
-        sfpstatus = 0
-        for port in range (SFP_PORT_START,SFP_PORT_END+1):
-            status = self._read_sysfs_file(CPLD_DIR+"sfp{}_present".format(port))  
-            bit_pos = pos[port-SFP_PORT_START]
-            sfpstatus = sfpstatus + (bit_pos * (int(status)))
-
-        return sfpstatus
-
-    def check_sfp_status(self, port_change, timeout):
-        """
-        check_sfp_status called from get_change_event, this will return correct
-            status of all 4 SFP ports if there is a change in any of them
-        """
-        start_time = time.time()
-        port = SFP_PORT_START
-        forever = False
-
-        if timeout == 0:
-            forever = True
-        elif timeout > 0:
-            timeout = timeout / float(1000)  # Convert to secs
-        else:
-            return False, {}
-        end_time = start_time + timeout
-
-        if (start_time > end_time):
-            return False, {}  # Time wrap or possibly incorrect timeout
-
-        while (timeout >= 0):
-            # Check for OIR events and return updated port_change
-            reg_value = self._get_transceiver_status()
-            if (reg_value != self.modprs_register):
-                changed_ports = (self.modprs_register ^ reg_value)
-                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
-                    # Mask off the bit corresponding to our port
-                    mask = (1 << port-SFP_PORT_START)
-                    if (changed_ports & mask):
-                        # ModPrsL is active high
-                        if reg_value & mask == 0:
-                            port_change[port] = '0'
-                        else:
-                            port_change[port] = '1'
-                    port += 1
-
-                # Update reg value
-                self.modprs_register = reg_value
-                return True, port_change
-
-            if forever:
-                time.sleep(1)
-            else:
-                timeout = end_time - time.time()
-                if timeout >= 1:
-                    time.sleep(1)  # We poll at 1 second granularity
-                else:
-                    if timeout > 0:
-                        time.sleep(timeout)
-                    return True, {}
-        return False, {}
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/README b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/README
deleted file mode 100644
index 3efc8fabce0..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/README
+++ /dev/null
@@ -1 +0,0 @@
-This directory contains unit tests of the Platform API 2.0
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
deleted file mode 100755
index 93dfcaac3d0..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
+++ /dev/null
@@ -1,72 +0,0 @@
-#!/usr/bin/env python
-
-try:
-    import sonic_platform.platform
-    import sonic_platform.chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-def main():
-    print("-----------------")
-    print("Chassis Unit Test")
-    print("-----------------")
-
-    chassis = sonic_platform.platform.Platform().get_chassis()
-    print("  Chassis name: {}".format(chassis.get_name()))
-
-    print("  Chassis presence: {}".format(chassis.get_presence()))
-
-    print("  Chassis model: {}".format(chassis.get_model()))
-
-    print("  Chassis serial: {}".format(chassis.get_serial()))
-
-    print("  Chassis revision: {}".format(chassis.get_revision()))
-
-    print("  Chassis status: {}".format(chassis.get_status()))
-
-    print("  Chassis base_mac: {}".format(chassis.get_base_mac()))
-
-    print("  Chassis reboot cause: {}\n".format(chassis.get_reboot_cause()))
-
-    print("  Chassis watchdog: {}".format(chassis.get_watchdog()))
-
-    print("  Chassis num_components: {}".format(chassis.get_num_components()))
-
-    print("  Chassis all_components: {}\n".format(chassis.get_all_components()))
-
-    print("  Chassis num_modules: {}".format(chassis.get_num_modules()))
-
-    print("  Chassis all_modules: {}\n".format(chassis.get_all_modules()))
-
-    print("  Chassis num_fans: {}".format(chassis.get_num_fans()))
-
-    print("  Chassis all_fans: {}\n".format(chassis.get_all_fans()))
-
-    print("  Chassis num_psus: {}".format(chassis.get_num_psus()))
-
-    print("  Chassis all_psus: {}\n".format(chassis.get_all_psus()))
-
-    print("  Chassis num_thermals: {}".format(chassis.get_num_thermals()))
-
-    print("  Chassis all_thermals: {}\n".format(chassis.get_all_thermals()))
-
-    print("  Chassis num_sfps: {}".format(chassis.get_num_sfps()))
-
-    print("  Chassis all_sfps: {}\n".format(chassis.get_all_sfps()))
-
-    print("  Chassis eeprom: {}".format(chassis.get_eeprom()))
-
-    print("  Chassis system_eeprom_info: {}\n".format(chassis.get_system_eeprom_info()))
-
-    print("  Chassis get_status_led start : {}\n".format(chassis.get_status_led()))
-    chassis.set_status_led('amber')
-    print("  Chassis get_status_led amber: {}\n".format(chassis.get_status_led()))
-    chassis.set_status_led('green')
-    print("  Chassis get_status_led green: {}\n".format(chassis.get_status_led()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-component.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
deleted file mode 100755
index 1116cc7b585..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------------")
-    print("Chassis Component Unit Test")
-    print("---------------------------")
-
-    chassis = Chassis()
-
-    for component in chassis.get_all_components():
-        print("    Name: {}".format(component.get_name()))
-        print("        Description: {}".format(component.get_description()))
-        print("        FW version: {}\n".format(component.get_firmware_version()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
deleted file mode 100755
index bee72e022e8..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("------------------------")
-    print("Chassis eeprom Unit Test")
-    print("------------------------")
-
-    chassis = Chassis()
-
-    eeprom = chassis.get_eeprom()
-
-    print("    Model: {}, Service Tag: {}".format(eeprom.modelstr(),
-                                             eeprom. service_tag_str()))
-    print("    Part#: {}, Serial#: {}".format(eeprom.part_number_str(),
-                                              eeprom.serial_number_str()))
-    print("    Base MAC: {}".format(eeprom.base_mac_addr()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
deleted file mode 100755
index 3fbedf1231d..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
+++ /dev/null
@@ -1,32 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis Fan Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    for fan in chassis.get_all_fans():
-        if not fan.get_presence():
-            print("    Name: {} not present".format(fan.get_name()))
-        else:
-            print("    Name:", fan.get_name())
-            print("        Presence: {}, Status: {}, LED: {}".format(fan.get_presence(),
-                                                                     fan.get_status(),
-                                                                     fan.get_status_led()))
-            print("        Model: {}, Serial#: {}".format(fan.get_model(),
-                                                          fan.get_serial()))
-            print("        Part#: {}, Service Tag: {}".format(fan.get_part_number(),
-                                                              fan.get_service_tag()))
-            print("        Direction: {}, Speed: {}%, Target Speed: {}%\n".format(fan.get_direction(),
-                                                                                    str(fan.get_speed()),
-                                                                                    str(fan.get_target_speed())))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
deleted file mode 100755
index e3979b8c417..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis PSU Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    for psu in chassis.get_all_psus():
-        if not psu.get_presence():
-            print("    Name: {} not present".format(psu.get_name()))
-        else:
-            print("    Name:", psu.get_name())
-            print("        Presence: {}, Status: {}, LED: {}".format(psu.get_presence(),
-                                                                     psu.get_status(),
-                                                                     psu.get_status_led()))
-            print("        Model: {}, Serial#: {}, Part#: {}".format(psu.get_model(),
-                                                                     psu.get_serial(),
-                                                                     psu.get_part_number()))
-            try:
-                current = psu.get_current()
-            except NotImplementedError:
-                current = "NA"
-            try:
-                power = psu.get_power()
-            except NotImplementedError:
-                power = "NA"
-
-            print("        Voltage: {}, Current: {}, Power: {}\n".format(psu.get_voltage(),
-                                                                         current,
-                                                                         power))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
deleted file mode 100755
index 4d283fa2eb0..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/usr/bin/env python
-
-try:
-    from sonic_platform.chassis import Chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-def main():
-    print("---------------------")
-    print("Chassis SFP Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    PORT_START = 1
-    PORT_END = 52
-
-    for physical_port in range(PORT_START, PORT_END+1):
-        print(" ")
-        print(" SFP transceiver tests  PORT = ", physical_port)
-        name = chassis.get_sfp(physical_port).get_name()
-        print(" SFP transceiver tests  NAME = ", name)
-
-        presence = chassis.get_sfp(physical_port).get_presence()
-        print("TEST 1 - sfp presence       [ True ] ", physical_port, presence)
-
-        status = chassis.get_sfp(physical_port).get_reset_status()
-        print("TEST 2 - sfp reset status   [ False ] ", physical_port, status)
-
-        txdisable = chassis.get_sfp(physical_port).get_tx_disable()
-        print("TEST 3 - sfp tx_disable     [ False ] ", physical_port, txdisable)
-
-        rxlos = chassis.get_sfp(physical_port).get_rx_los()
-        print("TEST 4 - sfp status rxlos   [ False ] ", physical_port, rxlos)
-
-        txfault = chassis.get_sfp(physical_port).get_tx_fault()
-        print("TEST 5 - sfp status txfault [ False ] ", physical_port, txfault)
-
-        lpmode = chassis.get_sfp(physical_port).get_lpmode()
-        print("TEST 6 - sfp enable lpmode  [ False ] ", physical_port, lpmode)
-
-        trans_info = chassis.get_sfp(physical_port).get_transceiver_info()
-        print("TEST 7 - sfp transceiver info for port:", physical_port, trans_info)
-
-        trans_status = chassis.get_sfp(physical_port).get_transceiver_bulk_status()
-        print("TEST 8 - sfp bulk status for port:", physical_port, trans_status)
-
-        threshold = chassis.get_sfp(physical_port).get_transceiver_threshold_info()
-        print("TEST 9 - sfp bulk status for port:", physical_port, threshold)
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
deleted file mode 100755
index 95cc8e89f0d..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-def main():
-    print("-------------------------")
-    print("Chassis Thermal Unit Test")
-    print("-------------------------")
-
-    chassis = Chassis()
-
-    for thermal in chassis.get_all_thermals():
-        if not thermal.get_presence():
-            print("    Name: {} not present".format(thermal.get_name()))
-        else:
-            print("    Name:", thermal.get_name())
-            print("        Presence: {}, Status: {}".format(thermal.get_presence(),
-                                                            thermal.get_status()))
-            print("        Model: {}, Serial#: {}".format(thermal.get_model(),
-                                                          thermal.get_serial()))
-            print("        Temperature(C): {}".format(thermal.get_temperature()))
-
-            try:
-                low_thresh = thermal.get_low_threshold()
-            except NotImplementedError:
-                low_thresh = "NA"
-            try:
-                high_thresh = thermal.get_high_threshold()
-            except NotImplementedError:
-                high_thresh = "NA"
-
-            print("        Low Threshold(C): {}, High Threshold(C): {}".format(low_thresh,
-                                                                               high_thresh))
-
-            try:
-                crit_low_thresh = thermal.get_low_critical_threshold()
-            except NotImplementedError:
-                crit_low_thresh = "NA"
-            try:
-                crit_high_thresh = thermal.get_high_critical_threshold()
-            except NotImplementedError:
-                crit_high_thresh = "NA"
-
-            print("        Crit Low Threshold(C): {}, Crit High Threshold(C): {}\n".format(crit_low_thresh,
-                                                                                           crit_high_thresh))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
deleted file mode 100755
index 20805e04ed2..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis Watchdog Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    watchdog = chassis.get_watchdog()
-
-    print("    Armed: {}".format(watchdog.is_armed()))
-    print("    Time Left: {}".format(watchdog.get_remaining_time()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal.py
deleted file mode 100644
index 20c15452b68..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal.py
+++ /dev/null
@@ -1,265 +0,0 @@
-########################################################################
-# Nokia IXS7215-A1
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Thermals' information which are available in the platform
-#
-########################################################################
-
-
-try:
-    import os
-    from sonic_platform_base.thermal_base import ThermalBase
-    from swsscommon.swsscommon import SonicV2Connector
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('thermal')
-
-class Thermal(ThermalBase):
-    """Nokia platform-specific Thermal class"""
-
-    I2C_CLASS_DIR = "/sys/class/i2c-adapter/"
-    I2C_DEV_MAPPING = (['i2c-0/0-0048/hwmon/', 1],
-                       ['i2c-0/0-0049/hwmon/', 1],
-                       ['i2c-0/0-004a/hwmon/', 1])
-
-    CN9130_THERMAL_DIR = "/sys/class/hwmon/hwmon1/"
-    ASIC_TEMP_INFO = "ASIC_TEMPERATURE_INFO"
-
-    THERMAL_NAME = ("PCB BACK", "PCB FRONT", "PCB MID", "ASIC", "CPU CORE")
-
-    def __init__(self, thermal_index):
-        ThermalBase.__init__(self)
-        self.index = thermal_index + 1
-        self.is_psu_thermal = False
-        self.dependency = None
-        self._minimum = None
-        self._maximum = None
-        self.thermal_high_threshold_file = None
-        # PCB temperature sensors
-        if self.index < 4:
-            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
-            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
-            sensor_high_suffix = "max"
-            sensor_high_crit_suffix = None
-            hwmon_node = os.listdir(i2c_path)[0]
-            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
-
-        #ASIC temperature sensor
-        elif self.index == 4:
-            sensor_high_suffix = None
-            sensor_high_crit_suffix = None
-            self.sensor_high_threshold = 100.0
-            self.sensor_crit_threshold = 110.0
-            self.SENSOR_DIR = None
-
-        # CPU CN9130 temperature sensor
-        elif self.index == 5:
-            dev_path = self.CN9130_THERMAL_DIR
-            sensor_index = 1
-            sensor_high_suffix = "crit"
-            sensor_high_crit_suffix = "max"
-            self.SENSOR_DIR = dev_path
-
-        # sysfs file for current temperature value
-        if self.SENSOR_DIR:
-            self.thermal_temperature_file = self.SENSOR_DIR \
-                + "temp{}_input".format(sensor_index)
-
-        # sysfs file for high threshold value if supported for this sensor
-        if sensor_high_suffix:
-            self.thermal_high_threshold_file = self.SENSOR_DIR \
-                + "temp{}_{}".format(sensor_index, sensor_high_suffix)
-        else:
-            self.thermal_high_threshold_file = None
-
-        # sysfs file for crit high threshold value if supported for this sensor
-        if sensor_high_crit_suffix:
-            self.thermal_high_crit_threshold_file = self.SENSOR_DIR \
-                + "temp{}_{}".format(sensor_index, sensor_high_crit_suffix)
-        else:
-            self.thermal_high_crit_threshold_file = None
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # sysfs_file and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def get_name(self):
-        """
-        Retrieves the name of the thermal
-
-        Returns:
-            string: The name of the thermal
-        """
-        return self.THERMAL_NAME[self.index - 1]
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the thermal
-
-        Returns:
-            bool: True if thermal is present, False if not
-        """
-        if self.dependency:
-            return self.dependency.get_presence()
-        else:
-            return True
-
-    def get_model(self):
-        """
-        Retrieves the model number (or part number) of the Thermal
-
-        Returns:
-            string: Model/part number of Thermal
-        """
-        return 'NA'
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Thermal
-
-        Returns:
-            string: Serial number of Thermal
-        """
-        return 'NA'
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the thermal
-
-        Returns:
-            A boolean value, True if thermal is operating properly,
-            False if not
-        """
-        if self.dependency:
-            return self.dependency.get_status()
-        else:
-            return True
-
-    def get_temperature(self):
-        """
-        Retrieves current temperature reading from thermal
-
-        Returns:
-            A float number of current temperature in Celsius up to
-            nearest thousandth of one degree Celsius, e.g. 30.125
-        """
-        #read from state_db for asic temperature
-        if self.index == 4:
-            db = SonicV2Connector()
-            db.connect(db.STATE_DB)
-            data_dict = db.get_all(db.STATE_DB, self.ASIC_TEMP_INFO)
-            thermal_temperature = float(data_dict['maximum_temperature'])
-        else:
-            thermal_temperature = self._read_sysfs_file(self.thermal_temperature_file)
-            if (thermal_temperature != 'ERR'):
-                thermal_temperature = float(thermal_temperature) / 1000
-            else:
-                thermal_temperature = 0
-
-        if self._minimum is None or self._minimum > thermal_temperature:
-            self._minimum = thermal_temperature
-        if self._maximum is None or self._maximum < thermal_temperature:
-            self._maximum = thermal_temperature
-
-        return float("{:.3f}".format(thermal_temperature))
-
-    def get_high_threshold(self):
-        """
-        Retrieves the high threshold temperature of thermal
-
-        Returns:
-            A float number, the high threshold temperature of thermal in
-            Celsius up to nearest thousandth of one degree Celsius,
-            e.g. 30.125
-        """
-        if self.index == 4:
-            return float("{:.3f}".format(self.sensor_high_threshold))
-        # Not implemented for this sensor
-        if not self.thermal_high_threshold_file:
-            raise  NotImplementedError
-
-        thermal_high_threshold = self._read_sysfs_file(self.thermal_high_threshold_file)
-        if (thermal_high_threshold != 'ERR'):
-            thermal_high_threshold = float(thermal_high_threshold) / 1000
-        else:
-            thermal_high_threshold = 0.0
-
-        return float("{:.3f}".format(thermal_high_threshold))
-
-    def set_high_threshold(self, temperature):
-        """
-        Sets the high threshold temperature of thermal
-
-        Args :
-            temperature: A float number up to nearest thousandth of one
-            degree Celsius, e.g. 30.125
-        Returns:
-            A boolean, True if threshold is set successfully, False if
-            not
-        """
-        # Thermal threshold values are pre-defined based on HW.
-        return False
-
-    def get_high_critical_threshold(self):
-        """
-        Retrieves the high critical threshold temperature of thermal
-
-        Returns:
-            A float number, the high critical threshold temperature of thermal in Celsius
-            up to nearest thousandth of one degree Celsius, e.g. 30.125
-        """
-        if self.index == 4:
-            return float("{:.3f}".format(self.sensor_crit_threshold))
-        # Not implemented for this sensor
-        if not self.thermal_high_crit_threshold_file:
-            raise  NotImplementedError
-
-        thermal_high_crit_threshold = self._read_sysfs_file(
-            self.thermal_high_crit_threshold_file)
-        if (thermal_high_crit_threshold != 'ERR'):
-            thermal_high_crit_threshold = float(thermal_high_crit_threshold) / 1000
-        else:
-            thermal_high_crit_threshold = 0.0
-
-        return float("{:.3f}".format(thermal_high_crit_threshold))
-
-    def get_minimum_recorded(self):
-        self.get_temperature()
-        return self._minimum
-
-    def get_maximum_recorded(self):
-        self.get_temperature()
-        return self._maximum
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
deleted file mode 100644
index 4dc9b6ab5b4..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
+++ /dev/null
@@ -1,222 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-
-from sonic_py_common import logger
-
-sonic_logger = logger.Logger('thermal_actions')
-
-
-class SetFanSpeedAction(ThermalPolicyActionBase):
-    """
-    Base thermal action class to set speed for fans
-    """
-    # JSON field definition
-    JSON_FIELD_SPEED = 'speed'
-    JSON_FIELD_DEFAULT_SPEED = 'default_speed'
-    JSON_FIELD_THRESHOLD1_SPEED = 'threshold1_speed'
-    JSON_FIELD_THRESHOLD2_SPEED = 'threshold2_speed'
-    JSON_FIELD_HIGHTEMP_SPEED = 'hightemp_speed'
-
-    def __init__(self):
-        """
-        Constructor of SetFanSpeedAction
-        """
-        self.default_speed = 25
-        self.threshold1_speed=40
-        self.threshold2_speed=75
-        self.hightemp_speed = 100
-        self.speed = self.default_speed
-
-    def load_from_json(self, json_obj):
-        """
-        Construct SetFanSpeedAction via JSON. JSON example:
-            {
-                "type": "fan.all.set_speed"
-                "speed": "100"
-            }
-        :param json_obj: A JSON object representing a SetFanSpeedAction action.
-        :return:
-        """
-        if SetFanSpeedAction.JSON_FIELD_SPEED in json_obj:
-            speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
-            if speed < 0 or speed > 100:
-                raise ValueError('SetFanSpeedAction invalid speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(speed))
-            self.speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_SPEED))
-
-    @classmethod
-    def set_all_fan_speed(cls, thermal_info_dict, speed):
-        from .thermal_infos import FanInfo
-        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
-            fan_info_obj = thermal_info_dict[FanInfo.INFO_NAME]
-            for fan in fan_info_obj.get_presence_fans():
-                fan.set_speed(int(speed))
-
-
-@thermal_json_object('fan.all.set_speed')
-class SetAllFanSpeedAction(SetFanSpeedAction):
-    """
-    Action to set speed for all fans
-    """
-    def execute(self, thermal_info_dict):
-        """
-        Set speed for all fans
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        SetAllFanSpeedAction.set_all_fan_speed(thermal_info_dict, self.speed)
-
-
-@thermal_json_object('thermal.temp_check_and_set_all_fan_speed')
-class ThermalRecoverAction(SetFanSpeedAction):
-    """
-    Action to check thermal sensor temperature change status and set speed for all fans
-    """
-
-    def load_from_json(self, json_obj):
-        """
-        Construct ThermalRecoverAction via JSON. JSON example:
-            {
-                "type": "thermal.temp_check_and_set_all_fan_speed"
-                "default_speed": "25",
-                "threshold1_speed": "40",
-                "threshold2_speed": "75",
-                "hightemp_speed": "100"
-            }
-        :param json_obj: A JSON object representing a ThermalRecoverAction action.
-        :return:
-        """
-        if SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED in json_obj:
-            default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
-            if default_speed < 0 or default_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(default_speed))
-            self.default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED))
-
-        if SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED in json_obj:
-            threshold1_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED])
-            if threshold1_speed < 0 or threshold1_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(threshold1_speed))
-            self.threshold1_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_THRESHOLD1_SPEED))
-        
-        if SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED in json_obj:
-            threshold2_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED])
-            if threshold2_speed < 0 or threshold2_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(threshold2_speed))
-            self.threshold2_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_THRESHOLD2_SPEED))
-        
-        if SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED in json_obj:
-            hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
-            if hightemp_speed < 0 or hightemp_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid hightemp speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(hightemp_speed))
-            self.hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED))
-
-        sonic_logger.log_warning("ThermalRecoverAction: default: {}, threshold1: {}, threshold2: {}, hightemp: {}".format(self.default_speed, self.threshold1_speed, self.threshold2_speed, self.hightemp_speed))
-
-    def execute(self, thermal_info_dict):
-        """
-        Check check thermal sensor temperature change status and set speed for all fans
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        from .thermal_infos import ThermalInfo
-        if ThermalInfo.INFO_NAME in thermal_info_dict and \
-           isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
-
-            thermal_info_obj = thermal_info_dict[ThermalInfo.INFO_NAME]
-            if thermal_info_obj.is_set_fan_high_temp_speed():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.hightemp_speed) 
-            elif thermal_info_obj.is_set_fan_threshold_two_speed():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.threshold2_speed)
-            elif thermal_info_obj.is_set_fan_threshold_one_speed():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.threshold1_speed)
-            elif thermal_info_obj.is_set_fan_default_speed():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.default_speed)
-
-
-@thermal_json_object('switch.shutdown')
-class SwitchPolicyAction(ThermalPolicyActionBase):
-    """
-    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,
-    all predefined thermal action will be executed.
-    """
-    def execute(self, thermal_info_dict):
-        """
-        Take action when thermal condition matches. For example, adjust speed of fan or shut
-        down the switch.
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        sonic_logger.log_warning("Alarm for temperature critical is detected, reboot Device")
-        # import os
-        # os.system('reboot')
-
-
-@thermal_json_object('thermal_control.control')
-class ControlThermalAlgoAction(ThermalPolicyActionBase):
-    """
-    Action to control the thermal control algorithm
-    """
-    # JSON field definition
-    JSON_FIELD_STATUS = 'status'
-
-    def __init__(self):
-        self.status = True
-
-    def load_from_json(self, json_obj):
-        """
-        Construct ControlThermalAlgoAction via JSON. JSON example:
-            {
-                "type": "thermal_control.control"
-                "status": "true"
-            }
-        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.
-        :return:
-        """
-        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:
-            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()
-            if status_str == 'true':
-                self.status = True
-            elif status_str == 'false':
-                self.status = False
-            else:
-                raise ValueError('Invalid {} field value, please specify true of false'.
-                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
-        else:
-            raise ValueError('ControlThermalAlgoAction '
-                             'missing mandatory field {} in JSON policy file'.
-                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
-
-    def execute(self, thermal_info_dict):
-        """
-        Disable thermal control algorithm
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        from .thermal_infos import ChassisInfo
-        if ChassisInfo.INFO_NAME in thermal_info_dict:
-            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]
-            chassis = chassis_info_obj.get_chassis()
-            thermal_manager = chassis.get_thermal_manager()
-            if self.status:
-                thermal_manager.start_thermal_control_algorithm()
-            else:
-                thermal_manager.stop_thermal_control_algorithm()
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
deleted file mode 100644
index 4923d63d746..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
+++ /dev/null
@@ -1,81 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_condition_base import ThermalPolicyConditionBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-
-
-class FanCondition(ThermalPolicyConditionBase):
-    def get_fan_info(self, thermal_info_dict):
-        from .thermal_infos import FanInfo
-        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
-            return thermal_info_dict[FanInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('fan.any.absence')
-class AnyFanAbsenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_absence_fans()) > 0 if fan_info_obj else False
-
-
-@thermal_json_object('fan.all.absence')
-class AllFanAbsenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_presence_fans()) == 0 if fan_info_obj else False
-
-
-@thermal_json_object('fan.all.presence')
-class AllFanPresenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_absence_fans()) == 0 if fan_info_obj else False
-
-
-class ThermalCondition(ThermalPolicyConditionBase):
-    def get_thermal_info(self, thermal_info_dict):
-        from .thermal_infos import ThermalInfo
-        if ThermalInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
-            return thermal_info_dict[ThermalInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('thermal.over.high_critical_threshold')
-class ThermalOverHighCriticalCondition(ThermalCondition):
-    def is_match(self, thermal_info_dict):
-        thermal_info_obj = self.get_thermal_info(thermal_info_dict)
-        if thermal_info_obj:
-            return thermal_info_obj.is_over_high_critical_threshold()
-        else:
-            return False
-
-
-class PsuCondition(ThermalPolicyConditionBase):
-    def get_psu_info(self, thermal_info_dict):
-        from .thermal_infos import PsuInfo
-        if PsuInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[PsuInfo.INFO_NAME], PsuInfo):
-            return thermal_info_dict[PsuInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('psu.any.absence')
-class AnyPsuAbsenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_absence_psus()) > 0 if psu_info_obj else False
-
-
-@thermal_json_object('psu.all.absence')
-class AllPsuAbsenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_presence_psus()) == 0 if psu_info_obj else False
-
-
-@thermal_json_object('psu.all.presence')
-class AllPsuPresenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_absence_psus()) == 0 if psu_info_obj else False
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
deleted file mode 100644
index 0f03ee7a4fd..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
+++ /dev/null
@@ -1,270 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_info_base import ThermalPolicyInfoBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-from sonic_py_common.logger import Logger
-
-logger = Logger()
-
-@thermal_json_object('fan_info')
-class FanInfo(ThermalPolicyInfoBase):
-    """
-    Fan information needed by thermal policy
-    """
-
-    # Fan information name
-    INFO_NAME = 'fan_info'
-
-    def __init__(self):
-        self._absence_fans = set()
-        self._presence_fans = set()
-        self._status_changed = False
-
-    def collect(self, chassis):
-        """
-        Collect absence and presence fans.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._status_changed = False
-        for fan in chassis.get_all_fans():
-            if fan.get_presence() and fan not in self._presence_fans:
-                self._presence_fans.add(fan)
-                self._status_changed = True
-                if fan in self._absence_fans:
-                    self._absence_fans.remove(fan)
-            elif not fan.get_presence() and fan not in self._absence_fans:
-                self._absence_fans.add(fan)
-                self._status_changed = True
-                if fan in self._presence_fans:
-                    self._presence_fans.remove(fan)
-
-    def get_absence_fans(self):
-        """
-        Retrieves absence fans
-        :return: A set of absence fans
-        """
-        return self._absence_fans
-
-    def get_presence_fans(self):
-        """
-        Retrieves presence fans
-        :return: A set of presence fans
-        """
-        return self._presence_fans
-
-    def is_status_changed(self):
-        """
-        Retrieves if the status of fan information changed
-        :return: True if status changed else False
-        """
-        return self._status_changed
-
-
-@thermal_json_object('thermal_info')
-class ThermalInfo(ThermalPolicyInfoBase):
-    """
-    Thermal information needed by thermal policy
-    """
-
-    # Fan information name
-    INFO_NAME = 'thermal_info'
-
-    def __init__(self):
-        self._old_threshold_level = -1
-        self._current_threshold_level = 0
-        self._num_fan_levels = 3
-        self._high_crital_threshold = 75
-        #THERMAL_NAME ("PCB BACK", "PCB FRONT", "PCB MID", "ASIC", "CPU CORE")
-        self._f2b_level_up_threshold = [[38,30,37,60,77],
-                                        [51,44,50,72,90],
-                                        [61,57,61,77,94]]
-        
-        self._f2b_level_down_threshold = [[29,24,29,50,64],
-                                          [40,37,40,59,75],
-                                          [58,54,58,72,90]]
-        
-        self._b2f_level_up_threshold = [[30,38,41,65,71],
-                                        [43,50,54,76,86],
-                                        [53,59,61,79,92]]
-        
-        self._b2f_level_down_threshold = [[22,30,33,54,60],
-                                          [37,44,46,62,73],
-                                          [51,57,58,75,90]]
-    def collect(self, chassis):
-        """
-        Collect thermal sensor temperature change status
-        :param chassis: The chassis object
-        :return:
-        """
-        self._temps = []
-        self._over_high_critical_threshold = False
-        self._set_fan_default_speed = False
-        self._set_fan_threshold_one_speed = False
-        self._set_fan_threshold_two_speed = False
-        self._set_fan_high_temp_speed = False
-
-        # Calculate average temp within the device
-        num_of_thermals = chassis.get_num_thermals()
-        for index in range(num_of_thermals):
-            self._temps.insert(index, chassis.get_thermal(index).get_temperature())
-        
-        fan_direction=chassis.get_fan(1).get_direction()
-        if(fan_direction == "intake"):
-            level_up_threshold=self._f2b_level_up_threshold
-            level_down_threshold=self._f2b_level_down_threshold
-        else:
-            level_up_threshold=self._b2f_level_up_threshold
-            level_down_threshold=self._b2f_level_down_threshold
-
-       # Find current required threshold level
-        max_level =0
-        min_level = [self._num_fan_levels for i in range(num_of_thermals)]  
-        for index in range(num_of_thermals):
-            for level in range(self._num_fan_levels):
-
-                if self._temps[index]>level_up_threshold[level][index]:
-                    if max_level<level+1:
-                        max_level=level+1
-                if self._temps[index]<level_down_threshold[level][index]:
-                    if min_level[index]>level:
-                        min_level[index]=level
-
-        max_of_min_level=max(min_level)
-
-        #compare with running threshold level 
-        if max_of_min_level > self._old_threshold_level:
-            max_of_min_level=self._old_threshold_level
-          
-        self._current_threshold_level = max(max_of_min_level,max_level)
-       
-        #set fan to max speed if one fan is down
-        for fan in chassis.get_all_fans():
-            if not fan.get_status() :
-                self._current_threshold_level = 3
-          
-       # Decide fan speed based on threshold level
-
-        if self._current_threshold_level != self._old_threshold_level:
-            if self._current_threshold_level == 0:
-                self._set_fan_default_speed = True
-            elif self._current_threshold_level == 1:
-                self._set_fan_threshold_one_speed = True
-            elif self._current_threshold_level == 2:
-                self._set_fan_threshold_two_speed = True
-            elif self._current_threshold_level == 3:
-                self._set_fan_high_temp_speed = True
-
-        self._old_threshold_level=self._current_threshold_level
-
-    def is_set_fan_default_speed(self):
-        """
-        Retrieves if the temperature is warm up and over high threshold
-        :return: True if the temperature is warm up and over high threshold else False
-        """
-        return self._set_fan_default_speed
-
-    def is_set_fan_threshold_one_speed(self):
-        """
-        Retrieves if the temperature is warm up and over high threshold
-        :return: True if the temperature is warm up and over high threshold else False
-        """
-        return self._set_fan_threshold_one_speed
-    
-    def is_set_fan_threshold_two_speed(self):
-        """
-        Retrieves if the temperature is warm up and over high threshold
-        :return: True if the temperature is warm up and over high threshold else False
-        """
-        return self._set_fan_threshold_two_speed
-
-    def is_set_fan_high_temp_speed(self):
-        """
-        Retrieves if the temperature is warm up and over high threshold
-        :return: True if the temperature is warm up and over high threshold else False
-        """
-        return self._set_fan_high_temp_speed
-
-    def is_over_high_critical_threshold(self):
-        """
-        Retrieves if the temperature is over high critical threshold
-        :return: True if the temperature is over high critical threshold else False
-        """
-        return self._over_high_critical_threshold
-
-
-@thermal_json_object('psu_info')
-class PsuInfo(ThermalPolicyInfoBase):
-    """
-    PSU information needed by thermal policy
-    """
-    INFO_NAME = 'psu_info'
-
-    def __init__(self):
-        self._absence_psus = set()
-        self._presence_psus = set()
-        self._status_changed = False
-
-    def collect(self, chassis):
-        """
-        Collect absence and presence PSUs.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._status_changed = False
-        for psu in chassis.get_all_psus():
-            if psu.get_presence() and psu.get_powergood_status() and psu not in self._presence_psus:
-                self._presence_psus.add(psu)
-                self._status_changed = True
-                if psu in self._absence_psus:
-                    self._absence_psus.remove(psu)
-            elif (not psu.get_presence() or not psu.get_powergood_status()) and psu not in self._absence_psus:
-                self._absence_psus.add(psu)
-                self._status_changed = True
-                if psu in self._presence_psus:
-                    self._presence_psus.remove(psu)
-
-    def get_absence_psus(self):
-        """
-        Retrieves presence PSUs
-        :return: A set of absence PSUs
-        """
-        return self._absence_psus
-
-    def get_presence_psus(self):
-        """
-        Retrieves presence PSUs
-        :return: A set of presence fans
-        """
-        return self._presence_psus
-
-    def is_status_changed(self):
-        """
-        Retrieves if the status of PSU information changed
-        :return: True if status changed else False
-        """
-        return self._status_changed
-
-
-@thermal_json_object('chassis_info')
-class ChassisInfo(ThermalPolicyInfoBase):
-    """
-    Chassis information needed by thermal policy
-    """
-    INFO_NAME = 'chassis_info'
-
-    def __init__(self):
-        self._chassis = None
-
-    def collect(self, chassis):
-        """
-        Collect platform chassis.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._chassis = chassis
-
-    def get_chassis(self):
-        """
-        Retrieves platform chassis object
-        :return: A platform chassis object.
-        """
-        return self._chassis
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
deleted file mode 100644
index 967cf175934..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
+++ /dev/null
@@ -1,49 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase
-from .thermal_actions import *
-from .thermal_conditions import *
-from .thermal_infos import *
-
-
-class ThermalManager(ThermalManagerBase):
-    THERMAL_ALGORITHM_CONTROL_PATH = '/var/run/hw-management/config/suspend'
-
-    @classmethod
-    def start_thermal_control_algorithm(cls):
-        """
-        Start thermal control algorithm
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        cls._control_thermal_control_algorithm(False)
-
-    @classmethod
-    def stop_thermal_control_algorithm(cls):
-        """
-        Stop thermal control algorithm
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        cls._control_thermal_control_algorithm(True)
-
-    @classmethod
-    def _control_thermal_control_algorithm(cls, suspend):
-        """
-        Control thermal control algorithm
-
-        Args:
-            suspend: Bool, indicate suspend the algorithm or not
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        status = True
-        write_value = 1 if suspend else 0
-        try:
-            with open(cls.THERMAL_ALGORITHM_CONTROL_PATH, 'w') as control_file:
-                control_file.write(str(write_value))
-        except (ValueError, IOError):
-            status = False
-
-        return status
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/watchdog.py b/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/watchdog.py
deleted file mode 100644
index 052a276af42..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/sonic_platform/watchdog.py
+++ /dev/null
@@ -1,231 +0,0 @@
-"""
-Module contains an implementation of SONiC Platform Base API and
-provides access to hardware watchdog
-"""
-
-import os
-import fcntl
-import array
-import time
-from sonic_platform_base.watchdog_base import WatchdogBase
-
-""" ioctl constants """
-IO_WRITE = 0x40000000
-IO_READ = 0x80000000
-IO_SIZE_INT = 0x00040000
-IO_READ_WRITE = 0xC0000000
-IO_TYPE_WATCHDOG = ord('W') << 8
-
-WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
-WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
-
-""" Watchdog ioctl commands """
-WDIOC_SETOPTIONS = 4 | WDR_INT
-WDIOC_KEEPALIVE = 5 | WDR_INT
-WDIOC_SETTIMEOUT = 6 | WDWR_INT
-WDIOC_GETTIMEOUT = 7 | WDR_INT
-WDIOC_SETPRETIMEOUT = 8 | WDWR_INT
-WDIOC_GETPRETIMEOUT = 9 | WDR_INT
-WDIOC_GETTIMELEFT = 10 | WDR_INT
-
-""" Watchdog status constants """
-WDIOS_DISABLECARD = 0x0001
-WDIOS_ENABLECARD = 0x0002
-
-""" watchdog sysfs """
-WD_SYSFS_PATH = "/sys/class/watchdog/watchdog0/"
-WD_GPIO_PATH = "/sys/class/gpio/gpio41/value"
-CPLD_DIR = "/sys/bus/i2c/devices/0-0041/"
-
-WD_COMMON_ERROR = -1
-
-class WatchdogImplBase(WatchdogBase):
-    """
-    Base class that implements common logic for interacting
-    with watchdog using ioctl commands
-    """
-
-    def __init__(self, wd_device_path):
-        """
-        Open a watchdog handle
-        @param wd_device_path Path to watchdog device
-        """
-        super(WatchdogImplBase, self).__init__()
-        
-        self.watchdog=""
-        self.watchdog_path = wd_device_path
-        self.watchdog_gpio_reg = WD_GPIO_PATH
-        self.wd_state_reg = WD_SYSFS_PATH+"state"
-        self.wd_timeout_reg = WD_SYSFS_PATH+"timeout"
-        self.wd_timeleft_reg = WD_SYSFS_PATH+"timeleft"
-    
-        self.timeout = self._gettimeout()
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-    
-    def _write_sysfs_file(self, sysfs_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if (int(self._read_sysfs_file(sysfs_file)) != value ):
-            time.sleep(3)
-            if (int(self._read_sysfs_file(sysfs_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-
-    def _disablewatchdog(self):
-        """
-        Turn off the watchdog timer
-        """
-
-        req = array.array('h', [WDIOS_DISABLECARD])
-        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
-        self._write_sysfs_file(self.watchdog_gpio_reg, 1)
-        self._read_sysfs_file(CPLD_DIR+"last_reset_cause")
-        
-    def _enablewatchdog(self):
-        """
-        Turn on the watchdog timer
-        """
-
-        req = array.array('h', [WDIOS_ENABLECARD])
-        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
-
-    def _keepalive(self):
-        """
-        Keep alive watchdog timer
-        """
-
-        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
-
-    def _settimeout(self, seconds):
-        """
-        Set watchdog timer timeout
-        @param seconds - timeout in seconds
-        @return is the actual set timeout
-        """
-
-        req = array.array('I', [seconds])
-        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
-
-        return int(req[0])
-
-    def _gettimeout(self):
-        """
-        Get watchdog timeout
-        @return watchdog timeout
-        """
-        timeout=0
-        timeout=self._read_sysfs_file(self.wd_timeout_reg)
-
-        return timeout
-
-    def _gettimeleft(self):
-        """
-        Get time left before watchdog timer expires
-        @return time left in seconds
-        """
-
-        req = array.array('I', [0])
-        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
-
-        return int(req[0])
-
-    def arm(self, seconds):
-        """
-        Implements arm WatchdogBase API
-        """
-
-        ret = WD_COMMON_ERROR
-        if (seconds < 0 or seconds > 340 ):
-            return ret
-        # Stop the watchdog service to gain access of watchdog file pointer
-        if self.is_armed():
-            os.popen("systemctl stop cpu_wdt.service")
-            time.sleep(2)
-        if not self.watchdog:
-            self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
-        try:
-            if self.timeout != seconds:
-                self.timeout = self._settimeout(seconds)
-            if self.is_armed():
-                self._keepalive()
-            else:
-                self._enablewatchdog()
-            ret = self.timeout
-        except IOError:
-            pass
-        if(ret == seconds):
-            self._write_sysfs_file(self.watchdog_gpio_reg, 0)
-        return ret
-
-    def disarm(self):
-        """
-        Implements disarm WatchdogBase API
-
-        Returns:
-            A boolean, True if watchdog is disarmed successfully, False
-            if not
-        """
-        
-        if self.is_armed():
-            os.popen("systemctl stop cpu_wdt.service")
-            time.sleep(2)
-            if not self.watchdog:
-                self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
-            try:
-                self._disablewatchdog()
-                self.timeout = 0
-            except IOError:
-                return False    
-        return True
-
-    def is_armed(self):
-        """
-        Implements is_armed WatchdogBase API
-        """
-        status = False
-
-        state = self._read_sysfs_file(self.wd_state_reg)
-        if (state != 'inactive'):
-            status = True
-
-        return status
-
-    def get_remaining_time(self):
-        """
-        Implements get_remaining_time WatchdogBase API
-        """
-
-        timeleft = WD_COMMON_ERROR
-
-        if self.is_armed():
-            timeleft=self._read_sysfs_file(self.wd_timeleft_reg)
-
-        return int(timeleft)
diff --git a/platform/marvell-arm64/sonic-platform-nokia/7215/utils/sonic_ssd.py b/platform/marvell-arm64/sonic-platform-nokia/7215/utils/sonic_ssd.py
deleted file mode 100644
index 563a0b22ce2..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/7215/utils/sonic_ssd.py
+++ /dev/null
@@ -1,47 +0,0 @@
-
-import os
-
-# pylint: disable=import-error
-from sonic_platform_base.sonic_ssd.ssd_base import SsdBase
-from sonic_platform_base.sonic_ssd.ssd_generic import SsdUtil as SsdUtilDefault
-
-class EmmcUtil(SsdBase):
-   def __init__(self, diskdev):
-      self.diskdev = diskdev
-      self.path = os.path.join('/sys/block', os.path.basename(diskdev))
-
-   def _readDeviceEntry(self, entry, default=None):
-      path = os.path.join(self.path, 'device', entry)
-      try:
-         with open(path, encoding='utf8') as f:
-            return f.read().rstrip()
-      except OSError:
-         return default
-
-   def _isSlc(self):
-      return bool(self._readDeviceEntry('enhanced_area_offset'))
-
-   def get_health(self):
-      data = self._readDeviceEntry('life_time')
-      if data is None:
-         raise NotImplementedError
-      value = int(data.split()[0 if self._isSlc() else 1], 0)
-      return float(100 - (10 * (value - 1)))
-
-   def get_temperature(self):
-      return 'N/A'
-
-   def get_model(self):
-      return self._readDeviceEntry('name')
-
-   def get_firmware(self):
-      return self._readDeviceEntry('fwrev')
-
-   def get_serial(self):
-      return self._readDeviceEntry('serial')
-
-   def get_vendor_output(self):
-      return ''
-
-def SsdUtil(diskdev):
-   return EmmcUtil('/dev/mmcblk0')
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/changelog b/platform/marvell-arm64/sonic-platform-nokia/debian/changelog
deleted file mode 100755
index f6573c957c5..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/changelog
+++ /dev/null
@@ -1,5 +0,0 @@
-sonic-platform-nokia-7215 (1.0) unstable; urgency=low
-
-  * Add support for nokia-7215.
-
- -- Nokia <pavan.prakash@nokia.com>  Fri, 20 Jan 2023 09:35:58 +0800
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/compat b/platform/marvell-arm64/sonic-platform-nokia/debian/compat
deleted file mode 100644
index ec635144f60..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/compat
+++ /dev/null
@@ -1 +0,0 @@
-9
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/control b/platform/marvell-arm64/sonic-platform-nokia/debian/control
deleted file mode 100755
index acab75a481e..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/control
+++ /dev/null
@@ -1,13 +0,0 @@
-Source: sonic-platform-nokia-7215
-Section: unknown
-Priority: optional
-Maintainer: Nokia <pavan.prakash@nokia.com>
-Build-Depends: debhelper (>=9)
-Standards-Version: 3.9.6
-Homepage: <insert the upstream URL, if relevant>
-
-Package: sonic-platform-nokia-7215
-Architecture: arm64
-Depends: ${misc:Depends}
-Description: <insert up to 60 chars description>
- <insert long description, indented with spaces>
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/rules b/platform/marvell-arm64/sonic-platform-nokia/debian/rules
deleted file mode 100755
index de6ed670d0c..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/rules
+++ /dev/null
@@ -1,84 +0,0 @@
-#!/usr/bin/make -f
-# See debhelper(7) (uncomment to enable)
-# output every command that modifies files on the build system.
-#export DH_VERBOSE = 1
-
-include /usr/share/dpkg/pkg-info.mk
-#--------------------------------------------------------
-
-PACKAGE_PRE_NAME := sonic-platform-nokia
-ifneq ($(CROSS_BUILD_ENVIRON), y)
-KVERSION   ?= $(shell uname -r)
-endif
-KERNEL_SRC :=  /lib/modules/$(KVERSION)
-INSTALL_MOD_DIR := kernel/extra/
-MOD_SRC_DIR:= $(shell pwd)
-MODULE_DIRS:= 7215
-UTILS_DIR := utils
-MODULE_DIR:= modules
-MRVL_MODULE_DIR:= mrvl-modules
-PRESTERA_MODULE_SRC := mrvl-prestera/drivers/generic/cpssEnabler/linuxNoKernelModule/drivers
-SERVICE_DIR := service
-PLATFORM_DIR := sonic_platform
-
-%:
-	dh $@ --with systemd,python3 --buildsystem=pybuild
-
-clean:
-	dh_testdir
-	dh_testroot
-	dh_clean
-
-build:
-	(for mod in $(MODULE_DIRS); do \
-		cd $(MOD_SRC_DIR)/../$(PRESTERA_MODULE_SRC)/; \
-		make clean; \
-		make modules -C $(KERNEL_SRC)/build M=`pwd` CONFIG_KM_MVPCI=y CONFIG_KM_MVINT=y || exit 1; \
-		mkdir $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR); \
-		cp *.ko $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/; \
-		cd $(MOD_SRC_DIR); \
-		make modules -C $(KERNEL_SRC)/build M=$(MOD_SRC_DIR)/$${mod}/modules || exit 1; \
-		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
-	done)
-
-binary: binary-arch binary-indep
-	# Nothing to do
-
-binary-arch:
-	# Nothing to do
-
-binary-indep:
-	dh_testdir
-	dh_installdirs
-
-	# Custom package commands
-	(for mod in $(MODULE_DIRS); do \
-		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
-		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
-		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /boot; \
-		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /lib/systemd/system; \
-		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
-		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
-		cp $(MOD_SRC_DIR)/$${mod}/$(MRVL_MODULE_DIR)/mvcpss.ko debian/$(PACKAGE_PRE_NAME)-$${mod}/$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
-		cp $(MOD_SRC_DIR)/$${mod}/$(MODULE_DIR)/*.ko debian/$(PACKAGE_PRE_NAME)-$${mod}/$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
-		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
-	done)
-
-	# Resuming debhelper scripts
-	dh_testroot
-	dh_install
-	dh_installchangelogs
-	dh_installdocs
-	dh_systemd_enable
-	dh_installinit
-	dh_systemd_start
-	dh_link
-	dh_fixperms
-	dh_compress
-	dh_strip
-	dh_installdeb
-	dh_gencontrol
-	dh_md5sums
-	dh_builddeb
-
-.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install b/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
deleted file mode 100644
index efa3c696be2..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
+++ /dev/null
@@ -1,6 +0,0 @@
-7215/scripts/nokia-7215-init.sh usr/local/bin
-7215/scripts/cpu_wdt.py  usr/local/bin
-7215/service/nokia-7215init.service  etc/systemd/system
-7215/service/cpu_wdt.service  etc/systemd/system
-7215/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-nokia_ixs7215_52xb-r0
-../mrvl-prestera/platform/arm64/ac5x/* /
diff --git a/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst b/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
deleted file mode 100644
index 949cd1a289e..00000000000
--- a/platform/marvell-arm64/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/bin/sh
-# postinst script for sonic-platform-nokia-7215
-#
-# see: dh_installdeb(1)
-
-set -e
-
-# summary of how this script can be called:
-#        * <postinst> `configure' <most-recently-configured-version>
-#        * <old-postinst> `abort-upgrade' <new version>
-#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
-#          <new-version>
-#        * <postinst> `abort-remove'
-#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
-#          <failed-install-package> <version> `removing'
-#          <conflicting-package> <version>
-# for details, see https://www.debian.org/doc/debian-policy/ or
-# the debian-policy package
-
-
-case "$1" in
-    configure)
-        chmod a+x /usr/local/bin/nokia-7215-init.sh
-        depmod -a
-        systemctl restart kmod
-        systemctl enable nokia-7215init.service
-        systemctl start nokia-7215init.service
-
-        systemctl enable cpu_wdt.service
-        systemctl start cpu_wdt.service
-
-    ;;
-
-    abort-upgrade|abort-remove|abort-deconfigure)
-    ;;
-
-    *)
-        echo "postinst called with unknown argument \`$1'" >&2
-        exit 1
-    ;;
-esac
-
-# dh_installdeb will replace this with shell code automatically
-# generated by other debhelper scripts.
-
-#DEBHELPER#
-
-exit 0
diff --git a/platform/marvell-arm64/sonic_fit.its b/platform/marvell-arm64/sonic_fit.its
deleted file mode 100644
index 3208388d980..00000000000
--- a/platform/marvell-arm64/sonic_fit.its
+++ /dev/null
@@ -1,151 +0,0 @@
-/dts-v1/;
-  
-/ {
-    description = "U-Boot fitImage for SONIC Marvell Arm64";
-    #address-cells = <1>;
-  
-    images {
-        kernel_ac5x {
-            description = "Linux Kernel for AC5x";
-            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
-            type = "kernel";
-            arch = "arm64";
-            os = "linux";
-            compression = "none";
-            load = <0x2 0x2080000>;
-            entry = <0x2 0x2080000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        fdt_ac5x {
-            description = "Flattened Device Tree blob for AC5x";
-            data = /incbin/("/usr/lib/linux-image-6.1.0-11-2-arm64/marvell/ac5-98dx35xx-rd.dtb");
-            type = "flat_dt";
-            arch = "arm64";
-            compression = "none";
-            load = <0x2 0x1000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        fdt_7215_a1 {
-            description = "Flattened Device Tree blob for 7215_IXS_A1";
-            data = /incbin/("/usr/lib/linux-image-6.1.0-11-2-arm64/marvell/7215-ixs-a1.dtb");
-            type = "flat_dt";
-            arch = "arm64";
-            compression = "none";
-            load = <0x11000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        ramdisk_ac5x {
-            description = "ramdisk for AC5x";
-            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
-            type = "ramdisk";
-            arch = "arm64";
-            os = "linux";
-            compression = "gzip";
-            load = <0x2 0x6000000>;
-            entry = <0x2 0x6000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        kernel_1 {
-            description = "Linux Kernel";
-            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
-            type = "kernel";
-            arch = "arm64";
-            os = "linux";
-            compression = "none";
-            load = <0x1000000>;
-            entry = <0x1000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        ramdisk_1 {
-            description = "ramdisk";
-            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
-            type = "ramdisk";
-            arch = "arm64";
-            os = "linux";
-            compression = "gzip";
-            load = <0x6000000>;
-            entry = <0x6000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        kernel_2 {
-            description = "Linux Kernel";
-            data = /incbin/("/boot/vmlinuz-6.1.0-11-2-arm64");
-            type = "kernel";
-            arch = "arm64";
-            os = "linux";
-            compression = "none";
-            load = <0x12000000>;
-            entry = <0x12000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        ramdisk_2 {
-            description = "ramdisk";
-            data = /incbin/("/boot/initrd.img-6.1.0-11-2-arm64");
-            type = "ramdisk";
-            arch = "arm64";
-            os = "linux";
-            compression = "gzip";
-            load = <0x18000000>;
-            entry = <0x18000000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        fdt_cn9131 {
-            description = "Flattened Device Tree blob";
-            data = /incbin/("/boot/cn9131-db-comexpress.dtb");
-            type = "flat_dt";
-            arch = "arm64";
-            compression = "none";
-            load = <0x0a00000>;
-            entry = <0x0a00000>;
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-    };
-    configurations {
-        default = "conf_ac5x";
-        conf_ac5x {
-            description = "Boot Linux kernel with FDT blob + ramdisk for RD_AC5x";
-            kernel = "kernel_ac5x";
-            fdt = "fdt_ac5x";
-            ramdisk = "ramdisk_ac5x";
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        conf_7215_a1 {
-            description = "Boot Linux kernel with FDT blob + ramdisk for 7125_IXS_A1";
-            kernel = "kernel_2";
-            fdt = "fdt_7215_a1";
-            ramdisk = "ramdisk_2";
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-        conf_cn9131 {
-            description = "Boot Linux kernel with FDT blob + ramdisk for CN9131";
-            kernel = "kernel_1";
-            fdt = "fdt_cn9131";
-            ramdisk = "ramdisk_1";
-            hash@1 {
-                algo = "sha1";
-            };
-        };
-   };
-};
diff --git a/platform/marvell-armhf/docker-saiserver-mrvl.dep b/platform/marvell-armhf/docker-saiserver-mrvl.dep
deleted file mode 100644
index 73851b9bf3e..00000000000
--- a/platform/marvell-armhf/docker-saiserver-mrvl.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-DPATH       := $($(DOCKER_SAISERVER_MRVL)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/docker-saiserver-mrvl.mk platform/marvell-armhf/docker-saiserver-mrvl.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SAISERVER_MRVL)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(DOCKER_SAISERVER_MRVL)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SAISERVER_MRVL)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/docker-saiserver-mrvl.mk b/platform/marvell-armhf/docker-saiserver-mrvl.mk
deleted file mode 100644
index 963335b5790..00000000000
--- a/platform/marvell-armhf/docker-saiserver-mrvl.mk
+++ /dev/null
@@ -1,15 +0,0 @@
-# docker image for mrvl saiserver
-
-DOCKER_SAISERVER_MRVL = docker-saiserver-mrvl.gz
-$(DOCKER_SAISERVER_MRVL)_PATH = $(PLATFORM_PATH)/docker-saiserver-mrvl
-$(DOCKER_SAISERVER_MRVL)_DEPENDS += $(SAISERVER)
-$(DOCKER_SAISERVER_MRVL)_FILES += $(DSSERVE) $(BCMCMD)
-$(DOCKER_SAISERVER_MRVL)_LOAD_DOCKERS += $(DOCKER_CONFIG_ENGINE_BULLSEYE)
-SONIC_DOCKER_IMAGES += $(DOCKER_SAISERVER_MRVL)
-
-$(DOCKER_SAISERVER_MRVL)_CONTAINER_NAME = saiserver
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += --privileged -t
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /var/run/docker-saiserver:/var/run/sswsyncd
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
-$(DOCKER_SAISERVER_MRVL)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc.dep b/platform/marvell-armhf/docker-syncd-mrvl-rpc.dep
deleted file mode 100644
index 957d3f9e7ab..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-DPATH       := $($(DOCKER_SYNCD_MRVL_RPC)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep   
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SYNCD_MRVL_RPC)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(DOCKER_SYNCD_MRVL_RPC)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SYNCD_MRVL_RPC)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc.mk b/platform/marvell-armhf/docker-syncd-mrvl-rpc.mk
deleted file mode 100644
index 20698efdf9e..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc.mk
+++ /dev/null
@@ -1,25 +0,0 @@
-# docker image for mrvl syncd with rpc
-
-DOCKER_SYNCD_MRVL_RPC = docker-syncd-mrvl-rpc.gz
-$(DOCKER_SYNCD_MRVL_RPC)_PATH = $(PLATFORM_PATH)/docker-syncd-mrvl-rpc
-$(DOCKER_SYNCD_MRVL_RPC)_DEPENDS += $(SYNCD_RPC) $(LIBTHRIFT) $(PTF)
-$(DOCKER_SYNCD_MRVL_RPC)_FILES += $(SUPERVISOR_PROC_EXIT_LISTENER_SCRIPT)
-ifeq ($(INSTALL_DEBUG_TOOLS), y)
-$(DOCKER_SYNCD_MRVL_RPC)_DEPENDS += $(SYNCD_RPC_DBG) \
-                                    $(LIBSWSSCOMMON_DBG) \
-                                    $(LIBSAIMETADATA_DBG) \
-                                    $(LIBSAIREDIS_DBG)
-endif
-$(DOCKER_SYNCD_MRVL_RPC)_LOAD_DOCKERS += $(DOCKER_SYNCD_BASE)
-SONIC_DOCKER_IMAGES += $(DOCKER_SYNCD_MRVL_RPC)
-ifeq ($(ENABLE_SYNCD_RPC),y)
-SONIC_INSTALL_DOCKER_IMAGES += $(DOCKER_SYNCD_MRVL_RPC)
-endif
-
-$(DOCKER_SYNCD_MRVL_RPC)_CONTAINER_NAME = syncd
-$(DOCKER_SYNCD_MRVL_RPC)_VERSION = 1.0.0+rpc
-$(DOCKER_SYNCD_MRVL_RPC)_PACKAGE_NAME = syncd
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += --privileged -t
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/machine.conf:/etc/machine.conf
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /etc/sonic:/etc/sonic:ro
-$(DOCKER_SYNCD_MRVL_RPC)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc/99-syncd.conf b/platform/marvell-armhf/docker-syncd-mrvl-rpc/99-syncd.conf
deleted file mode 100644
index 3fabe208d81..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc/99-syncd.conf
+++ /dev/null
@@ -1 +0,0 @@
-sysctl -w net.core.rmem_max=509430500
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
deleted file mode 100644
index b8bd6f64e71..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ /dev/null
@@ -1,56 +0,0 @@
-FROM docker-syncd-mrvl-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
-
-## Make apt-get non-interactive
-ENV DEBIAN_FRONTEND=noninteractive
-
-COPY \
-{% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor -%}
-debs/
-
-RUN apt-get purge -y syncd
-
-## Pre-install the fundamental packages
-RUN apt-get update \
- && apt-get -y install  \
-    net-tools           \
-    python3-pip         \
-    python-setuptools   \
-    build-essential     \
-    libssl-dev          \
-    libffi-dev          \
-    python-dev          \
-    wget                \
-    cmake               \
-    libqt5core5a        \
-    libqt5network5      \
-    libboost-atomic1.74.0
-
-RUN dpkg_apt() { [ -f $1 ] && { dpkg -i $1 || apt-get -y install -f; } || return 1; } ; \
-{% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
-dpkg_apt debs/{{ deb }}{{'; '}}
-{%- endfor %}
-
-RUN wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
- && tar xvfz 1.0.0.tar.gz \
- && cd nanomsg-1.0.0    \
- && mkdir -p build      \
- && cmake .             \
- && make install        \
- && ldconfig            \
- && cd ..               \
- && rm -fr nanomsg-1.0.0 \
- && rm -f 1.0.0.tar.gz  \
- && pip2 install cffi==1.7.0    \
- && pip2 install --upgrade cffi==1.7.0 \
- && pip2 install nnpy    \
- && mkdir -p /opt       \
- && cd /opt             \
- && wget https://raw.githubusercontent.com/p4lang/ptf/master/ptf_nn/ptf_nn_agent.py \
- && apt-get clean -y; apt-get autoclean -y; apt-get autoremove -y \
- && rm -rf /root/deps
-
-COPY ["ptf_nn_agent.conf", "/etc/supervisor/conf.d/"]
-
-ENTRYPOINT ["/usr/local/bin/supervisord"]
diff --git a/platform/marvell-armhf/docker-syncd-mrvl-rpc/ptf_nn_agent.conf b/platform/marvell-armhf/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
deleted file mode 100644
index fa1ed0eb162..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl-rpc/ptf_nn_agent.conf
+++ /dev/null
@@ -1,10 +0,0 @@
-[program:ptf_nn_agent]
-command=/usr/bin/python /opt/ptf_nn_agent.py --device-socket 1@tcp://0.0.0.0:10900 -i 1-3@Ethernet12 --set-iface-rcv-buffer=109430400
-process_name=ptf_nn_agent
-stdout_logfile=/tmp/ptf_nn_agent.out.log
-stderr_logfile=/tmp/ptf_nn_agent.err.log
-redirect_stderr=false
-autostart=true
-autorestart=true
-startsecs=1
-numprocs=1
diff --git a/platform/marvell-armhf/docker-syncd-mrvl.dep b/platform/marvell-armhf/docker-syncd-mrvl.dep
deleted file mode 100644
index 2aaef3b506f..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl.dep
+++ /dev/null
@@ -1,10 +0,0 @@
-DPATH       := $($(DOCKER_SYNCD_BASE)_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/docker-syncd-mrvl.mk platform/marvell-armhf/docker-syncd-mrvl.dep platform/marvell-armhf/sai.mk
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(DPATH))
-
-$(DOCKER_SYNCD_BASE)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(DOCKER_SYNCD_BASE)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(DOCKER_SYNCD_BASE)_DEP_FILES   := $(DEP_FILES)
-
-$(eval $(call add_dbg_docker,$(DOCKER_SYNCD_BASE),$(DOCKER_SYNCD_BASE_DBG)))
diff --git a/platform/marvell-armhf/docker-syncd-mrvl.mk b/platform/marvell-armhf/docker-syncd-mrvl.mk
deleted file mode 100644
index 236f8a437b4..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-# docker image for mrvl syncd
-
-DOCKER_SYNCD_PLATFORM_CODE = mrvl
-include $(PLATFORM_PATH)/../template/docker-syncd-bullseye.mk
-
-$(DOCKER_SYNCD_BASE)_DEPENDS += $(SYNCD)
-
-$(DOCKER_SYNCD_BASE)_DBG_DEPENDS += $(SYNCD_DBG) \
-                                $(LIBSWSSCOMMON_DBG) \
-                                $(LIBSAIMETADATA_DBG) \
-                                $(LIBSAIREDIS_DBG)
-
-$(DOCKER_SYNCD_BASE)_VERSION = 1.0.0
-$(DOCKER_SYNCD_BASE)_PACKAGE_NAME = syncd
-
-#$(DOCKER_SYNCD_BASE)_RUN_OPT += -v /host/warmboot:/var/warmboot
diff --git a/platform/marvell-armhf/docker-syncd-mrvl/Dockerfile.j2 b/platform/marvell-armhf/docker-syncd-mrvl/Dockerfile.j2
deleted file mode 100755
index 84e3d5bde2f..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl/Dockerfile.j2
+++ /dev/null
@@ -1,37 +0,0 @@
-{% from "dockers/dockerfile-macros.j2" import install_debian_packages %}
-FROM docker-config-engine-bullseye-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
-
-ARG docker_container_name
-
-## Make apt-get non-interactive
-ENV DEBIAN_FRONTEND=noninteractive
-
-RUN apt-get update
-
-COPY \
-{% for deb in docker_syncd_mrvl_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor -%}
-debs/
-
-RUN apt-get update \
- && apt-get -y install  \
-    net-tools           \
-    iputils-ping
-
-RUN apt-get -y install libpcap-dev libxml2-dev python-dev swig libsensors4-dev nfs-common
-
-RUN dpkg -i \
-{% for deb in docker_syncd_mrvl_debs.split(' ') -%}
-debs/{{ deb }}{{' '}}
-{%- endfor %}
-
-COPY ["supervisord.conf", "/etc/supervisor/conf.d/"]
-COPY ["files/supervisor-proc-exit-listener", "/usr/bin/"]
-COPY ["critical_processes", "/etc/supervisor/"]
-
-## Clean up
-RUN apt-get clean -y; apt-get autoclean -y; apt-get autoremove -y
-RUN rm -rf /debs
-
-ENTRYPOINT ["/usr/local/bin/supervisord"]
diff --git a/platform/marvell-armhf/docker-syncd-mrvl/critical_processes b/platform/marvell-armhf/docker-syncd-mrvl/critical_processes
deleted file mode 100644
index bdd6903c569..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl/critical_processes
+++ /dev/null
@@ -1 +0,0 @@
-program:syncd
diff --git a/platform/marvell-armhf/docker-syncd-mrvl/supervisord.conf b/platform/marvell-armhf/docker-syncd-mrvl/supervisord.conf
deleted file mode 100644
index 55f095d2be9..00000000000
--- a/platform/marvell-armhf/docker-syncd-mrvl/supervisord.conf
+++ /dev/null
@@ -1,39 +0,0 @@
-[supervisord]
-logfile_maxbytes=1MB
-logfile_backups=2
-nodaemon=true
-
-[eventlistener:dependent-startup]
-command=python3 -m supervisord_dependent_startup
-autostart=true
-autorestart=unexpected
-startretries=0
-exitcodes=0,3
-events=PROCESS_STATE
-buffer_size=1024
-
-[eventlistener:supervisor-proc-exit-listener]
-command=python3 /usr/bin/supervisor-proc-exit-listener --container-name syncd
-events=PROCESS_STATE_EXITED,PROCESS_STATE_RUNNING
-autostart=true
-autorestart=unexpected
-buffer_size=1024
-
-[program:rsyslogd]
-command=/usr/sbin/rsyslogd -n -iNONE
-priority=1
-autostart=false
-autorestart=false
-stdout_logfile=syslog
-stderr_logfile=syslog
-dependent_startup=true
-
-[program:syncd]
-command=/usr/bin/syncd_start.sh
-priority=2
-autostart=false
-autorestart=false
-stdout_logfile=syslog
-stderr_logfile=syslog
-dependent_startup=true
-dependent_startup_wait_for=rsyslogd:running
diff --git a/platform/marvell-armhf/libsaithrift-dev.dep b/platform/marvell-armhf/libsaithrift-dev.dep
deleted file mode 100644
index be9da37e8d0..00000000000
--- a/platform/marvell-armhf/libsaithrift-dev.dep
+++ /dev/null
@@ -1,11 +0,0 @@
-SPATH       := $($(LIBSAITHRIFT_DEV)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/libsaithrift-dev.mk platform/marvell-armhf/libsaithrift-dev.dep   
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-SMDEP_PATHS := $(SPATH)  $(SPATH)/bm/behavioral-model  $(SPATH)/test/ptf  $(SPATH)/test/saithrift/ctypesgen
-$(foreach path, $(SMDEP_PATHS), $(eval $(path) :=$(filter-out $(SMDEP_PATHS),$(addprefix $(path)/, $(shell cd $(path) &&  git ls-files | grep -Ev " " )))))
-
-$(LIBSAITHRIFT_DEV)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(LIBSAITHRIFT_DEV)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(LIBSAITHRIFT_DEV)_DEP_FILES   := $(DEP_FILES)
-$(LIBSAITHRIFT_DEV)_SMDEP_FILES := $(foreach path, $(SMDEP_PATHS), $($(path)))
-$(LIBSAITHRIFT_DEV)_SMDEP_PATHS := $(SMDEP_PATHS)
diff --git a/platform/marvell-armhf/libsaithrift-dev.mk b/platform/marvell-armhf/libsaithrift-dev.mk
deleted file mode 100644
index e1c3da156ec..00000000000
--- a/platform/marvell-armhf/libsaithrift-dev.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-# libsaithrift-dev package
-
-SAI_VER = 0.9.4
-
-LIBSAITHRIFT_DEV = libsaithrift-dev_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(LIBSAITHRIFT_DEV)_SRC_PATH = $(SRC_PATH)/sonic-sairedis/SAI
-$(LIBSAITHRIFT_DEV)_DEPENDS += $(LIBTHRIFT) $(LIBTHRIFT_DEV) $(PYTHON_THRIFT) $(THRIFT_COMPILER) $(MRVL_FPA) $(MRVL_SAI)
-$(LIBSAITHRIFT_DEV)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
-SONIC_DPKG_DEBS += $(LIBSAITHRIFT_DEV)
-
-PYTHON_SAITHRIFT = python-saithrift_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(PYTHON_SAITHRIFT)))
-
-SAISERVER = saiserver_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(SAISERVER)_RDEPENDS += $(LIBTHRIFT) $(MRVL_SAI)
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER)))
-
-SAISERVER_DBG = saiserver-dbg_$(SAI_VER)_$(CONFIGURED_ARCH).deb
-$(SAISERVER_DBG)_RDEPENDS += $(SAISERVER)
-$(eval $(call add_extra_package,$(LIBSAITHRIFT_DEV),$(SAISERVER_DBG)))
diff --git a/platform/marvell-armhf/one-image.dep b/platform/marvell-armhf/one-image.dep
deleted file mode 100644
index 154112a82ab..00000000000
--- a/platform/marvell-armhf/one-image.dep
+++ /dev/null
@@ -1 +0,0 @@
-$(SONIC_ONE_IMAGE)_CACHE_MODE  := none
diff --git a/platform/marvell-armhf/one-image.mk b/platform/marvell-armhf/one-image.mk
deleted file mode 100644
index b72b553487f..00000000000
--- a/platform/marvell-armhf/one-image.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-# sonic marvell one image installer
-
-SONIC_ONE_IMAGE = sonic-marvell-armhf.bin
-$(SONIC_ONE_IMAGE)_MACHINE = marvell-armhf
-$(SONIC_ONE_IMAGE)_IMAGE_TYPE = onie
-$(SONIC_ONE_IMAGE)_INSTALLS += $(SYSTEMD_SONIC_GENERATOR)
-$(SONIC_ONE_IMAGE)_INSTALLS += $(MRVL_PRESTERA_DEB)
-$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(ET6448M_PLATFORM) \
-				$(NOKIA_7215_PLATFORM)
-ifeq ($(INSTALL_DEBUG_TOOLS),y)
-$(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
-$(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
-else
-$(SONIC_ONE_IMAGE)_DOCKERS = $(SONIC_INSTALL_DOCKER_IMAGES)
-endif
-SONIC_INSTALLERS += $(SONIC_ONE_IMAGE)
diff --git a/platform/marvell-armhf/platform-et6448m.dep b/platform/marvell-armhf/platform-et6448m.dep
deleted file mode 100644
index 5f7e41d1f74..00000000000
--- a/platform/marvell-armhf/platform-et6448m.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-MPATH       := $($(ET6448M_PLATFORM)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/platform-et6448m.mk platform/marvell-armhf/platform-et6448m.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(MPATH))
-
-$(ET6448M_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(ET6448M_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(ET6448M_PLATFORM)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/platform-et6448m.mk b/platform/marvell-armhf/platform-et6448m.mk
deleted file mode 100644
index 1f0ee201cc7..00000000000
--- a/platform/marvell-armhf/platform-et6448m.mk
+++ /dev/null
@@ -1,8 +0,0 @@
-# ET6448M Platform
-
-ET6448M_VERSION=0.1
-ET6448M_PLATFORM = sonic-platform-et6448m_$(ET6448M_VERSION)_$(CONFIGURED_ARCH).deb
-$(ET6448M_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-et6448m
-$(ET6448M_PLATFORM)_PLATFORM = armhf-marvell_et6448m_52x-r0
-SONIC_DPKG_DEBS += $(ET6448M_PLATFORM)
-
diff --git a/platform/marvell-armhf/platform-nokia.dep b/platform/marvell-armhf/platform-nokia.dep
deleted file mode 100644
index 752a2016b6c..00000000000
--- a/platform/marvell-armhf/platform-nokia.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-MPATH       := $($(NOKIA_7215_PLATFORM)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/platform-nokia.mk platform/marvell-armhf/platform-nokia.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(MPATH))
-
-$(NOKIA_7215_PLATFORM)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(NOKIA_7215_PLATFORM)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(NOKIA_7215_PLATFORM)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/platform-nokia.mk b/platform/marvell-armhf/platform-nokia.mk
deleted file mode 100644
index e8d6d106d65..00000000000
--- a/platform/marvell-armhf/platform-nokia.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-# Nokia Platform
-
-NOKIA_7215_PLATFORM_VERSION = 1.0
-export NOKIA_7215_PLATFORM_VERSION
-
-NOKIA_7215_PLATFORM = sonic-platform-nokia-7215_$(NOKIA_7215_PLATFORM_VERSION)_$(CONFIGURED_ARCH).deb
-$(NOKIA_7215_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-nokia
-$(NOKIA_7215_PLATFORM)_PLATFORM = armhf-nokia_ixs7215_52x-r0
-SONIC_DPKG_DEBS += $(NOKIA_7215_PLATFORM)
-
diff --git a/platform/marvell-armhf/platform.conf b/platform/marvell-armhf/platform.conf
deleted file mode 100644
index 931cddd12a4..00000000000
--- a/platform/marvell-armhf/platform.conf
+++ /dev/null
@@ -1,303 +0,0 @@
-#  Copyright (C) Marvell Inc
-
-# over ride default behaviour
-
-echo "Preparing for installation ... "
-
-# global defines
-kernel_addr=0x1100000
-fdt_addr=0x2800000
-fdt_high=0x28fffff
-initrd_addr=0x2900000
-
-kernel_fname="/boot/vmlinuz-6.1.0-11-2-armmp"
-initrd_fname="/boot/initrd.img-6.1.0-11-2-armmp"
-fdt_fname="/boot/armada-385-ET6448M_4G_Nand.dtb"
-
-if [ "$install_env" = "onie" ]; then
-    MACH_FILE="/etc/machine.conf"
-else
-    MACH_FILE="/host/machine.conf"
-fi
-# armhf-marvell_et6448m_52x-r0  - Platform = Et6448M
-# armhf-nokia_ixs7215_52x-r0 - Platform = Nokia IPD6448M
-PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
-echo "Intalling SONiC from $install_env on Platform $PLATFORM"
-
-# global mount defines
-if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
-    demo_dev=ubi0
-    mtd_dev=/dev/$(cat /proc/mtd | grep "SONIC" | grep -o "mtd[0-9]")
-    mtd_num=$(echo $mtd_dev | grep -o "[0-9]")
-
-    fdt_fname="/boot/armada-385-ET6448M_4G_Nand.dtb"
-
-    BOOTARGS='setenv bootargs root='$demo_dev' rw rootwait ubi.mtd='$mtd_num' rootfstype=ubifs panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs}'
-    UBI_LOAD='run ubi_sonic_boot_mount_ubi; ubifsload $kernel_addr $image_name;ubifsload $fdt_addr $fdt_name; ubifsload $initrd_addr $initrd_name'
-    BOOTARGS_OLD='setenv bootargs root='$demo_dev' rw rootwait ubi.mtd='$mtd_num' rootfstype=ubifs panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs_old}'
-    UBI_LOAD_OLD='run ubi_sonic_boot_mount_ubi; ubifsload $kernel_addr $image_name_old;ubifsload $fdt_addr $fdt_name_old; ubifsload $initrd_addr $initrd_name_old'
-    UBIBOOTCMD='run ubi_sonic_boot_bootargs; run ubi_sonic_boot_load; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
-    UBIBOOTCMD_OLD='run ubi_sonic_boot_bootargs_old; run ubi_sonic_boot_load_old; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
-    LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
-
-elif [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
-    demo_dev=sda2
-
-    fdt_fname="/boot/armada-385-ipd6448m.dtb"
-
-    BOOTARGS='setenv bootargs root=/dev/'$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs}'
-    UBI_LOAD='scsi init; ext4load scsi 0:2 $kernel_addr $image_name; ext4load scsi 0:2 $fdt_addr $fdt_name; ext4load scsi 0:2 $initrd_addr $initrd_name'
-    BOOTARGS_OLD='setenv bootargs root=/dev/'$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,${baudrate} ${othbootargs} ${mtdparts} ${linuxargs_old}'
-    UBI_LOAD_OLD='scsi init; ext4load scsi 0:2 $kernel_addr $image_name_old; ext4load scsi 0:2 $fdt_addr $fdt_name_old; ext4load scsi 0:2 $initrd_addr $initrd_name_old'
-    UBIBOOTCMD='run ubi_sonic_boot_bootargs; run ubi_sonic_boot_load; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
-    UBIBOOTCMD_OLD='run ubi_sonic_boot_bootargs_old; run ubi_sonic_boot_load_old; test -n "$boot_once" && setenv boot_once "" && saveenv; bootz $kernel_addr $initrd_addr $fdt_addr'
-    LINUX_MISC_CMD='apparmor=1 security=apparmor usbcore.autosuspend=-1'
-
-else
-    echo "Unsupported Platform $PLAFORM"
-    exit 2
-fi
-demo_mnt=/tmp
-FW_ENV_DEFAULT='/dev/mtd0 0x00500000 0x80000 0x100000 8'
-UBOOT_FW_DEFAULT=1
-
-prepare_boot_menu() {
-    echo "Sync up cache ..."
-    sync
-    echo "Setting up U-Boot environment..."
-
-    DTB_HAS_ENV_BLK=$(grep uboot-env /proc/mtd | sed -e 's/:.*$//')
-    if [ -c "/dev/$DTB_HAS_ENV_BLK" ]; then
-        PROC_ENV_FILE=$(find /proc/device-tree/ -name env_size)
-        if [ -n "$PROC_ENV_FILE" ]
-        then
-            UBOOT_ENV_SIZ="0x$(hd $PROC_ENV_FILE | awk 'FNR==1 {print $2 $3 $4 $5}')"
-            UBOOT_ENV_ERASE_SIZ="0x$(grep uboot-env /proc/mtd | awk '{print $3}')"
-            if [[ -n "$UBOOT_ENV_SIZ" && -n "$UBOOT_ENV_ERASE_SIZ" ]]
-            then
-                # Env info from DTB 
-                FW_ENV_DTB="/dev/$DTB_HAS_ENV_BLK 0x00000000 $UBOOT_ENV_SIZ $UBOOT_ENV_ERASE_SIZ"
-            fi
-        fi
-    fi
-    if [ -n "$FW_ENV_DTB" ]
-    then
-                echo $FW_ENV_DTB > /etc/fw_env.config
-                echo "Found uboot env offset in device tree"
-                UBOOT_ENV_CRC=$(fw_printenv 2>&1 | grep -c 'Warning: Bad CRC') || true
-                if [ "$UBOOT_ENV_CRC" -eq 0 ]
-                then
-                    echo "Uboot env offset in device tree is valid"
-                    UBOOT_FW_DEFAULT=0
-                    fdt_fname="/boot/armada-385-ET6448M_4G_Nand_r2019.dtb"
-                else
-                    echo "Uboot env offset in device tree is NOT valid"
-                    UBOOT_FW_DEFAULT=1
-                fi
-    fi
-    if [ $UBOOT_FW_DEFAULT -eq 1 ]
-    then
-        echo $FW_ENV_DEFAULT > /etc/fw_env.config
-        echo "Using pre-configured uboot env"
-    fi
-    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
-        FW_ENV_DEFAULT='/dev/mtd0 0x00100000 0x10000 0x10000'
-        echo $FW_ENV_DEFAULT > /etc/fw_env.config
-        echo "Using pre-configured uboot env for armhf-nokia_ixs7215_52x-r0"
-    fi
-
-    image_name=${image_dir}${kernel_fname}
-    initrd_name=${image_dir}${initrd_fname}
-    fdt_name=${image_dir}${fdt_fname}
-
-    if [ "$install_env" = "onie" ]; then
-        FW_ARG="-f"
-        image_dir_old=""
-        image_name_old=""
-        initrd_name_old=""
-        fdt_name_old=""
-        sonic_version_2="None"
-    else
-        eval running_version="$(cat /proc/cmdline | sed -n 's/^.*loop=\/*image-\(\S\+\)\/.*$/\1/p')"
-        current_boot_next=$(fw_printenv -n boot_next || true)
-        running_sonic_image=1
-        if [ "$current_boot_next" = "run sonic_image_1" ]; then
-            # boot_next=run sonic_image_1
-            sonic_version_2=$(fw_printenv -n sonic_version_2 || true)
-            if test "${sonic_version_2#*$running_version}" != "$sonic_version_2"
-            then
-                running_sonic_image=2
-            else
-                running_sonic_image=1
-            fi
-        else
-            # boot_next=run sonic_image_2  
-            sonic_version_1=$(fw_printenv -n sonic_version_1 || true)
-            if test "${sonic_version_1#*$running_version}" != "$sonic_version_1"
-            then
-                running_sonic_image=1
-            else
-                running_sonic_image=2
-            fi
-        fi   
-        
-        if [ $running_sonic_image -eq 1 ]; then
-            image_dir_old=$(fw_printenv -n image_dir || true)
-            image_name_old=$(fw_printenv -n image_name || true)
-            initrd_name_old=$(fw_printenv -n initrd_name || true)
-            fdt_name_old=$(fw_printenv -n fdt_name || true)
-            sonic_version_2=$(fw_printenv -n sonic_version_1 || true)
-        else
-            image_dir_old=$(fw_printenv -n image_dir_old || true)
-            image_name_old=$(fw_printenv -n image_name_old || true)
-            initrd_name_old=$(fw_printenv -n initrd_name_old || true)
-            fdt_name_old=$(fw_printenv -n fdt_name_old || true)
-            sonic_version_2=$(fw_printenv -n sonic_version_2 || true)
-        fi
-    fi
-
-    # Set boot variables
-    fw_setenv ${FW_ARG} image_dir $image_dir > /dev/null
-    fw_setenv ${FW_ARG} image_name $image_name > /dev/null
-    fw_setenv ${FW_ARG} initrd_name $initrd_name > /dev/null
-    fw_setenv ${FW_ARG} fdt_name $fdt_name > /dev/null
-    fw_setenv ${FW_ARG} sonic_version_1 $demo_volume_revision_label > /dev/null
-    fw_setenv ${FW_ARG} image_dir_old $image_dir_old > /dev/null
-    fw_setenv ${FW_ARG} image_name_old $image_name_old > /dev/null
-    fw_setenv ${FW_ARG} initrd_name_old $initrd_name_old > /dev/null
-    fw_setenv ${FW_ARG} fdt_name_old $fdt_name_old > /dev/null
-    fw_setenv ${FW_ARG} sonic_version_2 $sonic_version_2 > /dev/null
-    BOOT1='echo " > Boot1: $sonic_version_1 - run sonic_image_1";echo;'
-    BOOT2='echo " > Boot2: $sonic_version_2 - run sonic_image_2";echo;'
-    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
-        BOOT3='echo " > Boot3: ONIE - run onie_bootcmd";echo;'
-    else
-        BOOT3='echo " > Boot3: ONIE - run onie_nand_boot";echo;'
-    fi
-    BORDER='echo "---------------------------------------------------";echo;'
-    fw_setenv ${FW_ARG} print_menu "$BORDER $BOOT1 $BOOT2 $BOOT3 $BORDER" > /dev/null
-
-    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG_SIZE loglevel=4 ${extra_cmdline_linux}" > /dev/null
-    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG_SIZE loglevel=4" > /dev/null
-
-    # Set boot configs
-    fw_setenv ${FW_ARG} kernel_addr $kernel_addr > /dev/null
-    fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
-    fw_setenv ${FW_ARG} fdt_high $fdt_high > /dev/null
-    fw_setenv ${FW_ARG} initrd_addr $initrd_addr > /dev/null
-    fw_setenv ${FW_ARG} mtdids 'nand0=armada-nand' > /dev/null
-    if [ $UBOOT_FW_DEFAULT -eq 1 ]
-    then
-        fw_setenv ${FW_ARG} mtdparts 'mtdparts=armada-nand:10m(U-Boot)ro,20m@10m(ONIE),-(SONIC)' > /dev/null
-    else
-        fw_setenv ${FW_ARG} mtdparts 'mtdparts=armada-nand:4m(uboot)ro,5m@5m(uboot-env),20m@10m(ONIE),-(SONIC)' > /dev/null
-    fi
-    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
-        fw_setenv ${FW_ARG} mtdparts 'mtdparts=spi0.0:4m(boot),-(spi-rootfs)' > /dev/null
-    fi
-    fw_setenv ${FW_ARG} ubi_sonic_boot_mount_ubi 'ubi part SONIC; ubifsmount ubi0' > /dev/null
-    fw_setenv ${FW_ARG} ubi_sonic_boot_bootargs "$BOOTARGS" > /dev/null
-    fw_setenv ${FW_ARG} ubi_sonic_boot_load "$UBI_LOAD" > /dev/null
-    fw_setenv ${FW_ARG} sonic_image_1 "$UBIBOOTCMD" > /dev/null
-    fw_setenv ${FW_ARG} ubi_sonic_boot_bootargs_old "$BOOTARGS_OLD" > /dev/null
-    fw_setenv ${FW_ARG} ubi_sonic_boot_load_old "$UBI_LOAD_OLD" > /dev/null
-    fw_setenv ${FW_ARG} sonic_image_2 "$UBIBOOTCMD_OLD" > /dev/null
-    fw_setenv ${FW_ARG} boot_next  'run sonic_image_1'> /dev/null
-    fw_setenv ${FW_ARG} bootcmd 'run print_menu; usb start; test -n "$boot_once" && run boot_once; run boot_next' > /dev/null
-
-}
-
-create_ubi_partition() {
-    ubidetach /dev/ubi_ctrl -d 0 2>/dev/null || true 
-
-    trap_push "${onie_bin} ubidetach -d 0 /dev/ubi_ctrl || true"
-    echo -en "Format mtd partition '$mtd_dev' "
-    ubiformat $mtd_dev -y -q || {
-        echo "Failed"
-    }
-
-    #attaches MTD devices (which describe raw flash) to UBI and creates corresponding UBI devices; ('-m 2' --> mtd2)
-    echo -en "ubiattach mtd '$mtd_num' "
-    ubiattach /dev/ubi_ctrl -m $mtd_num || {
-        echo "Failed"
-    }
-
-    #creates UBI volumes on UBI devices
-    ubimkvol  /dev/$demo_dev -N $demo_dev -s 3900MiB
-}
-
-create_gpt_partition() {
-    blk_dev="/dev/sda"
-    demo_part=$(sgdisk -p $blk_dev | grep -e "$demo_volume_label" | awk '{print $1}')
-    # ONIE partition size 168MB
-    onie_part_size=168
-
-    if [ -z "$demo_part" ] ; then
-        # Partition Does NOT Exists
-        echo "SONIC label [$demo_volume_label] is NOT found in Partition"
-        echo "Proceeding to create partition"
-
-        attr_bitmask="0x0"
-
-        sgdisk --new=${demo_part}::+${onie_part_size}MB \
-            --attributes=${demo_part}:=:$attr_bitmask \
-            --change-name=${demo_part}:$demo_volume_label $blk_dev \
-        || {
-            echo "Warning: The first trial of creating partition failed, trying the largest aligned available block of sectors on the disk"
-            begin=$(sgdisk -F $blk_dev)
-            end=$(sgdisk -E $blk_dev)
-            sgdisk --new=${demo_part}:$begin:$end \
-                --attributes=${demo_part}:=:$attr_bitmask \
-                --change-name=${demo_part}:$demo_volume_label $blk_dev
-        } || {
-            echo "Error: Unable to create partition $demo_part on $blk_dev"
-            exit 1
-        }
-        partprobe || true
-    else
-        # Partition Exists
-        echo "Partition exists $demo_part on $blk_dev"
-    fi
-
-    # Make filesystem
-    mkfs.ext4 -L $demo_volume_label /dev/$demo_dev
-}
-
-create_partition() {
-    # Platform speicific partition 
-    if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
-        echo "Doing UBI partition"
-        create_ubi_partition
-    else
-        echo "Doing GPT partition"
-        create_gpt_partition
-    fi
-}
-
-mount_partition() {
-
-    demo_mnt=$(mktemp -d) || {
-        echo "Error: Unable to create file sstem mount point"
-        exit 1
-    }
-
-    echo "Mounting $demo_dev on $demo_mnt "
-    if [ "$PLATFORM" = "armhf-marvell_et6448m_52x-r0" ]; then
-        trap_push "${onie_bin} umount /dev/ubi0_0|| true"
-        mount -t ubifs /dev/ubi0_0 $demo_mnt || {
-            echo "mount -t ubifs /dev/ubi0_0 $demo_mnt Failed"
-            exit 1
-        }
-    else
-        trap_push "${onie_bin} umount /dev/sda2|| true"
-        mount -t ext4 /dev/sda2 $demo_mnt || {
-            echo "mount -t ext4 /dev/sda2 $demo_mnt Failed"
-            exit 1
-        }
-    fi
-}
-
-bootloader_menu_config() {
-    # Update uboot Environment
-    prepare_boot_menu
-}
diff --git a/platform/marvell-armhf/prestera.dep b/platform/marvell-armhf/prestera.dep
deleted file mode 100644
index 4fd2883b119..00000000000
--- a/platform/marvell-armhf/prestera.dep
+++ /dev/null
@@ -1,8 +0,0 @@
-MPATH       := $($(MRVL_PRESTERA_DEB)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/prestera.mk platform/marvell-armhf/prestera.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES   += $(shell git ls-files $(MPATH))
-
-$(MRVL_PRESTERA_DEB)_CACHE_MODE  := GIT_CONTENT_SHA 
-$(MRVL_PRESTERA_DEB)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(MRVL_PRESTERA_DEB)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/prestera.mk b/platform/marvell-armhf/prestera.mk
deleted file mode 100644
index 50f44804fdb..00000000000
--- a/platform/marvell-armhf/prestera.mk
+++ /dev/null
@@ -1,11 +0,0 @@
-# Marvell Prestera
-
-export MRVL_PRESTERA_VER = 1.0
-export MRVL_PRESTERA = mrvlprestera_$(MRVL_PRESTERA_VER)_$(PLATFORM_ARCH)
-export MRVL_PRESTERA_DEB = $(MRVL_PRESTERA).deb
-export MRVL_PRESTERA_SRC_URL = https://github.com/Marvell-switching/mrvl-prestera.git
-export MRVL_PRESTERA_SRC_TAG = MRVL_PRESTERA_DRIVER_1.8
-
-$(MRVL_PRESTERA_DEB)_SRC_PATH = $(PLATFORM_PATH)/prestera
-$(MRVL_PRESTERA_DEB)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
-SONIC_DPKG_DEBS += $(MRVL_PRESTERA_DEB)
diff --git a/platform/marvell-armhf/prestera/debian/changelog b/platform/marvell-armhf/prestera/debian/changelog
deleted file mode 100644
index ab8de1dfa38..00000000000
--- a/platform/marvell-armhf/prestera/debian/changelog
+++ /dev/null
@@ -1,5 +0,0 @@
-mrvlprestera (1.0) unstable; urgency=low
-
-  * Prestera switch driver
-
- -- Marvell <arheneus@marvell.com>  Fri, 19 Feb 2021 10:39:18 +0800
diff --git a/platform/marvell-armhf/prestera/debian/compat b/platform/marvell-armhf/prestera/debian/compat
deleted file mode 100644
index ec635144f60..00000000000
--- a/platform/marvell-armhf/prestera/debian/compat
+++ /dev/null
@@ -1 +0,0 @@
-9
diff --git a/platform/marvell-armhf/prestera/debian/control b/platform/marvell-armhf/prestera/debian/control
deleted file mode 100755
index 51cb0579a26..00000000000
--- a/platform/marvell-armhf/prestera/debian/control
+++ /dev/null
@@ -1,15 +0,0 @@
-Source: mrvlprestera
-Section: unknown
-Priority: optional
-Maintainer: Marvell <arheneus@marvell.com>
-Build-Depends: debhelper (>=9)
-Standards-Version: 3.9.6
-Homepage: <insert the upstream URL, if relevant>
-#Vcs-Git: git://anonscm.debian.org/collab-maint/mrvlprestera.git
-#Vcs-Browser: https://anonscm.debian.org/cgit/collab-maint/mrvlprestera.git
-
-Package: mrvlprestera
-Architecture: armhf
-Homepage: <insert the upstream URL, if relevant>
-Description: 
-	kernel modules for prestera switch driver 
diff --git a/platform/marvell-armhf/prestera/debian/mrvlprestera.install.template b/platform/marvell-armhf/prestera/debian/mrvlprestera.install.template
deleted file mode 100644
index 70a9655ddea..00000000000
--- a/platform/marvell-armhf/prestera/debian/mrvlprestera.install.template
+++ /dev/null
@@ -1,2 +0,0 @@
-mrvl-prestera/drivers/armhf/cpssEnabler/linuxNoKernelModule/drivers/mvcpss.ko /lib/modules/KVERSION/kernel/extra
-mrvl-prestera/platform/armhf/*	/
diff --git a/platform/marvell-armhf/prestera/debian/rules b/platform/marvell-armhf/prestera/debian/rules
deleted file mode 100755
index aab9a1bcd9b..00000000000
--- a/platform/marvell-armhf/prestera/debian/rules
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/usr/bin/make -f
-
-include /usr/share/dpkg/pkg-info.mk
-
-PACKAGE_PRE_NAME := mrvlprestera
-ifneq ($(CROSS_BUILD_ENVIRON), y)
-KVERSION   ?= $(shell uname -r)
-endif
-KERNEL_SRC :=  /lib/modules/$(KVERSION)
-MOD_SRC_DIR:= $(shell pwd)
-MODULE_DIR := mrvl-prestera/drivers/armhf/cpssEnabler/linuxNoKernelModule/drivers
-
-%:
-	dh $@ --with systemd,python3 --buildsystem=pybuild
-
-clean:
-	dh_testdir
-	dh_testroot
-	dh_clean
-
-build:
-	# get sources
-	rm -rf mrvl-prestera || true
-	git clone ${MRVL_PRESTERA_SRC_URL}
-	cd mrvl-prestera && git checkout ${MRVL_PRESTERA_SRC_TAG} && cd ..
-	sed "s/KVERSION/${KVERSION}/g" /sonic/platform/marvell-armhf/prestera/debian/mrvlprestera.install.template > /sonic/platform/marvell-armhf/prestera/debian/mrvlprestera.install
-
-	make modules -C $(KERNEL_SRC)/build M=$(MOD_SRC_DIR)/$(MODULE_DIR)/ CONFIG_KM_MVPCI=y CONFIG_KM_MVDMA=y CONFIG_KM_MVINT=y
-
-binary: binary-arch binary-indep
-	# Nothing to do
-
-binary-arch: 
-	# Nothing to do
-
-binary-indep:
-	dh_testdir
-	dh_installdirs
-
-	# Resuming debhelper scripts
-	dh_testroot
-	dh_install
-	dh_installchangelogs
-	dh_installdocs
-	dh_systemd_enable
-	dh_installinit
-	dh_systemd_start
-	dh_link
-	dh_fixperms
-	dh_compress
-	dh_strip
-	dh_installdeb
-	dh_gencontrol
-	dh_md5sums
-	dh_builddeb
-.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-armhf/rules.dep b/platform/marvell-armhf/rules.dep
deleted file mode 100644
index 427219b355d..00000000000
--- a/platform/marvell-armhf/rules.dep
+++ /dev/null
@@ -1,9 +0,0 @@
-include $(PLATFORM_PATH)/sai.dep
-include $(PLATFORM_PATH)/prestera.dep
-include $(PLATFORM_PATH)/docker-syncd-mrvl.dep
-include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.dep
-include $(PLATFORM_PATH)/docker-saiserver-mrvl.dep
-include $(PLATFORM_PATH)/libsaithrift-dev.dep
-include $(PLATFORM_PATH)/platform-et6448m.dep
-include $(PLATFORM_PATH)/platform-nokia.dep
-include $(PLATFORM_PATH)/one-image.dep
diff --git a/platform/marvell-armhf/rules.mk b/platform/marvell-armhf/rules.mk
deleted file mode 100644
index fd320e8caa4..00000000000
--- a/platform/marvell-armhf/rules.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-#include $(PLATFORM_PATH)/sdk.mk
-include $(PLATFORM_PATH)/sai.mk
-include $(PLATFORM_PATH)/docker-syncd-mrvl.mk
-include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk
-include $(PLATFORM_PATH)/docker-saiserver-mrvl.mk
-include $(PLATFORM_PATH)/libsaithrift-dev.mk
-include $(PLATFORM_PATH)/one-image.mk
-include $(PLATFORM_PATH)/platform-et6448m.mk
-include $(PLATFORM_PATH)/platform-nokia.mk
-include $(PLATFORM_PATH)/prestera.mk
-
-ENABLE_SYNCD_RPC = ""
-INCLUDE_MGMT_FRAMEWORK = ""
-
-SONIC_ALL += $(SONIC_ONE_IMAGE) \
-             $(DOCKER_FPM)
-             #$(DOCKER_SYNCD_MRVL_RPC)
-
-# Inject mrvl sai into syncd
-$(SYNCD)_DEPENDS += $(MRVL_SAI)
-$(SYNCD)_UNINSTALLS += $(MRVL_SAI)
-
-ifeq ($(ENABLE_SYNCD_RPC),y)
-$(SYNCD)_DEPENDS += $(LIBSAITHRIFT_DEV)
-endif
-
-# Runtime dependency on mrvl sai is set only for syncd
-$(SYNCD)_RDEPENDS += $(MRVL_SAI)
diff --git a/platform/marvell-armhf/sai.dep b/platform/marvell-armhf/sai.dep
deleted file mode 100644
index d14927cdde2..00000000000
--- a/platform/marvell-armhf/sai.dep
+++ /dev/null
@@ -1,9 +0,0 @@
-SPATH       := $($(MRVL_SAI)_SRC_PATH)
-DEP_FILES   := $(SONIC_COMMON_FILES_LIST) platform/marvell-armhf/sai.mk platform/marvell-armhf/sai.dep
-DEP_FILES   += $(SONIC_COMMON_BASE_FILES_LIST)
-DEP_FILES	+= $(shell git ls-files $(SPATH))
-SMDEP_PATHS := $(SPATH)
-
-$(MRVL_SAI)_CACHE_MODE  := GIT_CONTENT_SHA
-$(MRVL_SAI)_DEP_FLAGS   := $(SONIC_COMMON_FLAGS_LIST)
-$(MRVL_SAI)_DEP_FILES   := $(DEP_FILES)
diff --git a/platform/marvell-armhf/sai.mk b/platform/marvell-armhf/sai.mk
deleted file mode 100644
index f7d8782ac0e..00000000000
--- a/platform/marvell-armhf/sai.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-# Marvell SAI
-
-export MRVL_SAI_VERSION = 1.13.0-1
-export MRVL_SAI = mrvllibsai_$(MRVL_SAI_VERSION)_$(PLATFORM_ARCH).deb
-
-$(MRVL_SAI)_SRC_PATH = $(PLATFORM_PATH)/sai
-$(eval $(call add_conflict_package,$(MRVL_SAI),$(LIBSAIVS_DEV)))
-
-SONIC_MAKE_DEBS += $(MRVL_SAI)
diff --git a/platform/marvell-armhf/sai/Makefile b/platform/marvell-armhf/sai/Makefile
deleted file mode 100644
index cf78504388c..00000000000
--- a/platform/marvell-armhf/sai/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-.ONESHELL:
-SHELL = /bin/bash
-.SHELLFLAGS += -e
-
-MRVL_SAI_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/armhf/sai-plugin/$(MRVL_SAI)
-
-$(addprefix $(DEST)/, $(MRVL_SAI)): $(DEST)/% :
-	# get deb package
-	wget -O $(DEST)/$(MRVL_SAI) $(MRVL_SAI_URL)
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/.gitignore b/platform/marvell-armhf/sonic-platform-et6448m/.gitignore
deleted file mode 100644
index 7f287d53822..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/.gitignore
+++ /dev/null
@@ -1,50 +0,0 @@
-# Object files
-*.o
-*.ko
-*.obj
-*.elf
-
-# Precompiled Headers
-*.gch
-*.pch
-
-# Libraries
-*.lib
-*.a
-*.la
-*.lo
-
-# Shared objects (inc. Windows DLLs)
-*.dll
-*.so
-*.so.*
-*.dylib
-
-# Executables
-*.exe
-*.out
-*.app
-*.i*86
-*.x86_64
-*.hex
-
-# Debug files
-*.dSYM/
-*.su
-
-# Kernel Module Compile Results
-*.mod*
-*.cmd
-*.o.d
-.tmp_versions/
-modules.order
-Module.symvers
-Mkfile.old
-dkms.conf
-
-# Debian packaging
-*.debhelper.log
-*.postinst.debhelper
-*.postrm.debhelper
-*.prerm.debhelper
-*.substvars
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/changelog b/platform/marvell-armhf/sonic-platform-et6448m/debian/changelog
deleted file mode 100755
index 98934823b4f..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/changelog
+++ /dev/null
@@ -1,5 +0,0 @@
-sonic-platform-et6448m (0.1) unstable; urgency=low
-
-  * Add support for ET6448M.
-
- -- Marvell <arheneus@marvell.com>  Mon, 11 Nov 2019 09:35:58 +0800
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/compat b/platform/marvell-armhf/sonic-platform-et6448m/debian/compat
deleted file mode 100644
index ec635144f60..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/compat
+++ /dev/null
@@ -1 +0,0 @@
-9
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/control b/platform/marvell-armhf/sonic-platform-et6448m/debian/control
deleted file mode 100755
index 52c9593a1ea..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/control
+++ /dev/null
@@ -1,15 +0,0 @@
-Source: sonic-platform-et6448m
-Section: unknown
-Priority: optional
-Maintainer: Marvell <arheneus@marvell.com>
-Build-Depends: debhelper (>=9)
-Standards-Version: 3.9.6
-Homepage: <insert the upstream URL, if relevant>
-#Vcs-Git: git://anonscm.debian.org/collab-maint/sonic-platform-et6448m.git
-#Vcs-Browser: https://anonscm.debian.org/cgit/collab-maint/sonic-platform-et6448m.git
-
-Package: sonic-platform-et6448m
-Architecture: armhf
-Depends: ${misc:Depends}
-Description: <insert up to 60 chars description>
- <insert long description, indented with spaces>
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/install b/platform/marvell-armhf/sonic-platform-et6448m/debian/install
deleted file mode 100644
index ceb6090c405..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/install
+++ /dev/null
@@ -1,3 +0,0 @@
-et6448m_plt_setup.sh usr/sbin
-entropy.py etc/
-inband_mgmt.sh etc/
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/postinst b/platform/marvell-armhf/sonic-platform-et6448m/debian/postinst
deleted file mode 100644
index a3a727c7222..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/postinst
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/bin/sh
-# postinst script for sonic-platform-et6448m
-#
-# see: dh_installdeb(1)
-
-set -e
-
-# summary of how this script can be called:
-#        * <postinst> `configure' <most-recently-configured-version>
-#        * <old-postinst> `abort-upgrade' <new version>
-#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
-#          <new-version>
-#        * <postinst> `abort-remove'
-#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
-#          <failed-install-package> <version> `removing'
-#          <conflicting-package> <version>
-# for details, see https://www.debian.org/doc/debian-policy/ or
-# the debian-policy package
-
-
-case "$1" in
-    configure)
-        sh /usr/sbin/et6448m_plt_setup.sh
-    ;;
-
-    abort-upgrade|abort-remove|abort-deconfigure)
-    ;;
-
-    *)
-        echo "postinst called with unknown argument \`$1'" >&2
-        exit 1
-    ;;
-esac
-
-# dh_installdeb will replace this with shell code automatically
-# generated by other debhelper scripts.
-
-#DEBHELPER#
-
-exit 0
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/debian/rules b/platform/marvell-armhf/sonic-platform-et6448m/debian/rules
deleted file mode 100755
index 2f54c4710f1..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/debian/rules
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/usr/bin/make -f
-# See debhelper(7) (uncomment to enable)
-# output every command that modifies files on the build system.
-#export DH_VERBOSE = 1
-
-
-# see FEATURE AREAS in dpkg-buildflags(1)
-#export DEB_BUILD_MAINT_OPTIONS = hardening=+all
-
-# see ENVIRONMENT in dpkg-buildflags(1)
-# package maintainers to append CFLAGS
-#export DEB_CFLAGS_MAINT_APPEND  = -Wall -pedantic
-# package maintainers to append LDFLAGS
-#export DEB_LDFLAGS_MAINT_APPEND = -Wl,--as-needed
-
-
-%:
-	dh $@ 
-
-
-# dh_make generated override targets
-# This is example for Cmake (See https://bugs.debian.org/641051 )
-#override_dh_auto_configure:
-#	dh_auto_configure -- #	-DCMAKE_LIBRARY_PATH=$(DEB_HOST_MULTIARCH)
-
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/entropy.py b/platform/marvell-armhf/sonic-platform-et6448m/entropy.py
deleted file mode 100644
index a2131cdc17f..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/entropy.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-import fcntl, struct
-import time
-from os import path
-
-RNDADDENTROPY=0x40085203
-
-def avail():
-    if path.exists("/proc/sys/kernel/random/entropy_avail"):
-        with open("/proc/sys/kernel/random/entropy_avail", mode='r') as avail:
-            return int(avail.read())
-    else:
-        return int(2048)
-
-if path.exists("/proc/sys/kernel/random/entropy_avail"):
-    while 1:
-        while avail() < 2048:
-            with open('/dev/urandom', 'rb') as urnd, open("/dev/random", mode='wb') as rnd:
-                d = urnd.read(512)
-                t = struct.pack('ii', 4 * len(d), len(d)) + d
-                fcntl.ioctl(rnd, RNDADDENTROPY, t)
-        time.sleep(30)
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/et6448m_plt_setup.sh b/platform/marvell-armhf/sonic-platform-et6448m/et6448m_plt_setup.sh
deleted file mode 100755
index a587b3b17ca..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/et6448m_plt_setup.sh
+++ /dev/null
@@ -1,60 +0,0 @@
-#!/bin/bash
-
-fw_uboot_env_cfg()
-{
-    echo "Setting up U-Boot environment..."
-    FW_ENV_DEFAULT='/dev/mtd0 0x00500000 0x80000 0x100000 8'
-    UBOOT_FW_DFAULT=1
-
-    DTB_HAS_ENV_BLK=$(grep uboot-env /proc/mtd | sed -e 's/:.*$//')
-    if [ -c "/dev/$DTB_HAS_ENV_BLK" ]; then
-        PROC_ENV_FILE=$(find /proc/device-tree/ -name env_size)
-        if [ -n "$PROC_ENV_FILE" ]
-        then
-            UBOOT_ENV_SIZ="0x$(hd $PROC_ENV_FILE | awk 'FNR==1 {print $2 $3 $4 $5}')"
-            UBOOT_ENV_ERASE_SIZ="0x$(grep uboot-env /proc/mtd | awk '{print $3}')"
-            if [[ -n "$UBOOT_ENV_SIZ" && -n "$UBOOT_ENV_ERASE_SIZ" ]]
-            then
-                # Env info from DTB 
-                FW_ENV_DTB="/dev/$DTB_HAS_ENV_BLK 0x00000000 $UBOOT_ENV_SIZ $UBOOT_ENV_ERASE_SIZ"
-            fi
-        fi
-    fi
-    if [ -n "$FW_ENV_DTB" ]
-    then
-                echo $FW_ENV_DTB > /etc/fw_env.config
-                echo "Found uboot env offset in device tree"
-                UBOOT_ENV_CRC=$(fw_printenv -c /etc/fw_env.config 2>&1 | grep -c 'Warning: Bad CRC')
-                if [ $UBOOT_ENV_CRC -eq 0 ]
-                then
-                    echo "Uboot env offset in device tree is valid"
-                    UBOOT_FW_DFAULT=0
-                else
-                    echo "Uboot env offset in device tree is NOT valid"
-                    UBOOT_FW_DFAULT=1
-                fi
-    fi
-    if [ $UBOOT_FW_DFAULT -eq 1 ]
-    then
-        echo $FW_ENV_DEFAULT > /etc/fw_env.config
-        echo "Using pre-configured uboot env"
-    fi
-}
-
-et6448m_profile()
-{
-    MAC_ADDR=$(fw_printenv -n ethaddr)
-    sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g" /usr/share/sonic/device/armhf-marvell_et6448m_52x-r0/et6448m/profile.ini
-    echo "ET6448M: Updating switch mac address ${MAC_ADDR}"
-}
-
-main()
-{
-    fw_uboot_env_cfg
-    et6448m_profile
-
-    python /etc/entropy.py &
-    /bin/sh /etc/inband_mgmt.sh
-}
-
-main $@
diff --git a/platform/marvell-armhf/sonic-platform-et6448m/inband_mgmt.sh b/platform/marvell-armhf/sonic-platform-et6448m/inband_mgmt.sh
deleted file mode 100644
index 3d3d77abeb3..00000000000
--- a/platform/marvell-armhf/sonic-platform-et6448m/inband_mgmt.sh
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/bin/sh
-
-#inband_mgmt
-
-inband_mgmt(){
-
-# The intent of this sequence is to ensure 12c bus enumeration order by
-# controlling the order in which the various i2c device drivers are
-# loaded. Hence the drivers are unloaded and then reloaded in the prescribed
-# order.
-# NOTE: In the nokia platform the following sequence is performed by the Nokia
-# platform service init script and thus should not be performed here
- if [ ! -f /host/machine.conf ]; then
-     exit 0
- fi
- grep ^onie_platform /host/machine.conf 2>/dev/null | grep nokia >/dev/null
- if [ $? != 0 ]; then
-     rmmod i2c-dev
-     rmmod i2c_mux_gpio
-     rmmod i2c_mv64xxx
-     modprobe i2c_mv64xxx
-     modprobe i2c-dev
-     modprobe i2c_mux_gpio
-     sleep 60
- fi
- while :; do
-   ip -br link show eth0 2> /dev/null
-   if [ $? -eq 0 ]; then
-       ip address show eth0 | grep -qw "inet" 2>/dev/null
-       if [ $? -ne 0 ]; then
-           ifconfig eth0 down
-           systemctl restart networking
-       fi
-       sleep 120
-   else
-     sleep 3
-   fi
- done
-}
-(inband_mgmt > /dev/null)&
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/cpu_wdt.py b/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/cpu_wdt.py
deleted file mode 100755
index 60f75b4f2e5..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/cpu_wdt.py
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-from sonic_py_common import logger
-import time
-import os
-import signal
-import sys
-
-
-TIMEOUT=170
-KEEPALIVE=55
-sonic_logger = logger.Logger('Watchdog')
-sonic_logger.set_min_log_priority_info()
-time.sleep(60)
-chassis = Chassis()
-watchdog = chassis.get_watchdog()
-
-def stopWdtService(signal, frame):
-    watchdog._disablewatchdog()
-    sonic_logger.log_notice("CPUWDT Disabled: watchdog armed=%s" % watchdog.is_armed() )
-    sys.exit()
-
-def main():
-
-    signal.signal(signal.SIGHUP, signal.SIG_IGN)
-    signal.signal(signal.SIGINT, stopWdtService)
-    signal.signal(signal.SIGTERM, stopWdtService)
-    
-    watchdog.arm(TIMEOUT)
-    sonic_logger.log_notice("CPUWDT Enabled: watchdog armed=%s" % watchdog.is_armed() )
-
-
-    while True:
-        time.sleep(KEEPALIVE)
-        watchdog._keepalive()
-        sonic_logger.log_info("CPUWDT keepalive")
-    done
-
-    stopWdtService
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/nokia-7215init.sh b/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
deleted file mode 100755
index 5ec108d1cfc..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/scripts/nokia-7215init.sh
+++ /dev/null
@@ -1,68 +0,0 @@
-#!/bin/bash
-
-# Platform init script for Nokia IXS 7215
-
-# Load required kernel-mode drivers
-load_kernel_drivers() {
-    # Remove modules loaded during Linux init
-    # FIX-ME: This will be removed in the future when Linux init no longer loads these
-    rmmod i2c_mux_gpio
-    rmmod i2c_dev
-    rmmod i2c_mv64xxx
-
-    # Carefully control the load order here to ensure consistent i2c bus numbering
-    modprobe i2c_mv64xxx
-    modprobe i2c_dev
-    modprobe i2c_mux_gpio
-    modprobe eeprom
-}
-
-
-nokia_7215_profile()
-{
-    MAC_ADDR=$(sudo decode-syseeprom -m)
-    sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g" /usr/share/sonic/device/armhf-nokia_ixs7215_52x-r0/Nokia-7215/profile.ini
-    echo "Nokia-7215: Updating switch mac address ${MAC_ADDR}"
-}
-
-# - Main entry
-
-# Install kernel drivers required for i2c bus access
-load_kernel_drivers
-
-# Disable sysrq-trigger
-echo 0 > /proc/sys/kernel/sysrq
-
-# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
-# the mux may be enumerated at number 4 or 5 so we check for the mux and skip if needed
-
-# Get list of the mux channels
-ismux_bus=$(i2cdetect -l|grep mux|cut -f1)
-
-# Enumerate the SFP eeprom device on each mux channel
-for mux in ${ismux_bus}
-do
-    echo optoe2 0x50 > /sys/class/i2c-adapter/${mux}/new_device
-done
-
-# Enumerate system eeprom
-echo 24c02 0x53 > /sys/class/i2c-adapter/i2c-0/new_device
-sleep 2
-chmod 644 /sys/class/i2c-adapter/i2c-0/0-0053/eeprom
-
-# Enumerate fan eeprom devices
-echo eeprom 0x55 > /sys/class/i2c-adapter/i2c-0/new_device
-echo eeprom 0x56 > /sys/class/i2c-adapter/i2c-0/new_device
-
-# Enumerate PSU eeprom devices
-echo eeprom 0x50 > /sys/class/i2c-adapter/i2c-1/new_device
-echo eeprom 0x51 > /sys/class/i2c-adapter/i2c-1/new_device
-
-# Enable optical SFP Tx
-i2cset -y -m 0x0f 0 0x41 0x5 0x00
-
-# Ensure switch is programmed with chassis base MAC addr
-nokia_7215_profile
-
-echo "Nokia-7215 - completed platform init script"
-exit 0
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/service/cpu_wdt.service b/platform/marvell-armhf/sonic-platform-nokia/7215/service/cpu_wdt.service
deleted file mode 100644
index 761deec569c..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/service/cpu_wdt.service
+++ /dev/null
@@ -1,8 +0,0 @@
-[Unit]
-Description=CPU WDT
-After=nokia-7215init.service
-[Service]
-ExecStart=/usr/local/bin/cpu_wdt.py
-
-[Install]
-WantedBy=multi-user.target
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf b/platform/marvell-armhf/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
deleted file mode 100644
index 0456c60d42b..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/service/fstrim.timer/timer-override.conf
+++ /dev/null
@@ -1,5 +0,0 @@
-[Unit]
-Description=Discard unused blocks daily
-
-[Timer]
-OnCalendar=daily
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/service/nokia-7215init.service b/platform/marvell-armhf/sonic-platform-nokia/7215/service/nokia-7215init.service
deleted file mode 100644
index 8b17dbc8edc..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/service/nokia-7215init.service
+++ /dev/null
@@ -1,14 +0,0 @@
-[Unit]
-Description=Nokia-7215 Platform Service
-Before=pmon.service
-After=sysinit.target
-DefaultDependencies=no
-
-[Service]
-ExecStart=/usr/local/bin/nokia-7215init.sh
-KillSignal=SIGKILL
-SuccessExitStatus=SIGKILL
-#StandardOutput=tty
-
-[Install]
-WantedBy=multi-user.target
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/setup.py b/platform/marvell-armhf/sonic-platform-nokia/7215/setup.py
deleted file mode 100755
index 65f4853bec8..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/setup.py
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/usr/bin/env python
-
-import os
-from setuptools import setup
-os.listdir
-
-setup(
-   name='sonic_platform',
-   version='1.0',
-   description='Module to initialize Nokia IXS 7215 platforms',
-
-   packages=['sonic_platform','sonic_platform.test'],
-   package_dir={'sonic_platform': '7215/sonic_platform'},
-)
-
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/__init__.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/__init__.py
deleted file mode 100755
index 39c712316dc..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/__init__.py
+++ /dev/null
@@ -1,4 +0,0 @@
-__all__ = ["platform", "chassis"]
-from sonic_platform import *
-
-
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py
deleted file mode 100755
index 008d5ba08b7..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/chassis.py
+++ /dev/null
@@ -1,415 +0,0 @@
-#############################################################################
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the platform information
-#
-#############################################################################
-
-try:
-    import os
-    import sys
-    import glob
-    from sonic_platform_base.chassis_base import ChassisBase
-    from sonic_platform.sfp import Sfp
-    from sonic_platform.eeprom import Eeprom
-    from sonic_platform.fan import Fan
-    from .fan_drawer import RealDrawer
-    from sonic_platform.psu import Psu
-    from sonic_platform.thermal import Thermal
-    from sonic_platform.component import Component
-    from sonic_py_common import logger
-    from sonic_py_common.general import getstatusoutput_noshell
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-smbus_present = 1
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-MAX_SELECT_DELAY = 3600
-COPPER_PORT_START = 1
-COPPER_PORT_END = 48
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-PORT_END = 52
-
-# Device counts
-MAX_7215_FAN_DRAWERS = 2
-MAX_7215_FANS_PER_DRAWER = 1
-MAX_7215_PSU = 2
-MAX_7215_THERMAL = 6
-
-# Temp - disable these to help with early debug
-MAX_7215_COMPONENT = 2
-
-SYSLOG_IDENTIFIER = "chassis"
-sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
-
-
-class Chassis(ChassisBase):
-    """
-    Nokia platform-specific Chassis class
-        Derived from Dell S6000 platform.
-        customized for the 7215 platform.
-    """
-
-    def __init__(self):
-        ChassisBase.__init__(self)
-        self.system_led_supported_color = ['off', 'amber', 'green', 'amber_blink', 'green_blink']
-        # Port numbers for SFP List Initialization
-        self.COPPER_PORT_START = COPPER_PORT_START
-        self.COPPER_PORT_END = COPPER_PORT_END
-        self.SFP_PORT_START = SFP_PORT_START
-        self.SFP_PORT_END = SFP_PORT_END
-        self.PORT_END = PORT_END
-
-        # for non-sfp ports create dummy objects for copper / non-sfp ports
-        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
-            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
-            self._sfp_list.append(sfp_node)
-
-        # Verify optoe2 driver SFP eeprom devices were enumerated and exist
-        # then create the sfp nodes
-        eeprom_path = "/sys/class/i2c-adapter/i2c-{0}/{0}-0050/eeprom"
-        mux_dev = sorted(glob.glob("/sys/class/i2c-adapter/i2c-0/i2c-[0-9]"))
-        y = 0
-        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
-            mux_dev_num = mux_dev[y]
-            port_i2c_map = mux_dev_num[-1]
-            y = y + 1
-            port_eeprom_path = eeprom_path.format(port_i2c_map)
-            if not os.path.exists(port_eeprom_path):
-                sonic_logger.log_info("path %s didnt exist" % port_eeprom_path)
-            sfp_node = Sfp(index, 'SFP', port_eeprom_path, port_i2c_map)
-            self._sfp_list.append(sfp_node)
-        self.sfp_event_initialized = False
-
-        # Instantiate system eeprom object
-        self._eeprom = Eeprom()
-
-        # Construct lists fans, power supplies, thermals & components
-        drawer_num = MAX_7215_FAN_DRAWERS
-        fan_num_per_drawer = MAX_7215_FANS_PER_DRAWER
-        drawer_ctor = RealDrawer
-        fan_index = 0
-        for drawer_index in range(drawer_num):
-            drawer = drawer_ctor(drawer_index)
-            self._fan_drawer_list.append(drawer)
-            for index in range(fan_num_per_drawer):
-                fan = Fan(fan_index, drawer)
-                fan_index += 1
-                drawer._fan_list.append(fan)
-                self._fan_list.append(fan)
-
-        for i in range(MAX_7215_PSU):
-            psu = Psu(i)
-            self._psu_list.append(psu)
-
-        for i in range(MAX_7215_THERMAL):
-            thermal = Thermal(i)
-            self._thermal_list.append(thermal)
-
-        for i in range(MAX_7215_COMPONENT):
-            component = Component(i)
-            self._component_list.append(component)
-
-    def get_sfp(self, index):
-        """
-        Retrieves sfp represented by (1-based) index <index>
-        Args:
-            index: An integer, the index (1-based) of the sfp to retrieve.
-            The index should be the sequence of physical SFP ports in a
-            chassis starting from 1.
-
-        Returns:
-            An object dervied from SfpBase representing the specified sfp
-        """
-        sfp = None
-
-        try:
-            # The index will start from 1
-            sfp = self._sfp_list[index-1]
-        except IndexError:
-            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
-                             index, len(self._sfp_list)))
-        return sfp
-
-    def get_name(self):
-        """
-        Retrieves the name of the chassis
-        Returns:
-            string: The name of the chassis
-        """
-        return self._eeprom.modelstr()
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the chassis
-        Returns:
-            bool: True if chassis is present, False if not
-        """
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the model number (or part number) of the chassis
-        Returns:
-            string: Model/part number of chassis
-        """
-        return self._eeprom.part_number_str()
-
-    def get_service_tag(self):
-        """
-        Retrieves the Service Tag of the chassis
-        Returns:
-            string: Service Tag of chassis
-        """
-        return self._eeprom.service_tag_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the chassis
-        Returns:
-            bool: A boolean value, True if chassis is operating properly
-            False if not
-        """
-        return True
-
-    def get_base_mac(self):
-        """
-        Retrieves the base MAC address for the chassis
-
-        Returns:
-            A string containing the MAC address in the format
-            'XX:XX:XX:XX:XX:XX'
-        """
-        return self._eeprom.base_mac_addr()
-
-    def get_serial(self):
-        """
-        Retrieves the hardware serial number for the chassis
-
-        Returns:
-            A string containing the hardware serial number for this
-            chassis.
-        """
-        return self._eeprom.serial_number_str()
-
-    def get_revision(self):
-        """
-        Retrieves the hardware revision of the chassis
-
-        Returns:
-            string: Revision value of chassis
-        """
-        if smbus_present == 0:  # called from host
-            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x0'])
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x0
-            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-        return str(value)
-
-    def get_system_eeprom_info(self):
-        """
-        Retrieves the full content of system EEPROM information for the
-        chassis
-
-        Returns:
-            A dictionary where keys are the type code defined in
-            OCP ONIE TlvInfo EEPROM format and values are their
-            corresponding values.
-        """
-        return self._eeprom.system_eeprom_info()
-
-    def get_reboot_cause(self):
-        """
-        Retrieves the cause of the previous reboot
-        Returns:
-            A tuple (string, string) where the first element is a string
-            containing the cause of the previous reboot. This string must be
-            one of the predefined strings in this class. If the first string
-            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
-            to pass a description of the reboot cause.
-        """
-        # The ixs7215 CPLD does not have a hardware reboot cause register so
-        # the hardware portion of reboot cause can't be implemented
-
-        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
-
-    def get_change_event(self, timeout=0):
-        """
-        Returns a nested dictionary containing all devices which have
-        experienced a change at chassis level
-
-        Args:
-            timeout: Timeout in milliseconds (optional). If timeout == 0,
-                this method will block until a change is detected.
-
-        Returns:
-            (bool, dict):
-                - True if call successful, False if not;
-                - A nested dictionary where key is a device type,
-                  value is a dictionary with key:value pairs in the format of
-                  {'device_id':'device_event'},
-                  where device_id is the device ID for this device and
-                        device_event,
-                             status='1' represents device inserted,
-                             status='0' represents device removed.
-                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
-                      indicates that fan 0 has been removed, fan 2
-                      has been inserted and sfp 11 has been removed.
-        """
-        # Initialize SFP event first
-        if not self.sfp_event_initialized:
-            from sonic_platform.sfp_event import sfp_event
-            self.sfp_event = sfp_event()
-            self.sfp_event.initialize()
-            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
-            self.sfp_event_initialized = True
-
-        wait_for_ever = (timeout == 0)
-        port_dict = {}
-        if wait_for_ever:
-            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
-            timeout = MAX_SELECT_DELAY
-            while True:
-                status = self.sfp_event.check_sfp_status(port_dict, timeout)
-                if not port_dict == {}:
-                    break
-        else:
-            # At boot up and in "INIT" state call from xrcvd will have timeout
-            # value return true without change after timeout and will
-            # transition to "SYSTEM_READY"
-            status = self.sfp_event.check_sfp_status(port_dict, timeout)
-
-        if status:
-            return True, {'sfp': port_dict}
-        else:
-            return True, {'sfp': {}}
-
-    def get_thermal_manager(self):
-        from .thermal_manager import ThermalManager
-        return ThermalManager
-
-    def initizalize_system_led(self):
-        return True
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the system LED
-
-        Args:
-            color: A string representing the color with which to set the
-                   system LED
-
-        Returns:
-            bool: True if system LED state is set successfully, False if not
-        """
-        if color not in self.system_led_supported_color:
-            return False
-
-        if (color == 'off'):
-            value = 0x00
-        elif (color == 'amber'):
-            value = 0x01
-        elif (color == 'green'):
-            value = 0x02
-        elif (color == 'amber_blink'):
-            value = 0x03
-        elif (color == 'green_blink'):
-            value = 0x04
-        else:
-            return False
-
-        # Write sys led
-        if smbus_present == 0:  # called from host (e.g. 'show system-health')
-            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cset', '-y', '0', '0x41', '0x7', str(value)])
-            if cmdstatus:
-                sonic_logger.log_warning("  System LED set %s failed" % value)
-                return False
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICEREG = 0x7
-            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, value)
-
-        return True
-
-    def get_status_led(self):
-        """
-        Gets the state of the system LED
-
-        Returns:
-            A string, one of the valid LED color strings which could be vendor
-            specified.
-        """
-        # Read sys led
-        if smbus_present == 0:  # called from host
-            cmdstatus, value = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x7'])
-            value = int(value, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x7
-            value = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if value == 0x00:
-            color = 'off'
-        elif value == 0x01:
-            color = 'amber'
-        elif value == 0x02:
-            color = 'green'
-        elif value == 0x03:
-            color = 'amber_blink'
-        elif value == 0x04:
-            color = 'green_blink'
-        else:
-            return None
-
-        return color
-
-    def get_watchdog(self):
-        """
-        Retrieves hardware watchdog device on this chassis
-
-        Returns:
-            An object derived from WatchdogBase representing the hardware
-            watchdog device
-
-        Note:
-            We overload this method to ensure that watchdog is only initialized
-            when it is referenced. Currently, only one daemon can open the
-            watchdog. To initialize watchdog in the constructor causes multiple
-            daemon try opening watchdog when loading and constructing a chassis
-            object and fail. By doing so we can eliminate that risk.
-        """
-        try:
-            if self._watchdog is None:
-                from sonic_platform.watchdog import WatchdogImplBase
-                watchdog_device_path = "/dev/watchdog0"
-                self._watchdog = WatchdogImplBase(watchdog_device_path)
-        except Exception as e:
-            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
-
-        return self._watchdog
-
-    def get_position_in_parent(self):
-        """
-		Retrieves 1-based relative physical position in parent device. If the agent cannot determine the parent-relative position
-        for some reason, or if the associated value of entPhysicalContainedIn is '0', then the value '-1' is returned
-		Returns:
-		    integer: The 1-based relative physical position in parent device or -1 if cannot determine the position
-		"""
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py
deleted file mode 100644
index 4e8863e64fd..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/component.py
+++ /dev/null
@@ -1,175 +0,0 @@
-########################################################################
-# NOKIA IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
-# the platform
-#
-########################################################################
-
-try:
-    import os
-    import subprocess
-    import ntpath
-    from sonic_platform_base.component_base import ComponentBase
-    from sonic_py_common.general import getstatusoutput_noshell, getstatusoutput_noshell_pipe
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-smbus_present = 1
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-
-class Component(ComponentBase):
-    """Nokia platform-specific Component class"""
-
-    CHASSIS_COMPONENTS = [
-        ["System-CPLD", "Used for managing SFPs, LEDs, PSUs and FANs "],
-        ["U-Boot", "Performs initialization during booting"],
-    ]
-    CPLD_UPDATE_COMMAND1 = ['cp', '/usr/sbin/vme', '/tmp']
-    CPLD_UPDATE_COMMAND2 = ['cp', '', '/tmp']
-    CPLD_UPDATE_COMMAND3 = ['cd', '/tmp']
-    CPLD_UPDATE_COMMAND4 = ['./vme', '']
-
-    def __init__(self, component_index):
-        self.index = component_index
-        self.name = self.CHASSIS_COMPONENTS[self.index][0]
-        self.description = self.CHASSIS_COMPONENTS[self.index][1]
-
-    def _get_cpld_version(self, cpld_number):
-
-        if smbus_present == 0:
-            cmdstatus, cpld_version = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x2'])
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x2
-            cpld_version = str(bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG))
-
-        return str(int(cpld_version, 16))
-
-    def get_name(self):
-        """
-        Retrieves the name of the component
-
-        Returns:
-            A string containing the name of the component
-        """
-        return self.name
-
-    def get_model(self):
-        """
-        Retrieves the part number of the component
-        Returns:
-            string: Part number of component
-        """
-        return 'NA'
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the component
-        Returns:
-            string: Serial number of component
-        """
-        return 'NA'
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the component
-        Returns:
-            bool: True if  present, False if not
-        """
-        return True
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the component
-        Returns:
-            bool: True if component is operating properly, False if not
-        """
-        return True
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device.
-        Returns:
-            integer: The 1-based relative physical position in parent
-            device or -1 if cannot determine the position
-        """
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether component is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
-
-    def get_description(self):
-        """
-        Retrieves the description of the component
-
-        Returns:
-            A string containing the description of the component
-        """
-        return self.description
-
-    def get_firmware_version(self):
-        """
-        Retrieves the firmware version of the component
-
-        Returns:
-            A string containing the firmware version of the component
-        """
-        if self.index == 0:
-            return self._get_cpld_version(self.index)
-
-        if self.index == 1:
-            cmd1 = ['grep', '--null-data', 'U-Boot', '/dev/mtd0ro']
-            cmd2 = ['head', '-1']
-            cmd3 = ['cut', '-d', ' ', '-f2-4']
-            cmdstatus, uboot_version = getstatusoutput_noshell_pipe(cmd1, cmd2, cmd3)
-            return uboot_version
-
-    def install_firmware(self, image_path):
-        """
-        Installs firmware to the component
-
-        Args:
-            image_path: A string, path to firmware image
-
-        Returns:
-            A boolean, True if install was successful, False if not
-        """
-        image_name = ntpath.basename(image_path)
-        print(" ixs7215 - install cpld {}".format(image_name))
-
-        # check whether the image file exists
-        if not os.path.isfile(image_path):
-            print("ERROR: the cpld image {} doesn't exist ".format(image_path))
-            return False
-
-        self.CPLD_UPDATE_COMMAND2[1] = image_path
-        self.CPLD_UPDATE_COMMAND4[1] = image_name
-
-        success_flag = False
- 
-        try:   
-            subprocess.check_call(self.CPLD_UPDATE_COMMAND1, stderr=subprocess.STDOUT)
-            subprocess.check_call(self.CPLD_UPDATE_COMMAND2, stderr=subprocess.STDOUT)
-            subprocess.check_call(self.CPLD_UPDATE_COMMAND3, stderr=subprocess.STDOUT)
-            subprocess.check_call(self.CPLD_UPDATE_COMMAND4, stderr=subprocess.STDOUT)
-            success_flag = True
-        except subprocess.CalledProcessError as e:
-            print("ERROR: Failed to upgrade CPLD: rc={}".format(e.returncode))
-
-        if success_flag:
-            print("INFO: Refresh or power cycle is required to finish CPLD installation")
-
-        return success_flag
-
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/eeprom.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/eeprom.py
deleted file mode 100644
index b3b31605b24..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/eeprom.py
+++ /dev/null
@@ -1,284 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains platform specific implementation of SONiC Platform
-# Base API and provides the EEPROMs' information.
-#
-# The different EEPROMs available are as follows:
-# - System EEPROM : Contains Serial number, Service tag, Base MA
-#                   address, etc. in ONIE TlvInfo EEPROM format.
-# - PSU EEPROM : Contains Model name and Part number.
-# - Fan EEPROM : Contains Part number, Serial number, Manufacture Date,
-#                and Service Tag.
-########################################################################
-
-
-try:
-    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
-    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-# PSU eeprom fields in format required by EepromDecoder
-psu_eeprom_format = [
-    ('Model', 's', 15), ('burn', 'x', 1),
-    ('Part Number', 's', 14), ('burn', 'x', 40),
-    ('Serial Number', 's', 11)
-    ]
-
-sonic_logger = logger.Logger('eeprom')
-
-
-class Eeprom(TlvInfoDecoder):
-    """Nokia platform-specific EEPROM class"""
-
-    I2C_DIR = "/sys/class/i2c-adapter/"
-
-    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
-        self.is_psu_eeprom = is_psu
-        self.is_fan_eeprom = is_fan
-        self.is_sys_eeprom = not (is_psu | is_fan)
-
-        if self.is_sys_eeprom:
-            self.start_offset = 0
-            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0053/eeprom"
-
-            # System EEPROM is in ONIE TlvInfo EEPROM format
-            super(Eeprom, self).__init__(self.eeprom_path,
-                                         self.start_offset, '', True)
-            self._load_system_eeprom()
-        else:
-            if self.is_psu_eeprom:
-                self.index = psu_index
-                self.start_offset = 18
-                self.eeprom_path = self.I2C_DIR \
-                    + "i2c-1/1-005{}/eeprom".format(self.index - 1)
-                self.format = psu_eeprom_format
-
-                # Decode device eeprom as per specified format
-                EepromDecoder.__init__(self, self.eeprom_path, self.format,
-                                       self.start_offset, '', True)
-            else:
-                self.index = fan_index
-                self.start_offset = 0
-                self.eeprom_path = self.I2C_DIR \
-                    + "i2c-0/0-005{}/eeprom".format(self.index + 4)
-
-                # Fan EEPROM is in ONIE TlvInfo EEPROM format
-                super(Eeprom, self).__init__(self.eeprom_path,
-                                             self.start_offset, '', True)
-
-            self._load_device_eeprom()
-
-    def _load_system_eeprom(self):
-        """
-        Reads the system EEPROM and retrieves the values corresponding
-        to the codes defined as per ONIE TlvInfo EEPROM format and fills
-        them in a dictionary.
-        """
-        try:
-            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
-            self.eeprom_data = self.read_eeprom()
-        except Exception as e:
-            sonic_logger.log_warning("Unable to read system eeprom")
-            self.base_mac = 'NA'
-            self.serial_number = 'NA'
-            self.part_number = 'NA'
-            self.model_str = 'NA'
-            self.service_tag = 'NA'
-            self.eeprom_tlv_dict = dict()
-        else:
-            eeprom = self.eeprom_data
-            if not self.is_valid_tlvinfo_header(eeprom):
-                sonic_logger.log_warning("Invalid system eeprom TLV header")
-                self.base_mac = 'NA'
-                self.serial_number = 'NA'
-                self.part_number = 'NA'
-                self.model_str = 'NA'
-                self.service_tag = 'NA'
-                return
-
-            total_length = (eeprom[9] << 8) | eeprom[10]
-            tlv_index = self._TLV_INFO_HDR_LEN
-            tlv_end = self._TLV_INFO_HDR_LEN + total_length
-
-            # Construct dictionary of eeprom TLV entries
-            self.eeprom_tlv_dict = dict()
-            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
-                if not self.is_valid_tlv(eeprom[tlv_index:]):
-                    break
-
-                tlv = eeprom[tlv_index:tlv_index + 2
-                             + eeprom[tlv_index + 1]]
-                code = "0x%02X" % (tlv[0])
-
-                name, value = self.decoder(None, tlv)
-
-                self.eeprom_tlv_dict[code] = value
-                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
-                    break
-
-                tlv_index += eeprom[tlv_index+1] + 2
-
-            self.base_mac = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
-            self.serial_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
-            self.part_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
-            self.model_str = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
-            self.service_tag = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
-
-    def _load_device_eeprom(self):
-        """
-        Reads the Fan/PSU EEPROM and interprets as per the specified format
-        """
-        self.serial_number = 'NA'
-        self.part_number = 'NA'
-        self.model_str = 'NA'
-        self.service_tag = 'NA'
-        self.mfg_date = 'NA'
-
-        # PSU device eeproms use proprietary format
-        if self.is_psu_eeprom:
-            try:
-                # Read Fan/PSU EEPROM as per the specified format.
-                self.eeprom_data = EepromDecoder.read_eeprom(self)
-            except Exception as e:
-                sonic_logger.log_warning("Unable to read device eeprom for PSU#{}".format(self.index))
-                return
-
-            # Bail out if PSU eeprom unavailable
-            if self.eeprom_data[0] == 255:
-                sonic_logger.log_warning("Uninitialized device eeprom for PSU#{}".format(self.index))
-                return
-
-            (valid, data) = self._get_eeprom_field("Model")
-            if valid:
-                self.model_str = data.decode()
-
-            (valid, data) = self._get_eeprom_field("Part Number")
-            if valid:
-                self.part_number = data.decode()
-
-            # Early PSU device eeproms were not programmed with serial #
-            try:
-                (valid, data) = self._get_eeprom_field("Serial Number")
-                if valid:
-                    self.serial_number = data.decode()
-            except Exception as e:
-                sonic_logger.log_warning("Unable to read serial# of PSU#{}".format(self.index))
-                return
-
-        # Fan device eeproms use ONIE TLV format
-        else:
-            try:
-                # Read Fan EEPROM as per ONIE TlvInfo EEPROM format.
-                self.eeprom_data = self.read_eeprom()
-            except Exception as e:
-                sonic_logger.log_warning("Unable to read device eeprom for Fan#{}".format(self.index))
-                return
-
-            eeprom = self.eeprom_data
-            if not self.is_valid_tlvinfo_header(eeprom):
-                sonic_logger.log_warning("Invalid device eeprom TLV header for Fan#{}".format(self.index))
-                return
-
-            total_length = (eeprom[9] << 8) | eeprom[10]
-            tlv_index = self._TLV_INFO_HDR_LEN
-            tlv_end = self._TLV_INFO_HDR_LEN + total_length
-
-            # Construct dictionary of eeprom TLV entries
-            self.eeprom_tlv_dict = dict()
-            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
-                if not self.is_valid_tlv(eeprom[tlv_index:]):
-                    break
-
-                tlv = eeprom[tlv_index:tlv_index + 2
-                             + eeprom[tlv_index + 1]]
-                code = "0x%02X" % (tlv[0])
-
-                name, value = self.decoder(None, tlv)
-
-                self.eeprom_tlv_dict[code] = value
-                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
-                    break
-
-                tlv_index += eeprom[tlv_index+1] + 2
-
-            self.serial_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
-            self.part_number = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
-            self.model_str = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
-            self.service_tag = self.eeprom_tlv_dict.get(
-                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
-
-    def _get_eeprom_field(self, field_name, decode=False):
-        """
-        For a field name specified in the EEPROM format, returns the
-        presence of the field and the value for the same.
-        """
-        field_start = 0
-        for field in self.format:
-            field_end = field_start + field[2]
-            if field[0] == field_name:
-                if decode:
-                    return (True, self.eeprom_data[field_start:field_end].decode('ascii'))
-                else:
-                    return (True, self.eeprom_data[field_start:field_end])
-            field_start = field_end
-
-        return (False, None)
-
-    def serial_number_str(self):
-        """
-        Returns the serial number.
-        """
-        return self.serial_number
-
-    def part_number_str(self):
-        """
-        Returns the part number.
-        """
-        return self.part_number
-
-    def airflow_fan_type(self):
-        """
-        Returns the airflow fan type.
-        """
-        if self.is_psu_eeprom:
-            return int(self.psu_type.encode('hex'), 16)
-        else:
-            return int(self.fan_type.encode('hex'), 16)
-
-    def modelstr(self):
-        """
-        Returns the Model name.
-        """
-        return self.model_str
-
-    def base_mac_addr(self):
-        """
-        Returns the base MAC address found in the system EEPROM.
-        """
-        return self.base_mac
-
-    def service_tag_str(self):
-        """
-        Returns the servicetag number.
-        """
-        return self.service_tag
-
-    def system_eeprom_info(self):
-        """
-        Returns a dictionary, where keys are the type code defined in
-        ONIE EEPROM format and values are their corresponding values
-        found in the system EEPROM.
-        """
-        return self.eeprom_tlv_dict
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan.py
deleted file mode 100644
index 71334ca4858..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan.py
+++ /dev/null
@@ -1,384 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Fans' information which are available in the platform
-#
-########################################################################
-
-
-try:
-    import os
-    import time
-    from sonic_platform_base.fan_base import FanBase
-    from sonic_platform.eeprom import Eeprom
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-smbus_present = 1
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-MAX_IXS7215_FAN_SPEED = 19000
-WORKING_IXS7215_FAN_SPEED = 960
-
-sonic_logger = logger.Logger('fan')
-
-
-class Fan(FanBase):
-    """Nokia platform-specific Fan class"""
-
-    def __init__(self, fan_index, fan_drawer, psu_fan=False, dependency=None):
-        self.is_psu_fan = psu_fan
-        ADT7473_DIR = "/sys/bus/i2c/devices/0-002e/hwmon/hwmon1/"
-
-        if not self.is_psu_fan:
-            # Fan is 1-based in Nokia platforms
-            self.index = fan_index + 1
-            self.fan_drawer = fan_drawer
-            self.set_fan_speed_reg = ADT7473_DIR+"pwm{}".format(self.index)
-            self.get_fan_speed_reg = ADT7473_DIR+"fan{}_input".format(self.index)
-            self.max_fan_speed = MAX_IXS7215_FAN_SPEED
-            self.supported_led_color = ['off', 'green', 'red']
-
-            # Fan eeprom
-            self.eeprom = Eeprom(is_fan=True, fan_index=self.index)
-        else:
-            # this is a PSU Fan
-            self.index = fan_index
-            self.dependency = dependency
-
-    def _get_i2c_register(self, reg_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(reg_file)):
-            return rv
-
-        try:
-            with open(reg_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _set_i2c_register(self, reg_file, value):
-        # On successful write, the value read will be written on
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(reg_file)):
-            return rv
-
-        try:
-            with open(reg_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        # Ensure that the write operation has succeeded
-        if (int(self._get_i2c_register(reg_file)) != value ):
-            time.sleep(3)
-            if (int(self._get_i2c_register(reg_file)) != value ):
-                rv = 'ERR'
-
-        return rv
-
-    def get_name(self):
-        """
-        Retrieves the name of the Fan
-
-        Returns:
-            string: The name of the Fan
-        """
-        if not self.is_psu_fan:
-            return "Fan{}".format(self.index)
-        else:
-            return "PSU{} Fan".format(self.index)
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the Fan Unit
-
-        Returns:
-            bool: True if Fan is present, False if not
-        """
-        if smbus_present == 0:
-            sonic_logger.log_info("PMON fan-smbus ERROR - presence ")
-            return False
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0xb
-            fanstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            fanstatus = fanstatus & 1
-            if fanstatus == 1:
-                return False
-        if self.index == 2:
-            fanstatus = fanstatus & 2
-            if fanstatus == 2:
-                return False
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the model number of the Fan
-
-        Returns:
-            string: Model number of Fan. Use part number for this.
-        """
-        return self.eeprom.part_number_str()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Fan
-
-        Returns:
-            string: Serial number of Fan
-        """
-        return self.eeprom.serial_number_str()
-
-    def get_part_number(self):
-        """
-        Retrieves the part number of the Fan
-
-        Returns:
-            string: Part number of Fan
-        """
-        return self.eeprom.part_number_str()
-
-    def get_service_tag(self):
-        """
-        Retrieves the service tag of the Fan
-
-        Returns:
-            string: Service Tag of Fan
-        """
-        return self.eeprom.service_tag_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the Fan
-
-        Returns:
-            bool: True if Fan is operating properly, False if not
-        """
-        status = False
-
-        fan_speed = self._get_i2c_register(self.get_fan_speed_reg)
-        if (fan_speed != 'ERR'):
-            if (int(fan_speed) > WORKING_IXS7215_FAN_SPEED):
-                status = True
-
-        return status
-
-    def get_direction(self):
-        """
-        Retrieves the fan airflow direction
-        Possible fan directions (relative to port-side of device)
-        Returns:
-            A string, either FAN_DIRECTION_INTAKE or
-            FAN_DIRECTION_EXHAUST depending on fan direction
-        """
-
-        return 'intake'
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return True
-
-
-    def get_speed(self):
-        """
-        Retrieves the speed of a Front FAN in the tray in revolutions per
-                 minute defined by 1-based index
-        :param index: An integer, 1-based index of the FAN to query speed
-        :return: integer, denoting front FAN speed
-        """
-        speed = 0
-
-        fan_speed = self._get_i2c_register(self.get_fan_speed_reg)
-        if (fan_speed != 'ERR'):
-            speed_in_rpm = int(fan_speed)
-        else:
-            speed_in_rpm = 0
-
-        speed = 100*speed_in_rpm//MAX_IXS7215_FAN_SPEED
-        if speed > 100:
-            speed = 100
-
-        return speed
-
-    def get_speed_tolerance(self):
-        """
-        Retrieves the speed tolerance of the fan
-
-        Returns:
-            An integer, the percentage of variance from target speed
-            which is considered tolerable
-        """
-        if self.get_presence():
-            # The tolerance value is fixed as 25% for this platform
-            tolerance = 25
-        else:
-            tolerance = 0
-
-        return tolerance
-
-    def set_speed(self, speed):
-        """
-        Set fan speed to expected value
-        Args:
-            speed: An integer, the percentage of full fan speed to set
-            fan to, in the range 0 (off) to 100 (full speed)
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        if self.is_psu_fan:
-            return False
-
-        # Set current fan duty cycle
-        # - 0x00 : fan off
-        # - 0x40 : 25% duty cycle
-        # - 0x80 : 50% duty cycle (default)
-        # - 0xff : 100% duty cycle (full speed)
-        if speed in range(0, 6):
-            fandutycycle = 0x00
-        elif speed in range(6, 41):
-            fandutycycle = 64
-        elif speed in range(41, 76):
-            fandutycycle = 128
-        elif speed in range(76, 101):
-            fandutycycle = 255
-        else:
-            return False
-
-        rv = self._set_i2c_register(self.set_fan_speed_reg, fandutycycle)
-        if (rv != 'ERR'):
-            return True
-        else:
-            return False
-
-    def set_status_led(self, color):
-        """
-        Set led to expected color
-        Args:
-            color: A string representing the color with which to set the
-                   fan module status LED
-        Returns:
-            bool: True if set success, False if fail.
-
-            off , red and green are the only settings 7215 fans
-        """
-
-        if self.is_psu_fan or (color not in self.supported_led_color):
-            return False
-        if (color == self.STATUS_LED_COLOR_AMBER):
-            return False
-        if (color == self.STATUS_LED_COLOR_RED):
-            value = 0x02
-        elif (color == self.STATUS_LED_COLOR_GREEN):
-            value = 0x01
-        elif (color == self.STATUS_LED_COLOR_OFF):
-            value = 0x00
-        else:
-            return False
-
-        if smbus_present == 0:
-            return False
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICEREG = 0x8
-            original = bus.read_byte_data(DEVICE_ADDRESS, DEVICEREG)
-            if (self.index == 1):
-                new = value << 4
-                ledstatus = original & 0xcf
-                ledstatus = ledstatus | new
-            elif self.index == 2:
-                new = value << 6
-                ledstatus = original & 0x3f
-                ledstatus = ledstatus | new
-            else:
-                return False
-
-            bus.write_byte_data(DEVICE_ADDRESS, DEVICEREG, ledstatus)
-
-        return True
-
-    def get_status_led(self):
-        """
-        Gets the state of the fan status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-
-        if self.is_psu_fan:
-            return None
-
-        if smbus_present == 0:
-            return None
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x8
-            ledstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            ledstatus = (ledstatus & 0x30)
-            ledstatus = ledstatus >> 4
-        elif self.index == 2:
-            ledstatus = (ledstatus & 0xC0)
-            ledstatus = ledstatus >> 6
-        if ledstatus == 0x02:
-            return self.STATUS_LED_COLOR_RED
-        elif ledstatus == 0x1:
-            return self.STATUS_LED_COLOR_GREEN
-        else:
-            return self.STATUS_LED_COLOR_OFF
-
-    def get_target_speed(self):
-        """
-        Retrieves the target (expected) speed of the fan
-
-        Returns:
-            An integer, the percentage of full fan speed, in the range 0
-            (off) to 100 (full speed)
-        """
-        speed = 0
-
-        fan_duty = self._get_i2c_register(self.set_fan_speed_reg)
-        if (fan_duty != 'ERR'):
-            dutyspeed = int(fan_duty)
-            if dutyspeed == 0:
-                speed = 0
-            elif dutyspeed == 64:
-                speed = 25
-            elif dutyspeed == 128:
-                speed = 50
-            elif dutyspeed == 255:
-                speed = 100
-
-        return speed
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
deleted file mode 100644
index 6c6218f0a79..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/fan_drawer.py
+++ /dev/null
@@ -1,102 +0,0 @@
-#############################################################################
-# Nokia
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Fan Drawer status which is available in the platform
-#
-#############################################################################
-
-try:
-    from sonic_platform_base.fan_drawer_base import FanDrawerBase
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('fan_drawer')
-
-class NokiaFanDrawer(FanDrawerBase):
-    def __init__(self, index):
-        super(NokiaFanDrawer, self).__init__()
-        self._index = index + 1
-        self._led = None
-
-    def get_index(self):
-        return self._index
-
-    def get_presence(self):
-        return self._fan_list[0].get_presence()
-
-    def get_model(self):
-        """
-        Retrieves the model number of the Fan Drawer
-        Returns:
-            string: Part number of Fan Drawer
-        """
-        return self._fan_list[0].get_model()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Fan Drawer
-        Returns:
-            string: Serial number of Fan
-        """
-        return self._fan_list[0].get_serial()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the Fan Drawer
-        Returns:
-            bool: True if Fan is operating properly, False if not
-        """
-        return self._fan_list[0].get_status()
-
-    def get_direction(self):
-        return 'intake'
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the fan drawer status LED
-
-        Args:
-            color: A string representing the color with which to set the
-                   fan drawer status LED
-
-        Returns:
-            bool: True if status LED state is set successfully, False if not
-        """
-        return self._fan_list[0].set_status_led(color)
-
-    def get_status_led(self):
-        """
-        Gets the state of the fan drawer LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings
-        """
-        return self._fan_list[0].get_status_led()
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return True
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self._index
-
-
-# For Nokia platforms with fan drawer(s)
-class RealDrawer(NokiaFanDrawer):
-    def __init__(self, index):
-        super(RealDrawer, self).__init__(index)
-        self._name = 'drawer{}'.format(self._index)
-
-    def get_name(self):
-        return self._name
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/platform.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/platform.py
deleted file mode 100755
index 7a3046bc739..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/platform.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#############################################################################
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the platform information
-#
-#############################################################################
-
-try:
-    from sonic_platform_base.platform_base import PlatformBase
-    from sonic_platform.chassis import Chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-class Platform(PlatformBase):
-    """
-    Nokia platform-specific class
-    """
-
-    def __init__(self):
-        PlatformBase.__init__(self)
-        self._chassis = Chassis()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py
deleted file mode 100644
index 243b807edb7..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/psu.py
+++ /dev/null
@@ -1,317 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the PSUs' information which are available in the platform
-#
-########################################################################
-
-try:
-    import os
-    from sonic_platform_base.psu_base import PsuBase
-    from sonic_py_common import logger
-    from sonic_platform.eeprom import Eeprom
-    from sonic_py_common.general import getstatusoutput_noshell
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-smbus_present = 1
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-sonic_logger = logger.Logger('psu')
-
-class Psu(PsuBase):
-    """Nokia platform-specific PSU class for 7215 """
-
-    def __init__(self, psu_index):
-        PsuBase.__init__(self)
-        # PSU is 1-based in Nokia platforms
-        self.index = psu_index + 1
-        self._fan_list = []
-
-        # PSU eeprom
-        self.eeprom = Eeprom(is_psu=True, psu_index=self.index)
-
-    def _write_sysfs_file(self, sysfs_file, value):
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'w') as fd:
-                rv = fd.write(str(value))
-        except Exception as e:
-            rv = 'ERR'
-
-        return rv
-
-    def _read_sysfs_file(self, sysfs_file):
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def get_name(self):
-        """
-        Retrieves the name of the device
-
-        Returns:
-            string: The name of the device
-        """
-        return "PSU{}".format(self.index)
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the Power Supply Unit (PSU)
-
-        Returns:
-            bool: True if PSU is present, False if not
-        """
-
-        if smbus_present == 0:  # if called from psuutil outside of pmon
-            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
-            psustatus = int(psustatus, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0xa
-            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            psustatus = psustatus & 1
-            if psustatus == 1:
-                return False
-        if self.index == 2:
-            psustatus = psustatus & 2
-            if psustatus == 2:
-                return False
-
-        return True
-
-    def get_model(self):
-        """
-        Retrieves the part number of the PSU
-
-        Returns:
-            string: Part number of PSU
-        """
-        return self.eeprom.modelstr()
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the PSU
-
-        Returns:
-            string: Serial number of PSU
-        """
-        return self.eeprom.serial_number_str()
-
-    def get_revision(self):
-        """
-        Retrieves the HW revision of the PSU
-
-        Returns:
-            string: HW revision of PSU
-        """
-        return self.eeprom.part_number_str()
-
-    def get_part_number(self):
-        """
-        Retrieves the part number of the PSU
-
-        Returns:
-            string: Part number of PSU
-        """
-        return self.eeprom.part_number_str()
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the PSU
-
-        Returns:
-            bool: True if PSU is operating properly, False if not
-        """
-
-        if smbus_present == 0:
-            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
-            psustatus = int(psustatus, 16)
-            sonic_logger.log_warning("PMON psu-smbus - presence = 0 ")
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0xa
-            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            psustatus = psustatus & 4
-            if psustatus == 4:
-                return True
-        if self.index == 2:
-            psustatus = psustatus & 8
-            if psustatus == 8:
-                return True
-
-        return False
-
-    def get_voltage(self):
-        """
-        Retrieves current PSU voltage output
-
-        Returns:
-            A float number, the output voltage in volts,
-            e.g. 12.1
-        """
-        if smbus_present == 0:
-            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
-            psustatus = int(psustatus, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0xa
-            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            psustatus = psustatus & 4
-            if psustatus == 4:
-                psu_voltage = 12.0
-                return psu_voltage
-        if self.index == 2:
-            psustatus = psustatus & 8
-            if psustatus == 8:
-                psu_voltage = 12.0
-                return psu_voltage
-
-        psu_voltage = 0.0
-        return psu_voltage
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return True
-
-    def get_powergood_status(self):
-        """
-        Retrieves the powergood status of PSU
-        Returns:
-            A boolean, True if PSU has stablized its output voltages and
-            passed all its internal self-tests, False if not.
-        """
-
-        if smbus_present == 0:
-            cmdstatus, psustatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0xa'])
-            psustatus = int(psustatus, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0xa
-            psustatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        if self.index == 1:
-            psustatus = psustatus & 4
-            if psustatus == 4:
-                return True
-        if self.index == 2:
-            psustatus = psustatus & 8
-            if psustatus == 8:
-                return True
-
-        return False
-
-    def get_status_led(self):
-        """
-        Gets the state of the PSU status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-        if self.get_powergood_status():
-            return self.STATUS_LED_COLOR_GREEN
-        else:
-            return self.STATUS_LED_COLOR_OFF
-
-    def set_status_led(self, color):
-        """
-        Sets the state of the PSU status LED
-        Args:
-            color: A string representing the color with which to set the
-                   PSU status LED
-        Returns:
-            bool: True if status LED state is set successfully, False if
-                  not
-        """
-        # The firmware running in the PSU controls the LED
-        # and the PSU LED state cannot be changed from CPU.
-        return False
-
-    def get_status_master_led(self):
-        """
-        Gets the state of the front panel PSU status LED
-
-        Returns:
-            A string, one of the predefined STATUS_LED_COLOR_* strings.
-        """
-        if (not os.path.isfile("/sys/class/gpio/psuLedGreen/value") or
-            not os.path.isfile("/sys/class/gpio/psuLedAmber/value")):
-            return None
-
-        green = self._read_sysfs_file("/sys/class/gpio/psuLedGreen/value")
-        amber = self._read_sysfs_file("/sys/class/gpio/psuLedAmber/value")
-        if green == "ERR" or amber == "ERR":
-            return None
-        if green == "1":
-            return self.STATUS_LED_COLOR_GREEN
-        elif amber == "1":
-            return self.STATUS_LED_COLOR_AMBER
-        else:
-            return None
-
-    def set_status_master_led(self, color):
-        """
-        Sets the state of the front panel PSU status LED
-
-        Returns:
-            bool: True if status LED state is set successfully, False if
-                  not
-        """
-        if (not os.path.isfile("/sys/class/gpio/psuLedGreen/value") or
-            not os.path.isfile("/sys/class/gpio/psuLedAmber/value")):
-            return False
-
-        if color == self.STATUS_LED_COLOR_GREEN:
-            rvg = self._write_sysfs_file("/sys/class/gpio/psuLedGreen/value", 1)
-            if rvg != "ERR":
-                rva = self._write_sysfs_file("/sys/class/gpio/psuLedAmber/value", 0)
-        elif color == self.STATUS_LED_COLOR_AMBER:
-            rvg = self._write_sysfs_file("/sys/class/gpio/psuLedGreen/value", 0)
-            if rvg != "ERR":
-                rva = self._write_sysfs_file("/sys/class/gpio/psuLedAmber/value", 1)
-        else:
-            return False
-
-        if rvg == "ERR" or rva == "ERR":
-            return False
-
-        return True
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py
deleted file mode 100644
index e05908386d3..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp.py
+++ /dev/null
@@ -1,216 +0,0 @@
-# Name: sfp.py, version: 1.0
-#
-# Description: Module contains the definitions of SFP related APIs
-# for Nokia IXR 7250 platform.
-#
-# Copyright (c) 2023, Nokia
-# All rights reserved.
-#
-
-try:
-    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase
-    from sonic_py_common.logger import Logger
-    from sonic_py_common import device_info
-
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-import subprocess as cmd
-
-smbus_present = 1
-
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-COPPER_TYPE = "COPPER"
-SFP_TYPE = "SFP"
-
-# SFP PORT numbers
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-
-logger = Logger()
-
-class Sfp(SfpOptoeBase):
-    """
-    Nokia IXR-7215 Platform-specific Sfp refactor class
-    """
-    instances = []
-
-    # Paths
-    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
-    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
-    HOST_CHK_CMD = "docker > /dev/null 2>&1"
-
-    PLATFORM = "armhf-nokia_ixs7215_52x-r0"
-    HWSKU = "Nokia-7215"
-
-    port_to_i2c_mapping = 0
-
-    # def __init__(self, index, sfp_type, stub):
-    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
-        SfpOptoeBase.__init__(self)
-
-        self.index = index
-        self.port_num = index
-        self.sfp_type = sfp_type
-        self.eeprom_path = eeprom_path
-        self.port_to_i2c_mapping = port_i2c_map
-        self.name = sfp_type + str(index-1)
-        self.port_name = sfp_type + str(index)
-        self.port_to_eeprom_mapping = {}
-
-        self.port_to_eeprom_mapping[index] = eeprom_path
-
-        self._version_info = device_info.get_sonic_version_info()
-        self.lastPresence = False
-
-        logger.log_debug("Sfp __init__ index {} setting name to {} and eeprom_path to {}".format(index, self.name, self.eeprom_path))
-
-        Sfp.instances.append(self)
-        
-    def get_eeprom_path(self):
-        return self.eeprom_path
-
-    def get_presence(self):
-        """
-        Retrieves the presence
-        Returns:
-            bool: True if is present, False if not
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-
-        if smbus_present == 0:  # if called from sfputil outside of pmon
-            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x41 0x3')
-            sfpstatus = int(sfpstatus, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x3
-            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-        pos = [1, 2, 4, 8]
-        bit_pos = pos[self.index-SFP_PORT_START]
-        sfpstatus = sfpstatus & (bit_pos)
-
-        if sfpstatus == 0:
-            return True
-
-        return False
-
-    def get_name(self):
-        """
-        Retrieves the name of the device
-            Returns:
-            string: The name of the device
-        """
-        return self.name
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device.
-        Returns:
-            integer: The 1-based relative physical position in parent device or
-                     -1 if cannot determine the position
-        """
-        return -1
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-
-        if self.sfp_type == "SFP":
-            return True
-        else:
-            return False
-
-    def _get_error_code(self):
-        """
-        Get error code of the SFP module
-
-        Returns:
-            The error code
-        """
-        return NotImplementedError
-
-    def get_error_description(self):
-        """
-        Get error description
-
-        Args:
-            error_code: The error code returned by _get_error_code
-
-        Returns:
-            The error description
-        """
-        if not self.get_presence():
-            error_description = self.SFP_STATUS_UNPLUGGED
-        else:
-            error_description = self.SFP_STATUS_OK
-
-        return error_description
-        # return NotImplementedError
-
-    def get_reset_status(self):
-        """
-        Retrieves the reset status of SFP
-        Returns:
-            A Boolean, True if reset enabled, False if disabled
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the device
-        """
-        reset = self.get_reset_status()
-
-        if reset is True:
-            status = False
-        else:
-            status = True
-
-        return status
-
-    def reset(self):
-        """
-        Reset SFP.
-        Returns:
-            A boolean, True if successful, False if not
-        """
-        # RJ45 and SFP ports not resettable
-        return False
-
-    def set_lpmode(self, lpmode):
-        """
-        Sets the lpmode (low power mode) of SFP
-        Args:
-            lpmode: A Boolean, True to enable lpmode, False to disable it
-            Note  : lpmode can be overridden by set_power_override
-        Returns:
-            A boolean, True if lpmode is set successfully, False if not
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
-
-    def get_lpmode(self):
-        """
-        Retrieves the lpmode (low power mode) status of this SFP
-        Returns:
-            A Boolean, True if lpmode is enabled, False if disabled
-        """
-        if self.sfp_type == COPPER_TYPE:
-            return False
-        if self.sfp_type == SFP_TYPE:
-            return False
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
deleted file mode 100644
index 34fc2bc6ae5..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/sfp_event.py
+++ /dev/null
@@ -1,112 +0,0 @@
-'''
-listen for the SFP change event and return to chassis.
-'''
-import time
-from sonic_py_common import logger
-from sonic_py_common.general import getstatusoutput_noshell
-
-smbus_present = 1
-
-try:
-    import smbus
-except ImportError as e:
-    smbus_present = 0
-
-# system level event/error
-EVENT_ON_ALL_SFP = '-1'
-SYSTEM_NOT_READY = 'system_not_ready'
-SYSTEM_READY = 'system_become_ready'
-SYSTEM_FAIL = 'system_fail'
-
-# SFP PORT numbers
-SFP_PORT_START = 49
-SFP_PORT_END = 52
-
-SYSLOG_IDENTIFIER = "sfp_event"
-sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
-
-
-class sfp_event:
-    ''' Listen to plugin/plugout cable events '''
-
-    def __init__(self):
-        self.handle = None
-
-    def initialize(self):
-        self.modprs_register = 0
-        # Get Transceiver status
-        time.sleep(5)
-        self.modprs_register = self._get_transceiver_status()
-        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
-
-    def deinitialize(self):
-        if self.handle is None:
-            return
-
-    def _get_transceiver_status(self):
-        if smbus_present == 0:
-            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
-            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])
-            sfpstatus = int(sfpstatus, 16)
-        else:
-            bus = smbus.SMBus(0)
-            DEVICE_ADDRESS = 0x41
-            DEVICE_REG = 0x3
-            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
-
-            sfpstatus = ~sfpstatus
-            sfpstatus = sfpstatus & 0xF
-
-        return sfpstatus
-
-    def check_sfp_status(self, port_change, timeout):
-        """
-        check_sfp_status called from get_change_event, this will return correct
-            status of all 4 SFP ports if there is a change in any of them
-        """
-        start_time = time.time()
-        port = SFP_PORT_START
-        forever = False
-
-        if timeout == 0:
-            forever = True
-        elif timeout > 0:
-            timeout = timeout / float(1000)  # Convert to secs
-        else:
-            return False, {}
-        end_time = start_time + timeout
-
-        if (start_time > end_time):
-            return False, {}  # Time wrap or possibly incorrect timeout
-
-        while (timeout >= 0):
-            # Check for OIR events and return updated port_change
-            reg_value = self._get_transceiver_status()
-            if (reg_value != self.modprs_register):
-                changed_ports = (self.modprs_register ^ reg_value)
-                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
-                    # Mask off the bit corresponding to our port
-                    mask = (1 << port-SFP_PORT_START)
-                    if (changed_ports & mask):
-                        # ModPrsL is active high
-                        if reg_value & mask == 0:
-                            port_change[port] = '0'
-                        else:
-                            port_change[port] = '1'
-                    port += 1
-
-                # Update reg value
-                self.modprs_register = reg_value
-                return True, port_change
-
-            if forever:
-                time.sleep(1)
-            else:
-                timeout = end_time - time.time()
-                if timeout >= 1:
-                    time.sleep(1)  # We poll at 1 second granularity
-                else:
-                    if timeout > 0:
-                        time.sleep(timeout)
-                    return True, {}
-        return False, {}
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/README b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/README
deleted file mode 100644
index 3efc8fabce0..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/README
+++ /dev/null
@@ -1 +0,0 @@
-This directory contains unit tests of the Platform API 2.0
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
deleted file mode 100755
index 93dfcaac3d0..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-chassis.py
+++ /dev/null
@@ -1,72 +0,0 @@
-#!/usr/bin/env python
-
-try:
-    import sonic_platform.platform
-    import sonic_platform.chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-def main():
-    print("-----------------")
-    print("Chassis Unit Test")
-    print("-----------------")
-
-    chassis = sonic_platform.platform.Platform().get_chassis()
-    print("  Chassis name: {}".format(chassis.get_name()))
-
-    print("  Chassis presence: {}".format(chassis.get_presence()))
-
-    print("  Chassis model: {}".format(chassis.get_model()))
-
-    print("  Chassis serial: {}".format(chassis.get_serial()))
-
-    print("  Chassis revision: {}".format(chassis.get_revision()))
-
-    print("  Chassis status: {}".format(chassis.get_status()))
-
-    print("  Chassis base_mac: {}".format(chassis.get_base_mac()))
-
-    print("  Chassis reboot cause: {}\n".format(chassis.get_reboot_cause()))
-
-    print("  Chassis watchdog: {}".format(chassis.get_watchdog()))
-
-    print("  Chassis num_components: {}".format(chassis.get_num_components()))
-
-    print("  Chassis all_components: {}\n".format(chassis.get_all_components()))
-
-    print("  Chassis num_modules: {}".format(chassis.get_num_modules()))
-
-    print("  Chassis all_modules: {}\n".format(chassis.get_all_modules()))
-
-    print("  Chassis num_fans: {}".format(chassis.get_num_fans()))
-
-    print("  Chassis all_fans: {}\n".format(chassis.get_all_fans()))
-
-    print("  Chassis num_psus: {}".format(chassis.get_num_psus()))
-
-    print("  Chassis all_psus: {}\n".format(chassis.get_all_psus()))
-
-    print("  Chassis num_thermals: {}".format(chassis.get_num_thermals()))
-
-    print("  Chassis all_thermals: {}\n".format(chassis.get_all_thermals()))
-
-    print("  Chassis num_sfps: {}".format(chassis.get_num_sfps()))
-
-    print("  Chassis all_sfps: {}\n".format(chassis.get_all_sfps()))
-
-    print("  Chassis eeprom: {}".format(chassis.get_eeprom()))
-
-    print("  Chassis system_eeprom_info: {}\n".format(chassis.get_system_eeprom_info()))
-
-    print("  Chassis get_status_led start : {}\n".format(chassis.get_status_led()))
-    chassis.set_status_led('amber')
-    print("  Chassis get_status_led amber: {}\n".format(chassis.get_status_led()))
-    chassis.set_status_led('green')
-    print("  Chassis get_status_led green: {}\n".format(chassis.get_status_led()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-component.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
deleted file mode 100755
index 1116cc7b585..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-component.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------------")
-    print("Chassis Component Unit Test")
-    print("---------------------------")
-
-    chassis = Chassis()
-
-    for component in chassis.get_all_components():
-        print("    Name: {}".format(component.get_name()))
-        print("        Description: {}".format(component.get_description()))
-        print("        FW version: {}\n".format(component.get_firmware_version()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
deleted file mode 100755
index 40836611692..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-eeprom.py
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("------------------------")
-    print("Chassis eeprom Unit Test")
-    print("------------------------")
-
-    chassis = Chassis()
-
-    eeprom = chassis.get_eeprom()
-
-    print("    Model: {}, Service Tag: {}".format(eeprom.modelstr(),
-                                             eeprom.service_tag_str()))
-    print("    Part#: {}, Serial#: {}".format(eeprom.part_number_str(),
-                                              eeprom.serial_number_str()))
-    print("    Base MAC: {}".format(eeprom.base_mac_addr()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
deleted file mode 100755
index 9bbf4d864ac..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-fan.py
+++ /dev/null
@@ -1,32 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis Fan Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    for fan in chassis.get_all_fans():
-        if not fan.get_presence():
-            print("    Name: {} not present".format(fan.get_name()))
-        else:
-            print("    Name:", fan.get_name())
-            print("        Presence: {}, Status: {}, LED: {}".format(fan.get_presence(),
-                                                                     fan.get_status(),
-                                                                     fan.get_status_led()))
-            print("        Model: {}, Serial#: {}".format(fan.get_model(),
-                                                          fan.get_serial()))
-            print("        Part#: {}, Service Tag: {}".format(fan.get_part_number(),
-                                                              fan.get_service_tag()))
-            print("        Direction: {}, Speed: {}RPM, Target Speed: {}%\n".format(fan.get_direction(),
-                                                                                    str(fan.get_speed()),
-                                                                                    str(fan.get_target_speed())))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
deleted file mode 100755
index e3979b8c417..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-psu.py
+++ /dev/null
@@ -1,40 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis PSU Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    for psu in chassis.get_all_psus():
-        if not psu.get_presence():
-            print("    Name: {} not present".format(psu.get_name()))
-        else:
-            print("    Name:", psu.get_name())
-            print("        Presence: {}, Status: {}, LED: {}".format(psu.get_presence(),
-                                                                     psu.get_status(),
-                                                                     psu.get_status_led()))
-            print("        Model: {}, Serial#: {}, Part#: {}".format(psu.get_model(),
-                                                                     psu.get_serial(),
-                                                                     psu.get_part_number()))
-            try:
-                current = psu.get_current()
-            except NotImplementedError:
-                current = "NA"
-            try:
-                power = psu.get_power()
-            except NotImplementedError:
-                power = "NA"
-
-            print("        Voltage: {}, Current: {}, Power: {}\n".format(psu.get_voltage(),
-                                                                         current,
-                                                                         power))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
deleted file mode 100755
index 4d283fa2eb0..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-sfp.py
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/usr/bin/env python
-
-try:
-    from sonic_platform.chassis import Chassis
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-
-def main():
-    print("---------------------")
-    print("Chassis SFP Unit Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    PORT_START = 1
-    PORT_END = 52
-
-    for physical_port in range(PORT_START, PORT_END+1):
-        print(" ")
-        print(" SFP transceiver tests  PORT = ", physical_port)
-        name = chassis.get_sfp(physical_port).get_name()
-        print(" SFP transceiver tests  NAME = ", name)
-
-        presence = chassis.get_sfp(physical_port).get_presence()
-        print("TEST 1 - sfp presence       [ True ] ", physical_port, presence)
-
-        status = chassis.get_sfp(physical_port).get_reset_status()
-        print("TEST 2 - sfp reset status   [ False ] ", physical_port, status)
-
-        txdisable = chassis.get_sfp(physical_port).get_tx_disable()
-        print("TEST 3 - sfp tx_disable     [ False ] ", physical_port, txdisable)
-
-        rxlos = chassis.get_sfp(physical_port).get_rx_los()
-        print("TEST 4 - sfp status rxlos   [ False ] ", physical_port, rxlos)
-
-        txfault = chassis.get_sfp(physical_port).get_tx_fault()
-        print("TEST 5 - sfp status txfault [ False ] ", physical_port, txfault)
-
-        lpmode = chassis.get_sfp(physical_port).get_lpmode()
-        print("TEST 6 - sfp enable lpmode  [ False ] ", physical_port, lpmode)
-
-        trans_info = chassis.get_sfp(physical_port).get_transceiver_info()
-        print("TEST 7 - sfp transceiver info for port:", physical_port, trans_info)
-
-        trans_status = chassis.get_sfp(physical_port).get_transceiver_bulk_status()
-        print("TEST 8 - sfp bulk status for port:", physical_port, trans_status)
-
-        threshold = chassis.get_sfp(physical_port).get_transceiver_threshold_info()
-        print("TEST 9 - sfp bulk status for port:", physical_port, threshold)
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
deleted file mode 100755
index 95cc8e89f0d..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-thermal.py
+++ /dev/null
@@ -1,50 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-def main():
-    print("-------------------------")
-    print("Chassis Thermal Unit Test")
-    print("-------------------------")
-
-    chassis = Chassis()
-
-    for thermal in chassis.get_all_thermals():
-        if not thermal.get_presence():
-            print("    Name: {} not present".format(thermal.get_name()))
-        else:
-            print("    Name:", thermal.get_name())
-            print("        Presence: {}, Status: {}".format(thermal.get_presence(),
-                                                            thermal.get_status()))
-            print("        Model: {}, Serial#: {}".format(thermal.get_model(),
-                                                          thermal.get_serial()))
-            print("        Temperature(C): {}".format(thermal.get_temperature()))
-
-            try:
-                low_thresh = thermal.get_low_threshold()
-            except NotImplementedError:
-                low_thresh = "NA"
-            try:
-                high_thresh = thermal.get_high_threshold()
-            except NotImplementedError:
-                high_thresh = "NA"
-
-            print("        Low Threshold(C): {}, High Threshold(C): {}".format(low_thresh,
-                                                                               high_thresh))
-
-            try:
-                crit_low_thresh = thermal.get_low_critical_threshold()
-            except NotImplementedError:
-                crit_low_thresh = "NA"
-            try:
-                crit_high_thresh = thermal.get_high_critical_threshold()
-            except NotImplementedError:
-                crit_high_thresh = "NA"
-
-            print("        Crit Low Threshold(C): {}, Crit High Threshold(C): {}\n".format(crit_low_thresh,
-                                                                                           crit_high_thresh))
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
deleted file mode 100755
index 20805e04ed2..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/test/test-watchdog.py
+++ /dev/null
@@ -1,22 +0,0 @@
-#!/usr/bin/python
-
-from sonic_platform.chassis import Chassis
-
-
-def main():
-    print("---------------------")
-    print("Chassis Watchdog Test")
-    print("---------------------")
-
-    chassis = Chassis()
-
-    watchdog = chassis.get_watchdog()
-
-    print("    Armed: {}".format(watchdog.is_armed()))
-    print("    Time Left: {}".format(watchdog.get_remaining_time()))
-
-    return
-
-
-if __name__ == '__main__':
-    main()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal.py
deleted file mode 100644
index 444ca5b137d..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal.py
+++ /dev/null
@@ -1,259 +0,0 @@
-########################################################################
-# Nokia IXS7215
-#
-# Module contains an implementation of SONiC Platform Base API and
-# provides the Thermals' information which are available in the platform
-#
-########################################################################
-
-
-try:
-    import os
-    from sonic_platform_base.thermal_base import ThermalBase
-    from sonic_py_common import logger
-except ImportError as e:
-    raise ImportError(str(e) + "- required module not found")
-
-sonic_logger = logger.Logger('thermal')
-
-class Thermal(ThermalBase):
-    """Nokia platform-specific Thermal class"""
-
-    I2C_CLASS_DIR = "/sys/class/i2c-adapter/"
-    I2C_DEV_MAPPING = (['i2c-0/0-004a/hwmon/', 1],
-                       ['i2c-0/0-004b/hwmon/', 1],
-                       ['i2c-0/0-002e/hwmon/', 1],
-                       ['i2c-0/0-002e/hwmon/', 2],
-                       ['i2c-0/0-002e/hwmon/', 3])
-
-    HWMON_CLASS_DIR = "/sys/class/hwmon/"
-
-    THERMAL_NAME = ("PCB PHY", "PCB MAC",
-                    "ADT7473-CPU", "ADT7473-LOC", "ADT7473-MAC",
-                    "CPU Core")
-
-    def __init__(self, thermal_index):
-        ThermalBase.__init__(self)
-        self.index = thermal_index + 1
-        self.is_psu_thermal = False
-        self.dependency = None
-        self._minimum = None
-        self._maximum = None
-        self.thermal_high_threshold_file = None
-        # PCB temperature sensors
-        if self.index < 3:
-            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
-            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
-            sensor_high_suffix = "max"
-            sensor_high_crit_suffix = None
-            hwmon_node = os.listdir(i2c_path)[0]
-            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
-
-        # ADT7473 temperature sensors
-        elif self.index < 6:
-            i2c_path = self.I2C_CLASS_DIR + self.I2C_DEV_MAPPING[self.index - 1][0]
-            sensor_index = self.I2C_DEV_MAPPING[self.index - 1][1]
-            sensor_high_suffix = "crit"
-            sensor_high_crit_suffix = None
-            hwmon_node = os.listdir(i2c_path)[0]
-            self.SENSOR_DIR = i2c_path + hwmon_node + '/'
-
-        # Armada 38x SOC temperature sensor
-        else:
-            dev_path = self.HWMON_CLASS_DIR
-            sensor_index = 1
-            sensor_high_suffix = None
-            sensor_high_crit_suffix = None
-            hwmon_node = os.listdir(dev_path)[0]
-            self.SENSOR_DIR = dev_path + hwmon_node + '/'
-
-        # sysfs file for current temperature value
-        self.thermal_temperature_file = self.SENSOR_DIR \
-            + "temp{}_input".format(sensor_index)
-
-        # sysfs file for high threshold value if supported for this sensor
-        if sensor_high_suffix:
-            self.thermal_high_threshold_file = self.SENSOR_DIR \
-                + "temp{}_{}".format(sensor_index, sensor_high_suffix)
-        else:
-            self.thermal_high_threshold_file = None
-
-        # sysfs file for crit high threshold value if supported for this sensor
-        if sensor_high_crit_suffix:
-            self.thermal_high_crit_threshold_file = self.SENSOR_DIR \
-                + "temp{}_{}".format(sensor_index, sensor_high_crit_suffix)
-        else:
-            self.thermal_high_crit_threshold_file = None
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # sysfs_file and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def get_name(self):
-        """
-        Retrieves the name of the thermal
-
-        Returns:
-            string: The name of the thermal
-        """
-        return self.THERMAL_NAME[self.index - 1]
-
-    def get_presence(self):
-        """
-        Retrieves the presence of the thermal
-
-        Returns:
-            bool: True if thermal is present, False if not
-        """
-        if self.dependency:
-            return self.dependency.get_presence()
-        else:
-            return True
-
-    def get_model(self):
-        """
-        Retrieves the model number (or part number) of the Thermal
-
-        Returns:
-            string: Model/part number of Thermal
-        """
-        return 'NA'
-
-    def get_serial(self):
-        """
-        Retrieves the serial number of the Thermal
-
-        Returns:
-            string: Serial number of Thermal
-        """
-        return 'NA'
-
-    def get_status(self):
-        """
-        Retrieves the operational status of the thermal
-
-        Returns:
-            A boolean value, True if thermal is operating properly,
-            False if not
-        """
-        if self.dependency:
-            return self.dependency.get_status()
-        else:
-            return True
-
-    def get_temperature(self):
-        """
-        Retrieves current temperature reading from thermal
-
-        Returns:
-            A float number of current temperature in Celsius up to
-            nearest thousandth of one degree Celsius, e.g. 30.125
-        """
-        thermal_temperature = self._read_sysfs_file(
-            self.thermal_temperature_file)
-        if (thermal_temperature != 'ERR'):
-            thermal_temperature = float(thermal_temperature) / 1000
-            if self._minimum is None or self._minimum > thermal_temperature:
-                self._minimum = thermal_temperature
-            if self._maximum is None or self._maximum < thermal_temperature:
-                self._maximum = thermal_temperature
-        else:
-            thermal_temperature = 0
-
-        return float("{:.3f}".format(thermal_temperature))
-
-    def get_high_threshold(self):
-        """
-        Retrieves the high threshold temperature of thermal
-
-        Returns:
-            A float number, the high threshold temperature of thermal in
-            Celsius up to nearest thousandth of one degree Celsius,
-            e.g. 30.125
-        """
-        # Not implemented for this sensor
-        if not self.thermal_high_threshold_file:
-            raise  NotImplementedError
-
-        thermal_high_threshold = self._read_sysfs_file(
-            self.thermal_high_threshold_file)
-        if (thermal_high_threshold != 'ERR'):
-            thermal_high_threshold = float(thermal_high_threshold) / 1000
-        else:
-            thermal_high_threshold = 0.0
-
-        return float("{:.3f}".format(thermal_high_threshold))
-
-    def set_high_threshold(self, temperature):
-        """
-        Sets the high threshold temperature of thermal
-
-        Args :
-            temperature: A float number up to nearest thousandth of one
-            degree Celsius, e.g. 30.125
-        Returns:
-            A boolean, True if threshold is set successfully, False if
-            not
-        """
-        # Thermal threshold values are pre-defined based on HW.
-        return False
-
-    def get_high_critical_threshold(self):
-        """
-        Retrieves the high critical threshold temperature of thermal
-
-        Returns:
-            A float number, the high critical threshold temperature of thermal in Celsius
-            up to nearest thousandth of one degree Celsius, e.g. 30.125
-        """
-
-        # Not implemented for this sensor
-        if not self.thermal_high_crit_threshold_file:
-            raise  NotImplementedError
-
-        thermal_high_crit_threshold = self._read_sysfs_file(
-            self.thermal_high_crit_threshold_file)
-        if (thermal_high_crit_threshold != 'ERR'):
-            thermal_high_crit_threshold = float(thermal_high_crit_threshold) / 1000
-        else:
-            thermal_high_crit_threshold = 0.0
-
-        return float("{:.3f}".format(thermal_high_crit_threshold))
-
-    def get_minimum_recorded(self):
-        self.get_temperature()
-        return self._minimum
-
-    def get_maximum_recorded(self):
-        self.get_temperature()
-        return self._maximum
-
-    def get_position_in_parent(self):
-        """
-        Retrieves 1-based relative physical position in parent device
-        Returns:
-            integer: The 1-based relative physical position in parent device
-        """
-        return self.index
-
-    def is_replaceable(self):
-        """
-        Indicate whether this device is replaceable.
-        Returns:
-            bool: True if it is replaceable.
-        """
-        return False
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
deleted file mode 100644
index a829fd80a5b..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_actions.py
+++ /dev/null
@@ -1,192 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_action_base import ThermalPolicyActionBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-
-from sonic_py_common import logger
-
-sonic_logger = logger.Logger('thermal_actions')
-
-
-class SetFanSpeedAction(ThermalPolicyActionBase):
-    """
-    Base thermal action class to set speed for fans
-    """
-    # JSON field definition
-    JSON_FIELD_SPEED = 'speed'
-    JSON_FIELD_DEFAULT_SPEED = 'default_speed'
-    JSON_FIELD_HIGHTEMP_SPEED = 'hightemp_speed'
-
-    def __init__(self):
-        """
-        Constructor of SetFanSpeedAction
-        """
-        self.default_speed = 50
-        self.hightemp_speed = 100
-        self.speed = self.default_speed
-
-    def load_from_json(self, json_obj):
-        """
-        Construct SetFanSpeedAction via JSON. JSON example:
-            {
-                "type": "fan.all.set_speed"
-                "speed": "100"
-            }
-        :param json_obj: A JSON object representing a SetFanSpeedAction action.
-        :return:
-        """
-        if SetFanSpeedAction.JSON_FIELD_SPEED in json_obj:
-            speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
-            if speed < 0 or speed > 100:
-                raise ValueError('SetFanSpeedAction invalid speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(speed))
-            self.speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_SPEED))
-
-    @classmethod
-    def set_all_fan_speed(cls, thermal_info_dict, speed):
-        from .thermal_infos import FanInfo
-        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
-            fan_info_obj = thermal_info_dict[FanInfo.INFO_NAME]
-            for fan in fan_info_obj.get_presence_fans():
-                fan.set_speed(int(speed))
-
-
-@thermal_json_object('fan.all.set_speed')
-class SetAllFanSpeedAction(SetFanSpeedAction):
-    """
-    Action to set speed for all fans
-    """
-    def execute(self, thermal_info_dict):
-        """
-        Set speed for all fans
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        SetAllFanSpeedAction.set_all_fan_speed(thermal_info_dict, self.speed)
-
-
-@thermal_json_object('thermal.temp_check_and_set_all_fan_speed')
-class ThermalRecoverAction(SetFanSpeedAction):
-    """
-    Action to check thermal sensor temperature change status and set speed for all fans
-    """
-
-    def load_from_json(self, json_obj):
-        """
-        Construct ThermalRecoverAction via JSON. JSON example:
-            {
-                "type": "thermal.temp_check_and_set_all_fan_speed"
-                "default_speed": "50"
-                "hightemp_speed": "100"
-            }
-        :param json_obj: A JSON object representing a ThermalRecoverAction action.
-        :return:
-        """
-        if SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED in json_obj:
-            default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
-            if default_speed < 0 or default_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid default speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(default_speed))
-            self.default_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_DEFAULT_SPEED))
-
-        if SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED in json_obj:
-            hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
-            if hightemp_speed < 0 or hightemp_speed > 100:
-                raise ValueError('SetFanSpeedAction invalid hightemp speed value {} in JSON policy file, valid value should be [0, 100]'.
-                                 format(hightemp_speed))
-            self.hightemp_speed = float(json_obj[SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED])
-        else:
-            raise ValueError('SetFanSpeedAction missing mandatory field {} in JSON policy file'.
-                             format(SetFanSpeedAction.JSON_FIELD_HIGHTEMP_SPEED))
-
-        sonic_logger.log_warning("ThermalRecoverAction: default: {}, hightemp: {}".format(self.default_speed, self.hightemp_speed))
-
-    def execute(self, thermal_info_dict):
-        """
-        Check check thermal sensor temperature change status and set speed for all fans
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        from .thermal_infos import ThermalInfo
-        if ThermalInfo.INFO_NAME in thermal_info_dict and \
-           isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
-
-            thermal_info_obj = thermal_info_dict[ThermalInfo.INFO_NAME]
-            if thermal_info_obj.is_warm_up_and_over_high_threshold():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.hightemp_speed)
-            elif thermal_info_obj.is_cool_down_and_below_low_threshold():
-                ThermalRecoverAction.set_all_fan_speed(thermal_info_dict, self.default_speed)
-
-
-@thermal_json_object('switch.shutdown')
-class SwitchPolicyAction(ThermalPolicyActionBase):
-    """
-    Base class for thermal action. Once all thermal conditions in a thermal policy are matched,
-    all predefined thermal action will be executed.
-    """
-    def execute(self, thermal_info_dict):
-        """
-        Take action when thermal condition matches. For example, adjust speed of fan or shut
-        down the switch.
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        sonic_logger.log_warning("Alarm for temperature critical is detected, reboot Device")
-        # import os
-        # os.system('reboot')
-
-
-@thermal_json_object('thermal_control.control')
-class ControlThermalAlgoAction(ThermalPolicyActionBase):
-    """
-    Action to control the thermal control algorithm
-    """
-    # JSON field definition
-    JSON_FIELD_STATUS = 'status'
-
-    def __init__(self):
-        self.status = True
-
-    def load_from_json(self, json_obj):
-        """
-        Construct ControlThermalAlgoAction via JSON. JSON example:
-            {
-                "type": "thermal_control.control"
-                "status": "true"
-            }
-        :param json_obj: A JSON object representing a ControlThermalAlgoAction action.
-        :return:
-        """
-        if ControlThermalAlgoAction.JSON_FIELD_STATUS in json_obj:
-            status_str = json_obj[ControlThermalAlgoAction.JSON_FIELD_STATUS].lower()
-            if status_str == 'true':
-                self.status = True
-            elif status_str == 'false':
-                self.status = False
-            else:
-                raise ValueError('Invalid {} field value, please specify true of false'.
-                                 format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
-        else:
-            raise ValueError('ControlThermalAlgoAction '
-                             'missing mandatory field {} in JSON policy file'.
-                             format(ControlThermalAlgoAction.JSON_FIELD_STATUS))
-
-    def execute(self, thermal_info_dict):
-        """
-        Disable thermal control algorithm
-        :param thermal_info_dict: A dictionary stores all thermal information.
-        :return:
-        """
-        from .thermal_infos import ChassisInfo
-        if ChassisInfo.INFO_NAME in thermal_info_dict:
-            chassis_info_obj = thermal_info_dict[ChassisInfo.INFO_NAME]
-            chassis = chassis_info_obj.get_chassis()
-            thermal_manager = chassis.get_thermal_manager()
-            if self.status:
-                thermal_manager.start_thermal_control_algorithm()
-            else:
-                thermal_manager.stop_thermal_control_algorithm()
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
deleted file mode 100644
index 4923d63d746..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_conditions.py
+++ /dev/null
@@ -1,81 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_condition_base import ThermalPolicyConditionBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-
-
-class FanCondition(ThermalPolicyConditionBase):
-    def get_fan_info(self, thermal_info_dict):
-        from .thermal_infos import FanInfo
-        if FanInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[FanInfo.INFO_NAME], FanInfo):
-            return thermal_info_dict[FanInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('fan.any.absence')
-class AnyFanAbsenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_absence_fans()) > 0 if fan_info_obj else False
-
-
-@thermal_json_object('fan.all.absence')
-class AllFanAbsenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_presence_fans()) == 0 if fan_info_obj else False
-
-
-@thermal_json_object('fan.all.presence')
-class AllFanPresenceCondition(FanCondition):
-    def is_match(self, thermal_info_dict):
-        fan_info_obj = self.get_fan_info(thermal_info_dict)
-        return len(fan_info_obj.get_absence_fans()) == 0 if fan_info_obj else False
-
-
-class ThermalCondition(ThermalPolicyConditionBase):
-    def get_thermal_info(self, thermal_info_dict):
-        from .thermal_infos import ThermalInfo
-        if ThermalInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[ThermalInfo.INFO_NAME], ThermalInfo):
-            return thermal_info_dict[ThermalInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('thermal.over.high_critical_threshold')
-class ThermalOverHighCriticalCondition(ThermalCondition):
-    def is_match(self, thermal_info_dict):
-        thermal_info_obj = self.get_thermal_info(thermal_info_dict)
-        if thermal_info_obj:
-            return thermal_info_obj.is_over_high_critical_threshold()
-        else:
-            return False
-
-
-class PsuCondition(ThermalPolicyConditionBase):
-    def get_psu_info(self, thermal_info_dict):
-        from .thermal_infos import PsuInfo
-        if PsuInfo.INFO_NAME in thermal_info_dict and isinstance(thermal_info_dict[PsuInfo.INFO_NAME], PsuInfo):
-            return thermal_info_dict[PsuInfo.INFO_NAME]
-        else:
-            return None
-
-
-@thermal_json_object('psu.any.absence')
-class AnyPsuAbsenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_absence_psus()) > 0 if psu_info_obj else False
-
-
-@thermal_json_object('psu.all.absence')
-class AllPsuAbsenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_presence_psus()) == 0 if psu_info_obj else False
-
-
-@thermal_json_object('psu.all.presence')
-class AllPsuPresenceCondition(PsuCondition):
-    def is_match(self, thermal_info_dict):
-        psu_info_obj = self.get_psu_info(thermal_info_dict)
-        return len(psu_info_obj.get_absence_psus()) == 0 if psu_info_obj else False
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
deleted file mode 100644
index cd0a0591cd2..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_infos.py
+++ /dev/null
@@ -1,210 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_info_base import ThermalPolicyInfoBase
-from sonic_platform_base.sonic_thermal_control.thermal_json_object import thermal_json_object
-
-
-@thermal_json_object('fan_info')
-class FanInfo(ThermalPolicyInfoBase):
-    """
-    Fan information needed by thermal policy
-    """
-
-    # Fan information name
-    INFO_NAME = 'fan_info'
-
-    def __init__(self):
-        self._absence_fans = set()
-        self._presence_fans = set()
-        self._status_changed = False
-
-    def collect(self, chassis):
-        """
-        Collect absence and presence fans.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._status_changed = False
-        for fan in chassis.get_all_fans():
-            if fan.get_presence() and fan not in self._presence_fans:
-                self._presence_fans.add(fan)
-                self._status_changed = True
-                if fan in self._absence_fans:
-                    self._absence_fans.remove(fan)
-            elif not fan.get_presence() and fan not in self._absence_fans:
-                self._absence_fans.add(fan)
-                self._status_changed = True
-                if fan in self._presence_fans:
-                    self._presence_fans.remove(fan)
-
-    def get_absence_fans(self):
-        """
-        Retrieves absence fans
-        :return: A set of absence fans
-        """
-        return self._absence_fans
-
-    def get_presence_fans(self):
-        """
-        Retrieves presence fans
-        :return: A set of presence fans
-        """
-        return self._presence_fans
-
-    def is_status_changed(self):
-        """
-        Retrieves if the status of fan information changed
-        :return: True if status changed else False
-        """
-        return self._status_changed
-
-
-@thermal_json_object('thermal_info')
-class ThermalInfo(ThermalPolicyInfoBase):
-    """
-    Thermal information needed by thermal policy
-    """
-
-    # Fan information name
-    INFO_NAME = 'thermal_info'
-
-    def __init__(self):
-        self.init = False
-        self._old_avg_temp = 0
-        self._current_avg_temp = 0
-        self._high_crital_threshold = 75
-        self._high_threshold = 45
-        self._low_threshold = 40
-
-    def collect(self, chassis):
-        """
-        Collect thermal sensor temperature change status
-        :param chassis: The chassis object
-        :return:
-        """
-        self._temps = []
-        self._over_high_critical_threshold = False
-        self._warm_up_and_over_high_threshold = False
-        self._cool_down_and_below_low_threshold = False
-
-        # Calculate average temp within the device
-        temp = 0
-        num_of_thermals = chassis.get_num_thermals()
-        for index in range(num_of_thermals):
-            self._temps.insert(index, chassis.get_thermal(index).get_temperature())
-            temp += self._temps[index]
-
-        self._current_avg_temp = temp / num_of_thermals
-
-        # Special case if first time
-        if self.init is False:
-            self._old_avg_temp = self._current_avg_temp
-            self.init = True
-
-        # Check if new average temp exceeds high threshold value
-        if self._current_avg_temp >= self._old_avg_temp and self._current_avg_temp >= self._high_threshold:
-            self._warm_up_and_over_high_threshold = True
-
-        # Check if new average temp exceeds low threshold value
-        if self._current_avg_temp <= self._old_avg_temp and self._current_avg_temp <= self._low_threshold:
-            self._cool_down_and_below_low_threshold = True
-
-        self._old_avg_temp = self._current_avg_temp
-
-    def is_warm_up_and_over_high_threshold(self):
-        """
-        Retrieves if the temperature is warm up and over high threshold
-        :return: True if the temperature is warm up and over high threshold else False
-        """
-        return self._warm_up_and_over_high_threshold
-
-    def is_cool_down_and_below_low_threshold(self):
-        """
-        Retrieves if the temperature is cold down and below low threshold
-        :return: True if the temperature is cold down and below low threshold else False
-        """
-        return self._cool_down_and_below_low_threshold
-
-    def is_over_high_critical_threshold(self):
-        """
-        Retrieves if the temperature is over high critical threshold
-        :return: True if the temperature is over high critical threshold else False
-        """
-        return self._over_high_critical_threshold
-
-
-@thermal_json_object('psu_info')
-class PsuInfo(ThermalPolicyInfoBase):
-    """
-    PSU information needed by thermal policy
-    """
-    INFO_NAME = 'psu_info'
-
-    def __init__(self):
-        self._absence_psus = set()
-        self._presence_psus = set()
-        self._status_changed = False
-
-    def collect(self, chassis):
-        """
-        Collect absence and presence PSUs.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._status_changed = False
-        for psu in chassis.get_all_psus():
-            if psu.get_presence() and psu.get_powergood_status() and psu not in self._presence_psus:
-                self._presence_psus.add(psu)
-                self._status_changed = True
-                if psu in self._absence_psus:
-                    self._absence_psus.remove(psu)
-            elif (not psu.get_presence() or not psu.get_powergood_status()) and psu not in self._absence_psus:
-                self._absence_psus.add(psu)
-                self._status_changed = True
-                if psu in self._presence_psus:
-                    self._presence_psus.remove(psu)
-
-    def get_absence_psus(self):
-        """
-        Retrieves presence PSUs
-        :return: A set of absence PSUs
-        """
-        return self._absence_psus
-
-    def get_presence_psus(self):
-        """
-        Retrieves presence PSUs
-        :return: A set of presence fans
-        """
-        return self._presence_psus
-
-    def is_status_changed(self):
-        """
-        Retrieves if the status of PSU information changed
-        :return: True if status changed else False
-        """
-        return self._status_changed
-
-
-@thermal_json_object('chassis_info')
-class ChassisInfo(ThermalPolicyInfoBase):
-    """
-    Chassis information needed by thermal policy
-    """
-    INFO_NAME = 'chassis_info'
-
-    def __init__(self):
-        self._chassis = None
-
-    def collect(self, chassis):
-        """
-        Collect platform chassis.
-        :param chassis: The chassis object
-        :return:
-        """
-        self._chassis = chassis
-
-    def get_chassis(self):
-        """
-        Retrieves platform chassis object
-        :return: A platform chassis object.
-        """
-        return self._chassis
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
deleted file mode 100644
index 967cf175934..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/thermal_manager.py
+++ /dev/null
@@ -1,49 +0,0 @@
-from sonic_platform_base.sonic_thermal_control.thermal_manager_base import ThermalManagerBase
-from .thermal_actions import *
-from .thermal_conditions import *
-from .thermal_infos import *
-
-
-class ThermalManager(ThermalManagerBase):
-    THERMAL_ALGORITHM_CONTROL_PATH = '/var/run/hw-management/config/suspend'
-
-    @classmethod
-    def start_thermal_control_algorithm(cls):
-        """
-        Start thermal control algorithm
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        cls._control_thermal_control_algorithm(False)
-
-    @classmethod
-    def stop_thermal_control_algorithm(cls):
-        """
-        Stop thermal control algorithm
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        cls._control_thermal_control_algorithm(True)
-
-    @classmethod
-    def _control_thermal_control_algorithm(cls, suspend):
-        """
-        Control thermal control algorithm
-
-        Args:
-            suspend: Bool, indicate suspend the algorithm or not
-
-        Returns:
-            bool: True if set success, False if fail.
-        """
-        status = True
-        write_value = 1 if suspend else 0
-        try:
-            with open(cls.THERMAL_ALGORITHM_CONTROL_PATH, 'w') as control_file:
-                control_file.write(str(write_value))
-        except (ValueError, IOError):
-            status = False
-
-        return status
diff --git a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/watchdog.py b/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/watchdog.py
deleted file mode 100644
index 03a8d9ecb4e..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/7215/sonic_platform/watchdog.py
+++ /dev/null
@@ -1,209 +0,0 @@
-"""
-ARMADA 38x Watchdog - one 32 bit cpu watchdog per cpu - 2 watchdogs ( page 662)
-
-Module contains an implementation of SONiC Platform Base API and
-provides access to hardware watchdog
-"""
-
-import os
-import fcntl
-import array
-import time
-from sonic_platform_base.watchdog_base import WatchdogBase
-
-""" ioctl constants """
-IO_WRITE = 0x40000000
-IO_READ = 0x80000000
-IO_READ_WRITE = 0xC0000000
-IO_SIZE_INT = 0x00040000
-IO_TYPE_WATCHDOG = ord('W') << 8
-
-WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
-WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
-
-""" Watchdog ioctl commands """
-WDIOC_SETOPTIONS = 4 | WDR_INT
-WDIOC_KEEPALIVE = 5 | WDR_INT
-WDIOC_SETTIMEOUT = 6 | WDWR_INT
-WDIOC_GETTIMEOUT = 7 | WDR_INT
-WDIOC_SETPRETIMEOUT = 8 | WDWR_INT
-WDIOC_GETPRETIMEOUT = 9 | WDR_INT
-WDIOC_GETTIMELEFT = 10 | WDR_INT
-
-""" Watchdog status constants """
-WDIOS_DISABLECARD = 0x0001
-WDIOS_ENABLECARD = 0x0002
-
-""" watchdog sysfs """
-WD_SYSFS_PATH = "/sys/class/watchdog/watchdog0/"
-
-WD_COMMON_ERROR = -1
-
-
-class WatchdogImplBase(WatchdogBase):
-    """
-    Base class that implements common logic for interacting
-    with watchdog using ioctl commands
-    """
-
-    def __init__(self, wd_device_path):
-        """
-        Open a watchdog handle
-        @param wd_device_path Path to watchdog device
-        """
-        super(WatchdogImplBase, self).__init__()
-        
-        self.watchdog=""
-        self.watchdog_path = wd_device_path
-        self.wd_state_reg = WD_SYSFS_PATH+"state"
-        self.wd_timeout_reg = WD_SYSFS_PATH+"timeout"
-        self.wd_timeleft_reg = WD_SYSFS_PATH+"timeleft"
-    
-        self.timeout = self._gettimeout()
-
-    def _read_sysfs_file(self, sysfs_file):
-        # On successful read, returns the value read from given
-        # reg_name and on failure returns 'ERR'
-        rv = 'ERR'
-
-        if (not os.path.isfile(sysfs_file)):
-            return rv
-        try:
-            with open(sysfs_file, 'r') as fd:
-                rv = fd.read()
-        except Exception as e:
-            rv = 'ERR'
-
-        rv = rv.rstrip('\r\n')
-        rv = rv.lstrip(" ")
-        return rv
-
-    def _disablewatchdog(self):
-        """
-        Turn off the watchdog timer
-        """
-
-        req = array.array('h', [WDIOS_DISABLECARD])
-        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
-
-    def _enablewatchdog(self):
-        """
-        Turn on the watchdog timer
-        """
-
-        req = array.array('h', [WDIOS_ENABLECARD])
-        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
-
-    def _keepalive(self):
-        """
-        Keep alive watchdog timer
-        """
-
-        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
-
-    def _settimeout(self, seconds):
-        """
-        Set watchdog timer timeout
-        @param seconds - timeout in seconds
-        @return is the actual set timeout
-        """
-
-        req = array.array('I', [seconds])
-        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
-
-        return int(req[0])
-
-    def _gettimeout(self):
-        """
-        Get watchdog timeout
-        @return watchdog timeout
-        """
-        timeout=0
-        timeout=self._read_sysfs_file(self.wd_timeout_reg)
-
-        return timeout
-
-    def _gettimeleft(self):
-        """
-        Get time left before watchdog timer expires
-        @return time left in seconds
-        """
-
-        req = array.array('I', [0])
-        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
-
-        return int(req[0])
-
-    def arm(self, seconds):
-        """
-        Arm the hardware watchdog
-        """
-
-        ret = WD_COMMON_ERROR
-        if seconds < 0:
-            return ret
-        
-        # Stop the watchdog service to gain access of watchdog file pointer
-        if self.is_armed():
-            os.popen("systemctl stop cpu_wdt.service")
-            time.sleep(2)
-        if not self.watchdog:
-            self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
-        try:
-            if self.timeout != seconds:
-                self.timeout = self._settimeout(seconds)
-            if self.is_armed():
-                self._keepalive()
-            else:
-                self._enablewatchdog()
-            ret = self.timeout
-        except IOError:
-            pass
-
-        return ret
-
-    def disarm(self):
-        """
-        Disarm the hardware watchdog
-
-        Returns:
-            A boolean, True if watchdog is disarmed successfully, False
-            if not
-        """
-        
-        if self.is_armed():
-            os.popen("systemctl stop cpu_wdt.service")
-            time.sleep(2)
-            if not self.watchdog:
-                self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
-            try:
-                self._disablewatchdog()
-                self.timeout = 0
-            except IOError:
-                return False
-
-        return True
-
-    def is_armed(self):
-        """
-        Implements is_armed WatchdogBase API
-        """
-        status = False
-
-        state = self._read_sysfs_file(self.wd_state_reg)
-        if (state != 'inactive'):
-            status = True
-
-        return status
-
-    def get_remaining_time(self):
-        """
-        Implements get_remaining_time WatchdogBase API
-        """
-
-        timeleft = WD_COMMON_ERROR
-
-        if self.is_armed():
-            timeleft=self._read_sysfs_file(self.wd_timeleft_reg)
-
-        return int(timeleft)
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/changelog b/platform/marvell-armhf/sonic-platform-nokia/debian/changelog
deleted file mode 100755
index f4c860fab86..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/changelog
+++ /dev/null
@@ -1,5 +0,0 @@
-sonic-platform-nokia-7215 (1.0) unstable; urgency=low
-
-  * Add support for nokia-7215.
-
- -- Nokia <carl.keene@nokia.com>  Wed, 15 Apr 2020 09:35:58 +0800
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/compat b/platform/marvell-armhf/sonic-platform-nokia/debian/compat
deleted file mode 100644
index ec635144f60..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/compat
+++ /dev/null
@@ -1 +0,0 @@
-9
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/control b/platform/marvell-armhf/sonic-platform-nokia/debian/control
deleted file mode 100755
index 0da04ac8984..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/control
+++ /dev/null
@@ -1,15 +0,0 @@
-Source: sonic-platform-nokia-7215
-Section: unknown
-Priority: optional
-Maintainer: Nokia <carl.keene@nokia.com>
-Build-Depends: debhelper (>=9)
-Standards-Version: 3.9.6
-Homepage: <insert the upstream URL, if relevant>
-#Vcs-Git: git://anonscm.debian.org/collab-maint/sonic-platform-et6448m.git
-#Vcs-Browser: https://anonscm.debian.org/cgit/collab-maint/sonic-platform-et6448m.git
-
-Package: sonic-platform-nokia-7215
-Architecture: armhf
-Depends: ${misc:Depends}
-Description: <insert up to 60 chars description>
- <insert long description, indented with spaces>
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/rules b/platform/marvell-armhf/sonic-platform-nokia/debian/rules
deleted file mode 100755
index b7592c2b51e..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/rules
+++ /dev/null
@@ -1,64 +0,0 @@
-#!/usr/bin/make -f
-# See debhelper(7) (uncomment to enable)
-# output every command that modifies files on the build system.
-#export DH_VERBOSE = 1
-
-include /usr/share/dpkg/pkg-info.mk
-#--------------------------------------------------------
-
-PACKAGE_PRE_NAME := sonic-platform-nokia
-MOD_SRC_DIR:= $(shell pwd)
-MODULE_DIRS:= 7215
-UTILS_DIR := utils
-SERVICE_DIR := service
-PLATFORM_DIR := sonic_platform
-
-%:
-	dh $@ --with systemd,python3 --buildsystem=pybuild
-
-clean:
-	dh_testdir
-	dh_testroot
-	dh_clean
-
-build:
-	(for mod in $(MODULE_DIRS); do \
-		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
-	done)
-
-binary: binary-arch binary-indep
-	# Nothing to do
-
-binary-arch:
-	# Nothing to do
-
-binary-indep:
-	dh_testdir
-	dh_installdirs
-
-	# Custom package commands
-	(for mod in $(MODULE_DIRS); do \
-		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
-		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
-		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
-		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
-	done)
-
-	# Resuming debhelper scripts
-	dh_testroot
-	dh_install
-	dh_installchangelogs
-	dh_installdocs
-	dh_systemd_enable
-	dh_installinit
-	dh_systemd_start
-	dh_link
-	dh_fixperms
-	dh_compress
-	dh_strip
-	dh_installdeb
-	dh_gencontrol
-	dh_md5sums
-	dh_builddeb
-
-.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install b/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
deleted file mode 100644
index bca328306ea..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.install
+++ /dev/null
@@ -1,8 +0,0 @@
-nokia-7215_plt_setup.sh usr/sbin
-7215/scripts/nokia-7215init.sh  usr/local/bin
-7215/scripts/cpu_wdt.py  usr/local/bin
-7215/service/nokia-7215init.service  etc/systemd/system
-7215/service/cpu_wdt.service  etc/systemd/system
-7215/service/fstrim.timer/timer-override.conf  /lib/systemd/system/fstrim.timer.d
-7215/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/armhf-nokia_ixs7215_52x-r0
-inband_mgmt.sh etc/
diff --git a/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst b/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
deleted file mode 100644
index 76d40865a0a..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/debian/sonic-platform-nokia-7215.postinst
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-# postinst script for sonic-platform-nokia-7215
-#
-# see: dh_installdeb(1)
-
-sh /usr/sbin/nokia-7215_plt_setup.sh
-systemctl enable nokia-7215init.service
-systemctl start nokia-7215init.service
-
-systemctl enable cpu_wdt.service
-systemctl start cpu_wdt.service
-
-exit 0
-
diff --git a/platform/marvell-armhf/sonic-platform-nokia/inband_mgmt.sh b/platform/marvell-armhf/sonic-platform-nokia/inband_mgmt.sh
deleted file mode 100644
index 25455d16ecb..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/inband_mgmt.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/bin/sh
-
-#inband_mgmt
-
-inband_mgmt(){
- # In this platform, one of the network ports is used as mgmt interface.
- # This script periodically monitors inband management port eth0 and
- # assigns IP address to eth0 if needed.
- if [ ! -f /host/machine.conf ]; then
-     exit 0
- fi
- #wait for n/w port init to complete
- sleep 60
- while :; do
-   ip -br link show eth0 2> /dev/null
-   if [ $? -eq 0 ]; then
-       ip address show eth0 | grep -qw "inet" 2>/dev/null
-       if [ $? -ne 0 ]; then
-           ifconfig eth0 down
-           systemctl restart networking
-       fi
-       sleep 120
-   else
-     sleep 3
-   fi
- done
-}
-(inband_mgmt > /dev/null)&
diff --git a/platform/marvell-armhf/sonic-platform-nokia/nokia-7215_plt_setup.sh b/platform/marvell-armhf/sonic-platform-nokia/nokia-7215_plt_setup.sh
deleted file mode 100755
index 017c7e5153a..00000000000
--- a/platform/marvell-armhf/sonic-platform-nokia/nokia-7215_plt_setup.sh
+++ /dev/null
@@ -1,31 +0,0 @@
-#!/bin/bash
-
-fw_uboot_env_cfg()
-{
-    echo "Setting up U-Boot environment..."
-
-    MACH_FILE="/host/machine.conf"
-    PLATFORM=`sed -n 's/onie_platform=\(.*\)/\1/p' $MACH_FILE`
-
-    if [ "$PLATFORM" = "armhf-nokia_ixs7215_52x-r0" ]; then
-	# Ixs7215 / IPD6448M board Uboot ENV offset
-        FW_ENV_DEFAULT='/dev/mtd0 0x00100000 0x10000 0x10000'
-    else
-        FW_ENV_DEFAULT='/dev/mtd0 0x00500000 0x80000 0x100000 8'
-    fi
-
-    echo "Using pre-configured uboot env"
-    echo $FW_ENV_DEFAULT > /etc/fw_env.config
-
-}
-
-
-main()
-{
-    fw_uboot_env_cfg
-    echo "Nokia-IXS7215: /dev/mtd0 FW_ENV_DEFAULT"
-
-    /bin/sh /etc/inband_mgmt.sh
-}
-
-main $@

From e3166f005e5e4b9193d84922b36d259554608122 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Tue, 20 Feb 2024 09:22:47 +0000
Subject: [PATCH 09/10] Update readme to reflect new build commands

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 README.md | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/README.md b/README.md
index 534540e3edf..1fbcb128c53 100644
--- a/README.md
+++ b/README.md
@@ -204,7 +204,7 @@ make target/sonic-[ASIC_VENDER]-armhf.bin
 _example:_
 
 ```shell
-make configure PLATFORM=marvell-armhf PLATFORM_ARCH=armhf
+make configure PLATFORM=marvell PLATFORM_ARCH=armhf
 make target/sonic-marvell-armhf.bin
 ```
 
@@ -215,7 +215,7 @@ using cross-compilation, run the following commands:
 # Execute make configure once to configure ASIC and ARCH for cross-compilation build
 
 NOJESSIE=1 NOSTRETCH=1 BLDENV=buster CROSS_BLDENV=1 \
-make configure PLATFORM=marvell-armhf PLATFORM_ARCH=armhf
+make configure PLATFORM=marvell PLATFORM_ARCH=armhf
 
 # Execute Arm32 build using cross-compilation environment
 
@@ -234,7 +234,7 @@ make configure PLATFORM=[ASIC_VENDOR] PLATFORM_ARCH=arm64
 
 # example:
 
-make configure PLATFORM=marvell-arm64 PLATFORM_ARCH=arm64
+make configure PLATFORM=marvell PLATFORM_ARCH=arm64
 ```
 
  **NOTE**:

From cb9c7241850cc4d3af9f82189673dd441fb6c997 Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Wed, 21 Feb 2024 04:53:31 +0000
Subject: [PATCH 10/10] Change azure pipeline commands for marvell

make configure is changed as below for 'marvell-arm64' and 'marvell-armhf'.
arm64 - make configure PLATFORM=marvell PLATFORM_ARCH=arm64
armhf - make configure PLATFORM=marvell PLATFORM_ARCH=armhf

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 .azure-pipelines/azure-pipelines-build.yml          | 2 ++
 .azure-pipelines/azure-pipelines-image-template.yml | 3 ++-
 .azure-pipelines/official-build-cache.yml           | 1 +
 azure-pipelines.yml                                 | 2 ++
 4 files changed, 7 insertions(+), 1 deletion(-)

diff --git a/.azure-pipelines/azure-pipelines-build.yml b/.azure-pipelines/azure-pipelines-build.yml
index b5e5c732286..26c7b53b4fd 100644
--- a/.azure-pipelines/azure-pipelines-build.yml
+++ b/.azure-pipelines/azure-pipelines-build.yml
@@ -90,6 +90,7 @@ jobs:
             pool: sonicbld-armhf
           timeoutInMinutes: 2880
           variables:
+            PLATFORM: marvell
             PLATFORM_ARCH: armhf
 
         - name: marvell-arm64
@@ -97,6 +98,7 @@ jobs:
             pool: sonicbld-arm64
           timeoutInMinutes: 2880
           variables:
+            PLATFORM: marvell
             PLATFORM_ARCH: arm64
 
         - name: marvell
diff --git a/.azure-pipelines/azure-pipelines-image-template.yml b/.azure-pipelines/azure-pipelines-image-template.yml
index c412edb4234..fed9db8f33a 100644
--- a/.azure-pipelines/azure-pipelines-image-template.yml
+++ b/.azure-pipelines/azure-pipelines-image-template.yml
@@ -49,7 +49,8 @@ jobs:
           sudo modprobe overlay
           sudo apt-get install -y acl
           sudo bash -c "echo 1 > /proc/sys/vm/compact_memory"
-          ENABLE_DOCKER_BASE_PULL=y make PLATFORM=$(PLATFORM_AZP) PLATFORM_ARCH=$(PLATFORM_ARCH) $(BUILD_OPTIONS) configure
+          [ -z "$PLATFORM" ] && PLATFORM=$(PLATFORM_AZP)
+          ENABLE_DOCKER_BASE_PULL=y make PLATFORM=$PLATFORM PLATFORM_ARCH=$(PLATFORM_ARCH) $(BUILD_OPTIONS) configure
         displayName: 'Make configure'
     postSteps:
       - script: |
diff --git a/.azure-pipelines/official-build-cache.yml b/.azure-pipelines/official-build-cache.yml
index c4261a72092..57b85f1d42b 100644
--- a/.azure-pipelines/official-build-cache.yml
+++ b/.azure-pipelines/official-build-cache.yml
@@ -49,4 +49,5 @@ stages:
           pool: sonicbld-armhf
           timeoutInMinutes: 1200
           variables:
+            PLATFORM: marvell
             PLATFORM_ARCH: armhf
diff --git a/azure-pipelines.yml b/azure-pipelines.yml
index ed863220329..201c984944f 100644
--- a/azure-pipelines.yml
+++ b/azure-pipelines.yml
@@ -79,11 +79,13 @@ stages:
       - name: marvell-arm64
         pool: sonicbld-arm64
         variables:
+           PLATFORM: marvell
            PLATFORM_ARCH: arm64
       - name: marvell-armhf
         pool: sonicbld-armhf
         timeoutInMinutes: 1200
         variables:
+          PLATFORM: marvell
           PLATFORM_ARCH: armhf
           INCLUDE_RESTAPI: y
 
