diff --git a/platform/marvell-arm64/docker-saiserver-mrvl.mk b/platform/marvell-arm64/docker-saiserver-mrvl.mk
index 90bb5ae99..498f35ffa 100644
--- a/platform/marvell-arm64/docker-saiserver-mrvl.mk
+++ b/platform/marvell-arm64/docker-saiserver-mrvl.mk
@@ -3,7 +3,7 @@
 DOCKER_SAISERVER_MRVL = docker-saiserver-mrvl.gz
 $(DOCKER_SAISERVER_MRVL)_PATH = $(PLATFORM_PATH)/docker-saiserver-mrvl
 $(DOCKER_SAISERVER_MRVL)_DEPENDS += $(SAISERVER)
-$(DOCKER_SAISERVER_MRVL)_LOAD_DOCKERS += $(DOCKER_CONFIG_ENGINE_BUSTER)
+$(DOCKER_SAISERVER_MRVL)_LOAD_DOCKERS += $(DOCKER_CONFIG_ENGINE_BULLSEYE)
 SONIC_DOCKER_IMAGES += $(DOCKER_SAISERVER_MRVL)
 
 $(DOCKER_SAISERVER_MRVL)_CONTAINER_NAME = saiserver
diff --git a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2 b/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
index 68670343b..1731e8dca 100644
--- a/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
+++ b/platform/marvell-arm64/docker-syncd-mrvl-rpc/Dockerfile.j2
@@ -15,7 +15,8 @@ RUN apt-get purge -y syncd
 RUN apt-get update \
  && apt-get -y install  \
     net-tools           \
-    python-pip          \
+    python3-pip		\
+    python-setuptools	\
     build-essential     \
     libssl-dev          \
     libffi-dev          \
@@ -24,7 +25,7 @@ RUN apt-get update \
     cmake               \
     libqt5core5a        \
     libqt5network5      \
-    libboost-atomic1.71.0
+    libboost-atomic1.74.0
 
 RUN dpkg_apt() { [ -f $1 ] && { dpkg -i $1 || apt-get -y install -f; } || return 1; } ; \
 {% for deb in docker_syncd_mrvl_rpc_debs.split(' ') -%}
@@ -41,9 +42,9 @@ RUN wget https://github.com/nanomsg/nanomsg/archive/1.0.0.tar.gz \
  && cd ..               \
  && rm -fr nanomsg-1.0.0 \
  && rm -f 1.0.0.tar.gz  \
- && pip install cffi==1.7.0    \
- && pip install --upgrade cffi==1.7.0 \
- && pip install nnpy    \
+ && pip2 install cffi==1.7.0    \
+ && pip2 install --upgrade cffi==1.7.0 \
+ && pip2 install nnpy    \
  && mkdir -p /opt       \
  && cd /opt             \
  && wget https://raw.githubusercontent.com/p4lang/ptf/master/ptf_nn/ptf_nn_agent.py \
diff --git a/platform/marvell-arm64/docker-syncd-mrvl.mk b/platform/marvell-arm64/docker-syncd-mrvl.mk
index 39135311b..236f8a437 100644
--- a/platform/marvell-arm64/docker-syncd-mrvl.mk
+++ b/platform/marvell-arm64/docker-syncd-mrvl.mk
@@ -1,7 +1,7 @@
 # docker image for mrvl syncd
 
 DOCKER_SYNCD_PLATFORM_CODE = mrvl
-include $(PLATFORM_PATH)/../template/docker-syncd-base.mk
+include $(PLATFORM_PATH)/../template/docker-syncd-bullseye.mk
 
 $(DOCKER_SYNCD_BASE)_DEPENDS += $(SYNCD)
 
diff --git a/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2 b/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
index d07c25231..84e3d5bde 100755
--- a/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
+++ b/platform/marvell-arm64/docker-syncd-mrvl/Dockerfile.j2
@@ -1,5 +1,5 @@
 {% from "dockers/dockerfile-macros.j2" import install_debian_packages %}
-FROM docker-config-engine-buster-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
+FROM docker-config-engine-bullseye-{{DOCKER_USERNAME}}:{{DOCKER_USERTAG}}
 
 ARG docker_container_name
 
diff --git a/platform/marvell-arm64/linux-kernel-arm64.mk b/platform/marvell-arm64/linux-kernel-arm64.mk
deleted file mode 100644
index a953c9082..000000000
--- a/platform/marvell-arm64/linux-kernel-arm64.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-# linux kernel package for marvell arm64
-
-# Add platform specific DTB
-LINUX_KERNEL_DTB = linux-image-4.9.168-arm64.deb
-$(LINUX_KERNEL_DTB)_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
-SONIC_ONLINE_DEBS += $(LINUX_KERNEL_DTB)
diff --git a/platform/marvell-arm64/linux/Makefile b/platform/marvell-arm64/linux/Makefile
deleted file mode 100644
index 89415f493..000000000
--- a/platform/marvell-arm64/linux/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-.ONESHELL:
-SHELL = /bin/bash
-.SHELLFLAGS += -e
-
-LINUX_KERNEL_MRVL_URL = https://github.com/Marvell-switching/sonic-marvell-binaries/raw/master/arm64/kernel/$(LINUX_KERNEL_DTB)
-
-$(addprefix $(DEST)/, $(LINUX_KERNEL_DTB)): $(DEST)/% :
-	# get deb package
-	wget -O $(DEST)/$(LINUX_KERNEL_DTB) $(LINUX_KERNEL_MRVL_URL)
-
diff --git a/platform/marvell-arm64/one-image.mk b/platform/marvell-arm64/one-image.mk
index 3d916be4e..491ce0a59 100644
--- a/platform/marvell-arm64/one-image.mk
+++ b/platform/marvell-arm64/one-image.mk
@@ -4,7 +4,10 @@ SONIC_ONE_IMAGE = sonic-marvell-arm64.bin
 $(SONIC_ONE_IMAGE)_MACHINE = marvell-arm64
 $(SONIC_ONE_IMAGE)_IMAGE_TYPE = onie
 $(SONIC_ONE_IMAGE)_INSTALLS += $(SYSTEMD_SONIC_GENERATOR)
-$(SONIC_ONE_IMAGE)_INSTALLS += $(LINUX_KERNEL_DTB)
+$(SONIC_ONE_IMAGE)_INSTALLS += $(MRVL_PRESTERA_DEB)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8540_16CD_PLATFORM)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8580_32CD_PLATFORM)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(AC5X_RD98DX35xx_PLATFORM)
 ifeq ($(INSTALL_DEBUG_TOOLS),y)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
diff --git a/platform/marvell-arm64/platform-db98cx8540-16cd.mk b/platform/marvell-arm64/platform-db98cx8540-16cd.mk
new file mode 100644
index 000000000..e0bc26892
--- /dev/null
+++ b/platform/marvell-arm64/platform-db98cx8540-16cd.mk
@@ -0,0 +1,12 @@
+# FALCON Platform 
+
+FALCON_VERSION = 1.0
+export FALCON_VERSION
+
+FALCON_DB98CX8540_16CD_PLATFORM = sonic-platform-db98cx8540-16cd-db98cx8540_$(FALCON_VERSION)_$(CONFIGURED_ARCH).deb
+$(FALCON_DB98CX8540_16CD_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-db98cx8540-16cd
+$(FALCON_DB98CX8540_16CD_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(FALCON_DB98CX8540_16CD_PLATFORM)_PLATFORM = arm64-marvell_db98cx8540_16cd-r0
+
+SONIC_DPKG_DEBS += $(FALCON_DB98CX8540_16CD_PLATFORM)
+
diff --git a/platform/marvell-arm64/platform-db98cx8580-32cd.mk b/platform/marvell-arm64/platform-db98cx8580-32cd.mk
new file mode 100644
index 000000000..34129b033
--- /dev/null
+++ b/platform/marvell-arm64/platform-db98cx8580-32cd.mk
@@ -0,0 +1,12 @@
+# FALCON Platform 
+
+FALCON_VERSION = 1.0
+export FALCON_VERSION
+
+FALCON_DB98CX8580_32CD_PLATFORM = sonic-platform-db98cx8580-32cd-db98cx8580_$(FALCON_VERSION)_$(CONFIGURED_ARCH).deb
+$(FALCON_DB98CX8580_32CD_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-db98cx8580-32cd
+$(FALCON_DB98CX8580_32CD_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(FALCON_DB98CX8580_32CD_PLATFORM)_PLATFORM = arm64-marvell_db98cx8580_32cd-r0
+
+SONIC_DPKG_DEBS += $(FALCON_DB98CX8580_32CD_PLATFORM)
+
diff --git a/platform/marvell-arm64/platform-rd98dx35xx.mk b/platform/marvell-arm64/platform-rd98dx35xx.mk
new file mode 100644
index 000000000..9e5a6b18e
--- /dev/null
+++ b/platform/marvell-arm64/platform-rd98dx35xx.mk
@@ -0,0 +1,8 @@
+# AC5X Platform
+
+AC5X_VERSION=1.0
+AC5X_RD98DX35xx_PLATFORM = sonic-platform-rd98dx35xx_$(AC5X_VERSION)_$(CONFIGURED_ARCH).deb
+$(AC5X_RD98DX35xx_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-rd98dx35xx
+$(AC5X_RD98DX35xx_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx-r0
+SONIC_DPKG_DEBS += $(AC5X_RD98DX35xx_PLATFORM)
+
diff --git a/platform/marvell-arm64/platform.conf b/platform/marvell-arm64/platform.conf
index 4ef62d36b..3bdc674bf 100644
--- a/platform/marvell-arm64/platform.conf
+++ b/platform/marvell-arm64/platform.conf
@@ -2,27 +2,70 @@
 
 # over ride default behaviour
 
+PLATFORM_AC5X="arm64-marvell_rd98DX35xx-r0"
+
 echo "Preparing for installation ... "
 
 IS_MASS=0
 # global defines
 kernel_addr=0x1100000
-fdt_addr=0x1000000
-fit_addr=0x1000000
-initrd_addr=0x2000000
+
+if [ "$install_env" = "onie" ]; then
+    MACH_FILE="/etc/machine.conf"
+else
+    MACH_FILE="/host/machine.conf"
+fi
+
+PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
+echo "Intalling SONiC from $install_env on Platform $PLATFORM"
+
+if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+    fdt_addr=0x201000000
+    fit_addr=0x210000000
+    initrd_addr=0x206000000
+else
+    fdt_addr=0x1000000
+    fit_addr=0x8000000
+    initrd_addr=0x2000000
+fi
+
 VAR_LOG=512
-DISK_SIZE=9
+DISK_SIZE=14
+
+kernel_fname="/boot/vmlinuz-5.10.0-18-2-arm64"
+initrd_fname="/boot/initrd.img-5.10.0-18-2-arm64"
+
+if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+    fdt_fname="/boot/ac5x.dtb"
+else
+    fdt_fname="/boot/armada-7020-comexpress.dtb"
+fi
 
-kernel_fname="/boot/vmlinuz-4.9.0-9-2-arm64"
-initrd_fname="/boot/initrd.img-4.9.0-9-2-arm64"
-fdt_fname="/boot/armada-7020-comexpress.dtb"
 fit_fname="/boot/sonic_arm64.fit"
 
+# AC5X related Partition information
+if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+    onie_part_size=168M
+    onie_part_num=1
+    onie_part_label=ONIE
+
+    swap_part_size=3G
+    swap_part_num=3
+    swap_part_label=swap
+
+    sonic_part_num=2
+    sonic_part_label=SONiC-OS
+fi
+
 # global mount defines
 #demo_dev=/dev/sda1
 demo_mnt=/tmp
-#mtd_dev=/dev/$(cat /proc/mtd | grep "ENV" | grep -o "mtd[0-9]")
-FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x100000'
+if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+    FW_ENV_DEFAULT='/dev/mtd0 0x400000 0x10000 0x10000'
+else
+    FW_ENV_DEFAULT='/dev/mtd1 0x0 0x10000 0x100000'
+fi
+
 UBOOT_FW_DEFAULT=1
 
 # Skip VID Header in UBIFS
@@ -79,11 +122,15 @@ prepare_boot_menu() {
                 echo "Error: Unable to detect $blk_dev $demo_dev"
                 exit 1
             fi
-            if [ ${IS_MASS} -eq 1 ]
+
+            if [ "$PLATFORM" = "$PLATFORM_AC5X" ]
+            then
+                demo_part=${sonic_part_num}
+                demo_dev=${blk_dev}p${sonic_part_num}
+            elif [ ${IS_MASS} -eq 1 ]
             then
                 demo_dev=${blk_dev}1
             else
-                #demo_dev=$(echo $blk_dev | sed -e 's/\(mmcblk[0-9]\)/\1p/')$demo_part
                 demo_dev=/dev/mmcblk0p1
             fi
         fi
@@ -104,17 +151,21 @@ prepare_boot_menu() {
     fw_setenv ${FW_ARG} sonic_version_2 $sonic_version_2 > /dev/null
     BOOT1='echo " > Boot1: $sonic_version_1 - run sonic_image_1";echo;'
     BOOT2='echo " > Boot2: $sonic_version_2 - run sonic_image_2";echo;'
-    BOOT3='echo " > Boot3: ONIE - run onie-nand-boot";echo;'
+    if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+        BOOT3='echo " > Boot3: ONIE - run onie_emmc_boot";echo;'
+    else
+        BOOT3='echo " > Boot3: ONIE - run onie_nand_boot";echo;'
+    fi
     BORDER='echo "---------------------------------------------------";echo;'
     fw_setenv ${FW_ARG} print_menu $BORDER $BOOT1 $BOOT2 $BOOT3 $BORDER > /dev/null
 
-    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG ${extra_cmdline_linux}" > /dev/null
-    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG" > /dev/null
+    fw_setenv ${FW_ARG} linuxargs "net.ifnames=0 loopfstype=squashfs loop=$image_dir/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG loglevel=4" > /dev/null
+    fw_setenv ${FW_ARG} linuxargs_old "net.ifnames=0 loopfstype=squashfs loop=$image_dir_old/$FILESYSTEM_SQUASHFS systemd.unified_cgroup_hierarchy=0 varlog_size=$VAR_LOG loglevel=4" > /dev/null
     sonic_bootargs_old='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs_old}'
     fw_setenv ${FW_ARG} sonic_bootargs_old $sonic_bootargs_old > /dev/null || true
     sonic_boot_load_old=$(fw_printenv -n sonic_boot_load || true)
     old_str="_old"
-    fw_setenv ${FW_ARG} sonic_boot_load_old $sonic_boot_load_old$old_str > /dev/null || true
+    fw_setenv ${FW_ARG} sonic_boot_load_old "$sonic_boot_load_old$old_str" > /dev/null || true
 
     fw_setenv ${FW_ARG} kernel_addr $kernel_addr > /dev/null
     fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
@@ -123,17 +174,19 @@ prepare_boot_menu() {
     # Set boot configs
     if [ ${IS_MASS} -eq 1 ]
     then
-        #USB_LOAD='ext4load usb 0 $kernel_addr $image_name; ext4load usb 0 $fdt_addr $fdt_name; ext4load usb 0 $initrd_addr $initrd_name'
         USB_LOAD='ext4load usb 0 $fit_addr $fit_name'
-        fw_setenv ${FW_ARG} sonic_boot_load $USB_LOAD > /dev/null
+        fw_setenv ${FW_ARG} sonic_boot_load "$USB_LOAD" > /dev/null
     else
-        #MMC_LOAD='ext4load mmc 0:'$demo_part' $kernel_addr $image_name; ext4load mmc 0:'$demo_part' $fdt_addr $fdt_name; ext4load mmc 0:'$demo_part' $initrd_addr $initrd_name'
         MMC_LOAD='ext4load mmc 0:'$demo_part' $fit_addr $fit_name'
-        fw_setenv ${FW_ARG} sonic_boot_load $MMC_LOAD > /dev/null
+        fw_setenv ${FW_ARG} sonic_boot_load "$MMC_LOAD" > /dev/null
+    fi
+    if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+        SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr#conf_ac5x'
+        SONIC_BOOT_CMD_OLD='run sonic_bootargs_old; run sonic_boot_load_old; bootm $fit_addr#conf_ac5x'
+    else
+        SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr'
+        SONIC_BOOT_CMD_OLD='run sonic_bootargs_old; run sonic_boot_load_old; bootm $fit_addr'
     fi
-    #SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; booti $kernel_addr $initrd_addr $fdt_addr'
-    SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr'
-    SONIC_BOOT_CMD_OLD='run sonic_bootargs_old; run sonic_boot_load_old; bootm $fit_addr'
     BOOTARGS='setenv bootargs root='$demo_dev' rw rootwait rootfstype=ext4 panic=1 console=ttyS0,115200 ${othbootargs} ${mtdparts} ${linuxargs}'
     fw_setenv ${FW_ARG} sonic_bootargs $BOOTARGS > /dev/null
     fw_setenv ${FW_ARG} sonic_bootcmd $SONIC_BOOT_CMD > /dev/null
@@ -148,6 +201,21 @@ prepare_boot_menu() {
 #Default block device is eMMC, if not look for usb storage
 get_install_device()
 {
+    if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+        mmc_bus="mmc0:0001"
+        for i in 0 1 2 ; do
+            if $(ls -l /sys/block/mmcblk$i/device 2>/dev/null | grep -q "$mmc_bus") ; then
+                echo "/dev/mmcblk$i"
+                blk_dev=/dev/mmcblk$i
+                echo "Selected mmc $blk_dev"
+                return 0
+            fi
+        done
+
+        echo "ERROR storage not found"
+        return 1
+    fi
+
     mass_bus="target0:0:0"
     for i in a b c ; do
         if $(ls -l /sys/block/sd$i/device 2>/dev/null | grep -q "$mass_bus") ; then
@@ -174,6 +242,62 @@ get_install_device()
 
 create_demo_partition() {
 
+    if [ "$PLATFORM" = "$PLATFORM_AC5X" ]
+    then
+        onie_part=$(sgdisk -p "$blk_dev" | grep -e "$onie_part_label" | awk '{print $1}')
+        sonic_part=$(sgdisk -p "$blk_dev" | grep -e "$sonic_part_label" | awk '{print $1}')
+        swap_part=$(sgdisk -p "$blk_dev" | grep -e "$swap_part_label" | awk '{print $1}')
+
+        if [ -z "$onie_part" ]
+        then
+            echo "Partitioning is Incorrect. Re-partitioning"
+            sgdisk -oZ ${blk_dev}
+
+            sgdisk --new ${onie_part_num}:0:+${onie_part_size} \
+                --change-name=${onie_part_num}:${onie_part_label} \
+                --typecode=${onie_part_num}:8300 -p ${blk_dev}
+
+            if [ $? -ne 0 ]; then
+                echo "Failed creating onie eMMC partition"
+                return 2
+            fi
+
+            mkfs.ext4 -F -L ${onie_part_label} ${blk_dev}p${onie_part_num}
+        else
+            fsck.ext4 -v -p ${blk_dev}p${onie_part_num}
+        fi
+
+        if [ -z "$swap_part" ]; then
+            # Create swap partition
+            sgdisk --new ${swap_part_num}:-${swap_part_size}: \
+                --change-name=${swap_part_num}:${swap_part_label} \
+                --typecode=${swap_part_num}:8200 -p ${blk_dev}
+        fi
+
+        if [ -z "$sonic_part" ]; then
+            # Create sonic partition
+            start_num=$(sgdisk -F $blk_dev)
+            end_num=$(sgdisk -E $blk_dev)
+
+            sgdisk --new ${sonic_part_num}:${start_num}:${end_num} \
+                --change-name=${sonic_part_num}:${sonic_part_label} \
+                --typecode=${sonic_part_num}:8300 -p ${blk_dev}
+
+            mkfs.ext4 -F -L ${sonic_part_label} ${blk_dev}p${sonic_part_num}
+        else
+            mkfs.ext4 -F -L ${sonic_part_label} ${blk_dev}p${sonic_part_num}
+        fi
+
+        partprobe
+        sync
+
+        mkswap ${blk_dev}p${swap_part_num}
+        echo "${blk_dev}p${swap_part_num}    swap  swap  defaults   0   0" > /etc/fstab
+        swapon -a
+
+        return 0
+    fi
+
     if [ ${IS_MASS} -eq 1 ]
     then
         # USB drive
@@ -201,11 +325,23 @@ create_partition() {
 }
 
 mount_partition() {
+
+    if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+        demo_part=${sonic_part_num}
+        demo_dev=${blk_dev}p${demo_part}
+
+        mount -t ext4 -o defaults,rw $demo_dev $demo_mnt || {
+            echo "Error: Unable to mount $demo_dev on $demo_mnt"
+            exit 1
+        }
+
+        return 0
+    fi
+
     if [ ${IS_MASS} -eq 1 ]
     then
         demo_dev=${blk_dev}1
     else
-        #demo_dev=$(echo $blk_dev | sed -e 's/\(mmcblk[0-9]\)/\1p/')$demo_part
         demo_dev=/dev/mmcblk0p1
     fi
 
diff --git a/platform/marvell-arm64/prestera.mk b/platform/marvell-arm64/prestera.mk
new file mode 100644
index 000000000..fc7debaf5
--- /dev/null
+++ b/platform/marvell-arm64/prestera.mk
@@ -0,0 +1,11 @@
+# Marvell Prestera
+
+export MRVL_PRESTERA_VER = 1.0
+export MRVL_PRESTERA = mrvlprestera_$(MRVL_PRESTERA_VER)_$(PLATFORM_ARCH)
+export MRVL_PRESTERA_DEB = $(MRVL_PRESTERA).deb
+export MRVL_PRESTERA_SRC_URL = https://github.com/Marvell-switching/mrvl-prestera.git
+export MRVL_PRESTERA_SRC_TAG = MRVL_PRESTERA_DRIVER_1.3
+
+$(MRVL_PRESTERA_DEB)_SRC_PATH = $(PLATFORM_PATH)/prestera
+$(MRVL_PRESTERA_DEB)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+SONIC_DPKG_DEBS += $(MRVL_PRESTERA_DEB)
diff --git a/platform/marvell-arm64/prestera/debian/changelog b/platform/marvell-arm64/prestera/debian/changelog
new file mode 100644
index 000000000..3e1e97802
--- /dev/null
+++ b/platform/marvell-arm64/prestera/debian/changelog
@@ -0,0 +1,5 @@
+mrvlprestera (1.0) unstable; urgency=low
+
+  * Prestera switch driver
+
+ -- Marvell <pnaregundi@marvell.com>  Fri, 19 Feb 2021 10:39:18 +0800
diff --git a/platform/marvell-arm64/prestera/debian/compat b/platform/marvell-arm64/prestera/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell-arm64/prestera/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell-arm64/prestera/debian/control b/platform/marvell-arm64/prestera/debian/control
new file mode 100755
index 000000000..33a96b991
--- /dev/null
+++ b/platform/marvell-arm64/prestera/debian/control
@@ -0,0 +1,15 @@
+Source: mrvlprestera
+Section: unknown
+Priority: optional
+Maintainer: Marvell <pnaregundi@marvell.com>
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+#Vcs-Git: git://anonscm.debian.org/collab-maint/mrvlprestera.git
+#Vcs-Browser: https://anonscm.debian.org/cgit/collab-maint/mrvlprestera.git
+
+Package: mrvlprestera
+Architecture: arm64
+Homepage: <insert the upstream URL, if relevant>
+Description: 
+	kernel modules for prestera switch driver 
diff --git a/platform/marvell-arm64/prestera/debian/mrvlprestera.install.template b/platform/marvell-arm64/prestera/debian/mrvlprestera.install.template
new file mode 100644
index 000000000..5747270e5
--- /dev/null
+++ b/platform/marvell-arm64/prestera/debian/mrvlprestera.install.template
@@ -0,0 +1,3 @@
+mrvl-prestera/drivers/generic/cpssEnabler/linuxNoKernelModule/drivers/mvMbusDrv.ko /lib/modules/KVERSION/kernel/extra
+mrvl-prestera/drivers/generic/cpssEnabler/linuxNoKernelModule/drivers/mvIntDrv.ko /lib/modules/KVERSION/kernel/extra
+mrvl-prestera/platform/arm64/*	/
diff --git a/platform/marvell-arm64/prestera/debian/rules b/platform/marvell-arm64/prestera/debian/rules
new file mode 100755
index 000000000..8601b509e
--- /dev/null
+++ b/platform/marvell-arm64/prestera/debian/rules
@@ -0,0 +1,55 @@
+#!/usr/bin/make -f
+
+include /usr/share/dpkg/pkg-info.mk
+
+PACKAGE_PRE_NAME := mrvlprestera
+ifneq ($(CROSS_BUILD_ENVIRON), y)
+KVERSION   ?= $(shell uname -r)
+endif
+KERNEL_SRC :=  /lib/modules/$(KVERSION)
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIR := mrvl-prestera/drivers/generic/cpssEnabler/linuxNoKernelModule/drivers
+
+%:
+	dh $@ --with systemd,python2,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	# get sources
+	rm -rf mrvl-prestera || true
+	git clone -b ${MRVL_PRESTERA_SRC_TAG} ${MRVL_PRESTERA_SRC_URL}
+	sed "s/KVERSION/${KVERSION}/g" /sonic/platform/marvell-arm64/prestera/debian/mrvlprestera.install.template > /sonic/platform/marvell-arm64/prestera/debian/mrvlprestera.install
+
+	make modules -C $(KERNEL_SRC)/build M=$(MOD_SRC_DIR)/$(MODULE_DIR)/
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch: 
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/rules.mk b/platform/marvell-arm64/rules.mk
index e63059d3f..e549af165 100644
--- a/platform/marvell-arm64/rules.mk
+++ b/platform/marvell-arm64/rules.mk
@@ -5,7 +5,10 @@ include $(PLATFORM_PATH)/docker-syncd-mrvl-rpc.mk
 include $(PLATFORM_PATH)/docker-saiserver-mrvl.mk
 include $(PLATFORM_PATH)/libsaithrift-dev.mk
 include $(PLATFORM_PATH)/one-image.mk
-include $(PLATFORM_PATH)/linux-kernel-arm64.mk
+include $(PLATFORM_PATH)/prestera.mk
+include $(PLATFORM_PATH)/platform-db98cx8540-16cd.mk
+include $(PLATFORM_PATH)/platform-db98cx8580-32cd.mk
+include $(PLATFORM_PATH)/platform-rd98dx35xx.mk
 
 SONIC_ALL += $(SONIC_ONE_IMAGE) \
              $(DOCKER_FPM) 	\
diff --git a/platform/marvell-arm64/sai.mk b/platform/marvell-arm64/sai.mk
index 6cf794729..f6372ca68 100644
--- a/platform/marvell-arm64/sai.mk
+++ b/platform/marvell-arm64/sai.mk
@@ -1,7 +1,7 @@
 # Marvell SAI
 
-export MRVL_SAI_VERSION = 1.5.1
-export MRVL_SAI = mrvllibsai_$(PLATFORM_ARCH)_$(MRVL_SAI_VERSION).deb
+export MRVL_SAI_VERSION = 1.11.0-8
+export MRVL_SAI = mrvllibsai_$(MRVL_SAI_VERSION)_$(PLATFORM_ARCH).deb
 
 $(MRVL_SAI)_SRC_PATH = $(PLATFORM_PATH)/sai
 $(eval $(call add_conflict_package,$(MRVL_SAI),$(LIBSAIVS_DEV)))
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh
new file mode 100644
index 000000000..871ec2a72
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd-init.sh
@@ -0,0 +1,22 @@
+#!/bin/bash
+
+# Platform init script for db98cx8540-16cd 
+
+db98cx8540_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*db98cx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "db98cx8540: Updating switch mac address ${MAC_ADDR}"
+}
+
+
+# - Main entry
+
+db98cx8540_profile
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+# the mux may be enumerated at number 4 or 5 so we check for the mux and skip if needed
+# Get list of the mux channels
+# Enumerate the SFP eeprom device on each mux channel
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-0/new_device
+
+exit 0
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd_plt_setup.sh b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd_plt_setup.sh
new file mode 100644
index 000000000..172e50fbb
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/scripts/db98cx8540-16cd_plt_setup.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+PLATFORM_FALCON="arm64-marvell_db98cx8540_16cd-r0"
+MACH_FILE="/host/machine.conf"
+
+db98cx8540_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*db98cx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "db98cx8540: Updating switch mac address ${MAC_ADDR}"
+}
+
+main()
+{
+    if [ -f "$MACH_FILE" ]; then
+        PLATFORM=`sed -n 's/onie_platform=\(.*\)/\1/p' $MACH_FILE`
+        if [ "$PLATFORM" = "$PLATFORM_FALCON" ]; then
+            db98cx8540_profile
+        fi
+    fi
+}
+
+main $@
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service
new file mode 100644
index 000000000..2a29621b0
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/service/db98cx8540-16cd-init.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=Platform db98cx8540-16cd Service
+After=rc-local.service
+Before=getty.target
+
+[Service]
+ExecStart=/usr/local/bin/db98cx8540-16cd-init.sh
+StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py
new file mode 100644
index 000000000..ba72a742c
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'db98cx8540/sonic_platform'},
+)
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py
new file mode 100644
index 000000000..d47d563fe
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/chassis.py
@@ -0,0 +1,311 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 0
+COPPER_PORT_END = 0
+SFP_PORT_START = 1
+SFP_PORT_END = 132
+PORT_END = 132
+MAX_COMPONENT=2
+
+profile_6_4_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,3",  53:"0x70,3",  54:"0x70,3",  55:"0x70,3",
+ 56:"0x71,4",  57:"0x71,4",  58:"0x71,5",  59:"0x71,5",  60:"0x71,6",  61:"0x71,6",  62:"0x71,7",  63:"0x71,7",
+ 64:"0x71,0",  65:"0x71,1",  66:"0x71,2",  67:"0x71,3",  68:"0x74,4",  69:"0x74,5" }
+
+profile_128x50G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_48x25G_4x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x74,4",  53:"0x74,5" }
+
+sfputil_profiles = {
+ "FC6_8T-DB":profile_6_4_db,
+ "FC128x50G":profile_128x50G,
+ "FC48x25G4x100GR4":profile_48x25G_4x100G
+}
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_db98cx8540_16cd-r0"
+    HWSKU = "db98cx8540_16cd"
+
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        # Port numbers for Initialize SFP list
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        sai_profile_path=self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+        eeprom_path = '/sys/bus/i2c/devices/0-0050/eeprom'
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            profile = sfputil_profiles[self._port_profile]
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            if port in profile:
+                sfp_node = Sfp(index, 'QSFP', port_eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+            component = Component(i)
+            self._component_list.append(component)
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def __get_path_to_sai_profile_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                                ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py
new file mode 100644
index 000000000..ee3dbfc6c
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/component.py
@@ -0,0 +1,92 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["U-Boot", "Performs initialization during booting"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+
+        if self.index == 0:
+            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -2 | cut -d" " -f2')
+            return uboot_version
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py
new file mode 100644
index 000000000..a6f6bea17
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/eeprom.py
@@ -0,0 +1,237 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Serial number, Part number, Service Tag,
+#                PSU type, Revision.
+# - Fan EEPROM : Contains Serial number, Part number, Service Tag,
+#                Fan type, Number of Fans in Fantray, Revision.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = "/etc/sonic/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 6
+                #self.eeprom_path = self.I2C_DIR \
+                #    + "i2c-3{0}/3{0}-0056/eeprom".format(self.index - 1)
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(2 - self.index)
+                self.format = psu_eeprom_format
+            else:
+                self.index = fan_index
+                self.start_offset = 13
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-4{0}/4{0}-0050/eeprom".format(self.index - 1)
+                self.format = fan_eeprom_format
+            EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                   self.start_offset, '', True)
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and retrieves the serial number and
+        model number of the device.
+        """
+        try:
+            # Read Fan/PSU EEPROM as per the specified format.
+            self.eeprom_data = EepromDecoder.read_eeprom(self)
+        except Exception as e:
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+        else:
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data
+            else:
+                self.model_str = 'NA'
+
+            (valid, data) = self._get_eeprom_field("Serial Number")
+            if valid:
+                self.serial_number = data
+            else:
+                self.serial_number = 'NA'
+
+            if self.is_psu_eeprom:
+                (valid, data) = self._get_eeprom_field("PSU Type")
+                if valid:
+                    self.psu_type = data
+                else:
+                    self.psu_type = 'NA'
+            else:
+                (valid, data) = self._get_eeprom_field("Fan Type")
+                if valid:
+                    self.fan_type = data
+                else:
+                    self.fan_type = 'NA'
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py
new file mode 100644
index 000000000..f40b03895
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp.py
@@ -0,0 +1,1379 @@
+#!/usr/bin/env python
+import os
+import time
+from ctypes import create_string_buffer
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom
+    from sonic_platform_base.sonic_sfp.inf8628 import inf8628InterfaceId
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_6_4_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,3",  53:"0x70,3",  54:"0x70,3",  55:"0x70,3",
+ 56:"0x71,4",  57:"0x71,4",  58:"0x71,5",  59:"0x71,5",  60:"0x71,6",  61:"0x71,6",  62:"0x71,7",  63:"0x71,7",
+ 64:"0x71,0",  65:"0x71,1",  66:"0x71,2",  67:"0x71,3",  68:"0x74,4",  69:"0x74,5" }
+
+profile_128x50G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_48x25G_4x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x74,4",  53:"0x74,5" }
+
+sfputil_profiles = {
+ "FC6_8T-DB":profile_6_4_db,
+ "FC128x50G":profile_128x50G,
+ "FC48x25G4x100GR4":profile_48x25G_4x100G
+}
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+XCVR_INTFACE_BULK_WIDTH_QSFP = 20
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+XCVR_CABLE_LENGTH_WIDTH_QSFP = 5
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+XCVR_HW_REV_WIDTH_OSFP = 2
+XCVR_HW_REV_WIDTH_QSFP = 2
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+QSFP_DOM_BULK_DATA_START = 22
+QSFP_DOM_BULK_DATA_SIZE = 36
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+# definitions of the offset for values in OSFP info eeprom
+OSFP_TYPE_OFFSET = 0
+OSFP_VENDOR_NAME_OFFSET = 129
+OSFP_VENDOR_PN_OFFSET = 148
+OSFP_HW_REV_OFFSET = 164
+OSFP_VENDOR_SN_OFFSET = 166
+
+# Offset for values in QSFP eeprom
+QSFP_DOM_REV_OFFSET = 1
+QSFP_DOM_REV_WIDTH = 1
+QSFP_TEMPE_OFFSET = 22
+QSFP_TEMPE_WIDTH = 2
+QSFP_VOLT_OFFSET = 26
+QSFP_VOLT_WIDTH = 2
+QSFP_VERSION_COMPLIANCE_OFFSET = 1
+QSFP_VERSION_COMPLIANCE_WIDTH = 2
+QSFP_CHANNL_MON_OFFSET = 34
+QSFP_CHANNL_MON_WIDTH = 16
+QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH = 24
+QSFP_CHANNL_DISABLE_STATUS_OFFSET = 86
+QSFP_CHANNL_DISABLE_STATUS_WIDTH = 1
+QSFP_CHANNL_RX_LOS_STATUS_OFFSET = 3
+QSFP_CHANNL_RX_LOS_STATUS_WIDTH = 1
+QSFP_CHANNL_TX_FAULT_STATUS_OFFSET = 4
+QSFP_CHANNL_TX_FAULT_STATUS_WIDTH = 1
+QSFP_CONTROL_OFFSET = 86
+QSFP_CONTROL_WIDTH = 8
+QSFP_MODULE_MONITOR_OFFSET = 0
+QSFP_MODULE_MONITOR_WIDTH = 9
+QSFP_POWEROVERRIDE_OFFSET = 93
+QSFP_POWEROVERRIDE_WIDTH = 1
+QSFP_POWEROVERRIDE_BIT = 0
+QSFP_POWERSET_BIT = 1
+QSFP_OPTION_VALUE_OFFSET = 192
+QSFP_OPTION_VALUE_WIDTH = 4
+QSFP_MODULE_UPPER_PAGE3_START = 384
+QSFP_MODULE_THRESHOLD_OFFSET = 128
+QSFP_MODULE_THRESHOLD_WIDTH = 24
+QSFP_CHANNL_THRESHOLD_OFFSET = 176
+QSFP_CHANNL_THRESHOLD_WIDTH = 24
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+
+qsfp_cable_length_tup = ('Length(km)', 'Length OM3(2m)',
+                         'Length OM2(m)', 'Length OM1(m)',
+                         'Length Cable Assembly(m)')
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+qsfp_compliance_code_tup = ('10/40G Ethernet Compliance Code', 'SONET Compliance codes',
+                            'SAS/SATA compliance codes', 'Gigabit Ethernet Compliant codes',
+                            'Fibre Channel link length/Transmitter Technology',
+                            'Fibre Channel transmission media', 'Fibre Channel Speed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+QSFP_TYPE = "QSFP"
+OSFP_TYPE = "OSFP"
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class Sfp(SfpBase):
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_db98cx8540_16cd-r0"
+    HWSKU = "db98cx8540_16cd"
+    _port_start = 1
+    _port_end = 132
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+        self.port_to_eeprom_mapping[index] = eeprom_path
+        sai_profile_path = self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path  + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+        self._dom_capability_detect()
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+    
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+                cmd = "i2cset -y 0 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+                os.system(cmd)
+        else:
+                bus = smbus.SMBus(0)
+                bus.write_byte_data(device_addr, offset, value)
+
+    def __get_path_to_port_config_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "port_config.ini"])
+ 
+    def __get_path_to_sai_profile_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == COPPER_TYPE:
+            return
+
+        if self.sfp_type == "QSFP":
+            self.calibration = 1
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                self.dom_supported = False
+            offset = 128
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                (offset + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qsfp_version_compliance_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_VERSION_COMPLIANCE_OFFSET, QSFP_VERSION_COMPLIANCE_WIDTH)
+                qsfp_version_compliance = int(
+                    qsfp_version_compliance_raw[0], 16)
+                dom_capability = sfpi_obj.parse_dom_capability(
+                    qsfp_dom_capability_raw, 0)
+                if qsfp_version_compliance >= 0x08:
+                    self.dom_temp_supported = dom_capability['data']['Temp_support']['value'] == 'On'
+                    self.dom_volt_supported = dom_capability['data']['Voltage_support']['value'] == 'On'
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = dom_capability['data']['Tx_power_support']['value'] == 'On'
+                else:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = True
+
+                self.dom_supported = True
+                self.calibration = 1
+                sfpd_obj = sff8436Dom()
+                if sfpd_obj is None:
+                    return None
+                qsfp_option_value_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_OPTION_VALUE_OFFSET, QSFP_OPTION_VALUE_WIDTH)
+                if qsfp_option_value_raw is not None:
+                    optional_capability = sfpd_obj.parse_option_params(
+                        qsfp_option_value_raw, 0)
+                    self.dom_tx_disable_supported = optional_capability[
+                        'data']['TxDisable']['value'] == 'On'
+                dom_status_indicator = sfpd_obj.parse_dom_status_indicator(
+                    qsfp_version_compliance_raw, 1)
+                self.qsfp_page3_available = dom_status_indicator['data']['FlatMem']['value'] == 'Off'
+            else:
+                self.dom_supported = False
+                self.dom_temp_supported = False
+                self.dom_volt_supported = False
+                self.dom_rx_power_supported = False
+                self.dom_tx_power_supported = False
+                self.calibration = 0
+                self.qsfp_page3_available = False
+
+        elif self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if self.sfp_type == OSFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            sfp_type_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                    sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                    sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                    sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                    sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if self.sfp_type == QSFP_TYPE:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+            if self.sfp_type == QSFP_TYPE:
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 0
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_DOM_BULK_DATA_START), QSFP_DOM_BULK_DATA_SIZE)
+
+            if dom_data_raw is None:
+                return transceiver_dom_info_dict
+
+            if self.dom_temp_supported:
+                start = QSFP_TEMPE_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_TEMPE_WIDTH
+                dom_temperature_data = sfpd_obj.parse_temperature(
+                    dom_data_raw[start: end], 0)
+                temp = self.__convert_string_to_num(
+                    dom_temperature_data['data']['Temperature']['value'])
+                if temp is not None:
+                    transceiver_dom_info_dict['temperature'] = temp
+
+            if self.dom_volt_supported:
+                start = QSFP_VOLT_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_VOLT_WIDTH
+                dom_voltage_data = sfpd_obj.parse_voltage(
+                    dom_data_raw[start: end], 0)
+                volt = self.__convert_string_to_num(
+                    dom_voltage_data['data']['Vcc']['value'])
+                if volt is not None:
+                    transceiver_dom_info_dict['voltage'] = volt
+
+            start = QSFP_CHANNL_MON_OFFSET - QSFP_DOM_BULK_DATA_START
+            end = start + QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                dom_data_raw[start: end], 0)
+
+            if self.dom_tx_power_supported:
+                transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX1Power']['value'])
+                transceiver_dom_info_dict['tx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX2Power']['value'])
+                transceiver_dom_info_dict['tx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX3Power']['value'])
+                transceiver_dom_info_dict['tx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX4Power']['value'])
+
+            if self.dom_rx_power_supported:
+                transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX1Power']['value'])
+                transceiver_dom_info_dict['rx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX2Power']['value'])
+                transceiver_dom_info_dict['rx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX3Power']['value'])
+                transceiver_dom_info_dict['rx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX4Power']['value'])
+
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported or not self.qsfp_page3_available:
+                return transceiver_dom_threshold_info_dict
+
+            # Dom Threshold data starts from offset 384
+            # Revert offset back to 0 once data is retrieved
+            offset = QSFP_MODULE_UPPER_PAGE3_START
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_THRESHOLD_OFFSET), QSFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_data = sfpd_obj.parse_module_threshold_values(
+                dom_module_threshold_raw, 0)
+
+            dom_channel_threshold_raw = self.__read_eeprom_specific_bytes((offset + QSFP_CHANNL_THRESHOLD_OFFSET),
+                                                                          QSFP_CHANNL_THRESHOLD_WIDTH)
+            if dom_channel_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+            dom_channel_threshold_data = sfpd_obj.parse_channel_threshold_values(
+                dom_channel_threshold_raw, 0)
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VccHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VccHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VccLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VccLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_channel_threshold_data['data']['RxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_channel_threshold_data['data']['RxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_channel_threshold_data['data']['RxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_channel_threshold_data['data']['RxPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_channel_threshold_data['data']['TxBiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_channel_threshold_data['data']['TxBiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_channel_threshold_data['data']['TxBiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_channel_threshold_data['data']['TxBiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_channel_threshold_data['data']['TxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_channel_threshold_data['data']['TxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_channel_threshold_data['data']['TxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_channel_threshold_data['data']['TxPowerLowWarning']['value']
+
+        else:
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == OSFP_TYPE:
+            return False
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+            dom_module_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_MONITOR_OFFSET), QSFP_MODULE_MONITOR_WIDTH)
+
+            if dom_module_monitor_raw is not None:
+                return True
+            else:
+                return False
+        elif self.sfp_type == SFP_TYPE:
+            offset = 0
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        return False
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        return False
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+        return False
+ 
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == QSFP_TYPE:
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return False
+
+            dom_control_raw = self.__read_eeprom_specific_bytes(
+                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None
+            if dom_control_raw is not None:
+                dom_control_data = sfpd_obj.parse_control_bytes(
+                    dom_control_raw, 0)
+                return ('On' == dom_control_data['data']['PowerOverride']['value'])
+        else:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+            A list of four integer numbers, representing TX bias in mA
+            for channel 0 to channel 4.
+            Ex. ['110.09', '111.12', '108.21', '112.09']
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx1_bs = transceiver_bulk_status.get("tx1bias", "N/A")
+        tx2_bs = transceiver_bulk_status.get("tx2bias", "N/A")
+        tx3_bs = transceiver_bulk_status.get("tx3bias", "N/A")
+        tx4_bs = transceiver_bulk_status.get("tx4bias", "N/A")
+        tx_bias_list = [tx1_bs, tx2_bs, tx3_bs, tx4_bs]
+        return tx_bias_list
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_rx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX1Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX2Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX3Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_tx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX1Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX2Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX3Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP and return all user module settings to their default srate.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        # Check for invalid port_num
+        if self.port_num < self._port_start or self.port_num > self._port_end:
+            return False
+        port_ps = "/sys/bus/i2c/devices/0-0050/sfp_port_reset"
+        try:
+            reg_file = open(port_ps, 'w')
+        except IOError as e:
+            print(e)
+            return False
+
+        #toggle reset
+        reg_file.seek(0)
+        reg_file.write('1')
+        time.sleep(1)
+        reg_file.seek(0)
+        reg_file.write('0')
+        reg_file.close()
+        return True
+
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX for all channels
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                tx_disable_ctl = 0xf if tx_disable else 0x0
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                channel_state = self.get_tx_disable_channel()
+                tx_enable_mask = [0xe, 0xd, 0xb, 0x7]
+                tx_disable_mask = [0x1, 0x3, 0x7, 0xf]
+                tx_disable_ctl = channel_state | tx_disable_mask[
+                    channel] if disable else channel_state & tx_enable_mask[channel]
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            try:
+                power_override_bit = 0
+                if power_override:
+                    power_override_bit |= 1 << 0
+
+                power_set_bit = 0
+                if power_set:
+                    power_set_bit |= 1 << 1
+
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(power_override_bit | power_set_bit)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_POWEROVERRIDE_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+        self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        port_index = self.port_num-1
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+        profile = sfputil_profiles[self._port_profile]
+        if  port_index not in profile:
+            return False
+        else:
+            offset = int(profile[port_index].split(",")[1])
+            bin_offset = 1<<offset
+            device_reg = int(profile[port_index].split(",")[0],16)
+            self.i2c_set(device_reg, 0, bin_offset)
+            try:
+                reg_file = open(sysfs_sfp_i2c_client_eeprom_path, 'rb')
+                reg_file.seek(1)
+                reg_file.read(2)
+            except IOError as e:
+                return False
+
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..6bc036360
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/sfp_event.py
@@ -0,0 +1,215 @@
+#!/usr/bin/env python
+'''
+listen to the SDK for the SFP change event and return to chassis.
+'''
+
+from __future__ import print_function
+import os
+import time
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_6_4_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,3",  53:"0x70,3",  54:"0x70,3",  55:"0x70,3",
+ 56:"0x71,4",  57:"0x71,4",  58:"0x71,5",  59:"0x71,5",  60:"0x71,6",  61:"0x71,6",  62:"0x71,7",  63:"0x71,7",
+ 64:"0x71,0",  65:"0x71,1",  66:"0x71,2",  67:"0x71,3",  68:"0x74,4",  69:"0x74,5" }
+
+profile_128x50G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,0", 101:"0x71,0", 102:"0x71,0", 103:"0x71,0",
+104:"0x71,1", 105:"0x71,1", 106:"0x71,1", 107:"0x71,1", 108:"0x71,1", 109:"0x71,1", 110:"0x71,1", 111:"0x71,1",
+112:"0x71,2", 113:"0x71,2", 114:"0x71,2", 115:"0x71,2", 116:"0x71,2", 117:"0x71,2", 118:"0x71,2", 119:"0x71,2",
+120:"0x71,3", 121:"0x71,3", 122:"0x71,3", 123:"0x71,3", 124:"0x71,3", 125:"0x71,3", 126:"0x71,3", 127:"0x71,3",
+128:"0x74,4", 129:"0x74,5" }
+
+profile_48x25G_4x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x74,4",  53:"0x74,5" }
+
+sfputil_profiles = {
+ "FC6_8T-DB":profile_6_4_db,
+ "FC128x50G":profile_128x50G,
+ "FC48x25G4x100GR4":profile_48x25G_4x100G
+}
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+HOST_CHK_CMD = "docker > /dev/null 2>&1"
+PLATFORM = "arm64-marvell_db98cx8540_16cd-r0"
+HWSKU = "db98cx8540_16cd"
+
+# SFP PORT numbers
+SFP_PORT_START = 1
+SFP_PORT_END = 132
+
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+
+    def __init__(self):
+        
+        self.handle = None
+        self.port_to_eeprom_mapping = {}
+        self.SFP_PORT_START=SFP_PORT_START
+        self.SFP_PORT_END=SFP_PORT_END
+        self.PLATFORM_ROOT_PATH=PLATFORM_ROOT_PATH
+        self.PLATFORM=PLATFORM
+        self.PMON_HWSKU_PATH=PMON_HWSKU_PATH
+        self.HOST_CHK_CMD = HOST_CHK_CMD
+        self.HWSKU = HWSKU
+
+        eeprom_path="/sys/bus/i2c/devices/0-0050/eeprom"
+
+        x = self.SFP_PORT_START
+        while(x<self.SFP_PORT_END+1):
+            self.port_to_eeprom_mapping[x] = eeprom_path
+            x = x + 1
+        path=self.__get_path_to_sai_file()
+        cmd = "cat " + path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+ 
+    def initialize(self):       
+        self.modprs_register = 0 
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+            cmd = "i2cset -y 0 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+            os.system(cmd)
+        else:
+            bus = smbus.SMBus(0)
+            bus.write_byte_data(device_addr, offset, value)
+      
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+        sfp_status = 0
+        x = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+                port_index = index-1
+                profile = sfputil_profiles[self._port_profile]
+                if  port_index in profile:
+                        offset = int(profile[port_index].split(",")[1])
+                        bin_offset = 1<<offset
+                        device_reg = int(profile[port_index].split(",")[0],16)
+                        self.i2c_set(device_reg, 0, bin_offset)
+                        path = "/sys/bus/i2c/devices/0-0050/eeprom"
+                        try:
+                                reg_file = open(path, 'rb')
+                                reg_file.seek(1)
+                                reg_file.read(2)
+                                sfp_status=( x | (1<<index-self.SFP_PORT_START)) + sfp_status
+                        except IOError as e:
+                                sfp_status=( x & ~(1<<index-self.SFP_PORT_START)) + sfp_status
+
+        sfp_status = ~sfp_status
+        return sfp_status
+
+    def __get_path_to_sai_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+         check_sfp_status called from get_change_event,
+            this will return correct status of all 4 SFP ports if there is a change in any of them 
+        """
+    
+        start_time = time.time()
+        port = self.SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000) # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {} # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= self.SFP_PORT_START and port <=self.SFP_PORT_END):
+                    profile = sfputil_profiles[self._port_profile]
+                    port_index = port - 1 
+                    if  port_index in profile:
+                        # Mask off the bit corresponding to our port
+                        mask = (1 << port-SFP_PORT_START)
+                        if (changed_ports & mask):
+                                # ModPrsL is active high
+                                if reg_value & mask == 0:
+                                     port_change[port] = '1'
+                                else:
+                                     port_change[port] = '0'
+                    port += 1
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1) # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py
new file mode 100644
index 000000000..8c8541ea0
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/sonic_platform/watchdog.py
@@ -0,0 +1,133 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/db98cx8540/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/changelog b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/changelog
new file mode 100644
index 000000000..1fd791934
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/changelog
@@ -0,0 +1,4 @@
+sonic-platform-db98cx8540-16cd-db98cx8540 (1.0) unstable; urgency=low
+
+  * Add support for sonic-platform-db98cx8540-16cd
+  -- Marvell Wed, 15 Apr 2020 09:35:58 +0800
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/compat b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/control b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/control
new file mode 100644
index 000000000..6d52332a2
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-db98cx8540-16cd-db98cx8540
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-db98cx8540-16cd-db98cx8540
+Architecture: arm64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/rules b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/rules
new file mode 100755
index 000000000..00ca29b16
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/rules
@@ -0,0 +1,65 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-db98cx8540-16cd
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= db98cx8540
+UTILS_DIR := utils
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		python2 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install
new file mode 100644
index 000000000..3f5de523b
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.install
@@ -0,0 +1,4 @@
+db98cx8540/scripts/db98cx8540-16cd_plt_setup.sh usr/local/bin
+db98cx8540/scripts/db98cx8540-16cd-init.sh  usr/local/bin
+db98cx8540/service/db98cx8540-16cd-init.service etc/systemd/system
+db98cx8540/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-marvell_db98cx8540_16cd-r0
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst
new file mode 100644
index 000000000..25094df69
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8540-16cd/debian/sonic-platform-db98cx8540-16cd-db98cx8540.postinst
@@ -0,0 +1,10 @@
+#!/bin/sh
+# postinst script for sonic-platform-db98cx8540-16cd
+#
+# see: dh_installdeb(1)
+
+sh /usr/local/bin/db98cx8540-16cd_plt_setup.sh
+chmod a+x /usr/local/bin/db98cx8540-16cd-init.sh
+systemctl enable db98cx8540-16cd-init.service
+exit 0
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh
new file mode 100644
index 000000000..d164985db
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd-init.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+# Platform init script for db98cx8580-32cd 
+
+db98cx8580_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*db98cx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "db98cx8540: Updating switch mac address ${MAC_ADDR}"
+}
+
+# - Main entry
+db98cx8580_profile
+
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+# the mux may be enumerated at number 4 or 5 so we check for the mux and skip if needed
+# Get list of the mux channels
+# Enumerate the SFP eeprom device on each mux channel
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-0/new_device
+exit 0
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd_plt_setup.sh b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd_plt_setup.sh
new file mode 100644
index 000000000..12adc4abe
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/scripts/db98cx8580-32cd_plt_setup.sh
@@ -0,0 +1,23 @@
+#!/bin/bash
+
+PLATFORM_FALCON="arm64-marvell_db98cx8580_32cd-r0"
+MACH_FILE="/host/machine.conf"
+
+db98cx8580_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*db98cx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "db98cx8540: Updating switch mac address ${MAC_ADDR}"
+}
+
+main()
+{
+    if [ -f "$MACH_FILE" ]; then
+        PLATFORM=`sed -n 's/onie_platform=\(.*\)/\1/p' $MACH_FILE`
+        if [ "$PLATFORM" = "$PLATFORM_FALCON" ]; then
+            db98cx8580_profile
+        fi
+    fi
+}
+
+main $@
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service
new file mode 100644
index 000000000..e759256ba
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/service/db98cx8580-32cd-init.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=Platform db98cx8580-32cd Service
+After=rc-local.service
+Before=getty.target
+
+[Service]
+ExecStart=/usr/local/bin/db98cx8580-32cd-init.sh
+StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py
new file mode 100644
index 000000000..e48d2e160
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'db98cx8580/sonic_platform'},
+)
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py
new file mode 100644
index 000000000..fa110ba5b
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/chassis.py
@@ -0,0 +1,310 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 0
+COPPER_PORT_END = 0
+SFP_PORT_START = 1
+SFP_PORT_END = 257
+PORT_END = 257
+MAX_COMPONENT=2
+
+profile_12_8_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,1", 101:"0x71,1", 102:"0x71,1", 103:"0x71,1",
+104:"0x71,2", 105:"0x71,2", 106:"0x71,2", 107:"0x71,2", 108:"0x71,3", 109:"0x71,3", 110:"0x71,3", 111:"0x71,3",
+112:"0x72,4", 113:"0x72,4", 114:"0x72,5", 115:"0x72,5", 116:"0x72,6", 117:"0x72,6", 118:"0x72,7", 119:"0x71,7",
+120:"0x72,0", 121:"0x72,0", 122:"0x72,1", 123:"0x72,1", 124:"0x72,2", 125:"0x72,2", 126:"0x72,3", 127:"0x72,3",
+128:"0x73,4", 129:"0x73,5", 130:"0x73,6", 131:"0x73,7", 132:"0x73,0", 133:"0x73,1", 134:"0x73,2", 135:"0x73,3",
+136:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4", 4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x72,4",  53:"0x72,5",  54:"0x72,6",  55:"0x72,7",
+ 56:"0x74,4" }
+
+sfputil_profiles = {
+ "FC12_8T-DB":profile_12_8_db,
+ "FC48x25G8x100GR4":profile_48x25G_8x100G,
+ "FALCON32X25G":profile_32x25G
+}
+
+
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_db98cx8580_32cd-r0"
+    HWSKU = os.popen('''cat /etc/sonic/config_db.json |grep hwsku |cut -d \\" -f 4''').read().strip()
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        # Port numbers for Initialize SFP list
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        sai_profile_path=self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+        eeprom_path = '/sys/bus/i2c/devices/0-0050/eeprom'
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            profile = sfputil_profiles[self._port_profile]
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            if port in profile:
+                sfp_node = Sfp(index, 'QSFP', port_eeprom_path, i2cdev )
+                self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+             component = Component(i)
+             self._component_list.append(component)
+
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def __get_path_to_sai_profile_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                                ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py
new file mode 100644
index 000000000..a6ce2f602
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/component.py
@@ -0,0 +1,94 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["U-Boot", "Performs initialization during booting"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+
+        if self.index == 0:
+            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data U-Boot /dev/mtd0ro|head -2 | cut -d" " -f2')
+            return uboot_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py
new file mode 100644
index 000000000..a6f6bea17
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/eeprom.py
@@ -0,0 +1,237 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Serial number, Part number, Service Tag,
+#                PSU type, Revision.
+# - Fan EEPROM : Contains Serial number, Part number, Service Tag,
+#                Fan type, Number of Fans in Fantray, Revision.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = "/etc/sonic/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            if self.is_psu_eeprom:
+                self.index = psu_index
+                self.start_offset = 6
+                #self.eeprom_path = self.I2C_DIR \
+                #    + "i2c-3{0}/3{0}-0056/eeprom".format(self.index - 1)
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-0/0-005{}/eeprom".format(2 - self.index)
+                self.format = psu_eeprom_format
+            else:
+                self.index = fan_index
+                self.start_offset = 13
+                self.eeprom_path = self.I2C_DIR \
+                    + "i2c-4{0}/4{0}-0050/eeprom".format(self.index - 1)
+                self.format = fan_eeprom_format
+            EepromDecoder.__init__(self, self.eeprom_path, self.format,
+                                   self.start_offset, '', True)
+            self._load_device_eeprom()
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _load_device_eeprom(self):
+        """
+        Reads the Fan/PSU EEPROM and retrieves the serial number and
+        model number of the device.
+        """
+        try:
+            # Read Fan/PSU EEPROM as per the specified format.
+            self.eeprom_data = EepromDecoder.read_eeprom(self)
+        except Exception as e:
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+        else:
+            (valid, data) = self._get_eeprom_field("Model")
+            if valid:
+                self.model_str = data
+            else:
+                self.model_str = 'NA'
+
+            (valid, data) = self._get_eeprom_field("Serial Number")
+            if valid:
+                self.serial_number = data
+            else:
+                self.serial_number = 'NA'
+
+            if self.is_psu_eeprom:
+                (valid, data) = self._get_eeprom_field("PSU Type")
+                if valid:
+                    self.psu_type = data
+                else:
+                    self.psu_type = 'NA'
+            else:
+                (valid, data) = self._get_eeprom_field("Fan Type")
+                if valid:
+                    self.fan_type = data
+                else:
+                    self.fan_type = 'NA'
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        else:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py
new file mode 100644
index 000000000..9859cde6e
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp.py
@@ -0,0 +1,1378 @@
+#!/usr/bin/env python
+import os
+import time
+from ctypes import create_string_buffer
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8436 import sff8436Dom
+    from sonic_platform_base.sonic_sfp.inf8628 import inf8628InterfaceId
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_12_8_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,1", 101:"0x71,1", 102:"0x71,1", 103:"0x71,1",
+104:"0x71,2", 105:"0x71,2", 106:"0x71,2", 107:"0x71,2", 108:"0x71,3", 109:"0x71,3", 110:"0x71,3", 111:"0x71,3",
+112:"0x72,4", 113:"0x72,4", 114:"0x72,5", 115:"0x72,5", 116:"0x72,6", 117:"0x72,6", 118:"0x72,7", 119:"0x71,7",
+120:"0x72,0", 121:"0x72,0", 122:"0x72,1", 123:"0x72,1", 124:"0x72,2", 125:"0x72,2", 126:"0x72,3", 127:"0x72,3",
+128:"0x73,4", 129:"0x73,5", 130:"0x73,6", 131:"0x73,7", 132:"0x73,0", 133:"0x73,1", 134:"0x73,2", 135:"0x73,3",
+136:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4", 4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x72,4",  53:"0x72,5",  54:"0x72,6",  55:"0x72,7",
+ 56:"0x74,4" }
+
+sfputil_profiles = {
+ "FC12_8T-DB":profile_12_8_db,
+ "FC48x25G8x100GR4":profile_48x25G_8x100G,
+ "FALCON32X25G":profile_32x25G
+}
+
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+XCVR_INTFACE_BULK_WIDTH_QSFP = 20
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+XCVR_CABLE_LENGTH_WIDTH_QSFP = 5
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+XCVR_HW_REV_WIDTH_OSFP = 2
+XCVR_HW_REV_WIDTH_QSFP = 2
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+QSFP_DOM_BULK_DATA_START = 22
+QSFP_DOM_BULK_DATA_SIZE = 36
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+# definitions of the offset for values in OSFP info eeprom
+OSFP_TYPE_OFFSET = 0
+OSFP_VENDOR_NAME_OFFSET = 129
+OSFP_VENDOR_PN_OFFSET = 148
+OSFP_HW_REV_OFFSET = 164
+OSFP_VENDOR_SN_OFFSET = 166
+
+# Offset for values in QSFP eeprom
+QSFP_DOM_REV_OFFSET = 1
+QSFP_DOM_REV_WIDTH = 1
+QSFP_TEMPE_OFFSET = 22
+QSFP_TEMPE_WIDTH = 2
+QSFP_VOLT_OFFSET = 26
+QSFP_VOLT_WIDTH = 2
+QSFP_VERSION_COMPLIANCE_OFFSET = 1
+QSFP_VERSION_COMPLIANCE_WIDTH = 2
+QSFP_CHANNL_MON_OFFSET = 34
+QSFP_CHANNL_MON_WIDTH = 16
+QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH = 24
+QSFP_CHANNL_DISABLE_STATUS_OFFSET = 86
+QSFP_CHANNL_DISABLE_STATUS_WIDTH = 1
+QSFP_CHANNL_RX_LOS_STATUS_OFFSET = 3
+QSFP_CHANNL_RX_LOS_STATUS_WIDTH = 1
+QSFP_CHANNL_TX_FAULT_STATUS_OFFSET = 4
+QSFP_CHANNL_TX_FAULT_STATUS_WIDTH = 1
+QSFP_CONTROL_OFFSET = 86
+QSFP_CONTROL_WIDTH = 8
+QSFP_MODULE_MONITOR_OFFSET = 0
+QSFP_MODULE_MONITOR_WIDTH = 9
+QSFP_POWEROVERRIDE_OFFSET = 93
+QSFP_POWEROVERRIDE_WIDTH = 1
+QSFP_POWEROVERRIDE_BIT = 0
+QSFP_POWERSET_BIT = 1
+QSFP_OPTION_VALUE_OFFSET = 192
+QSFP_OPTION_VALUE_WIDTH = 4
+QSFP_MODULE_UPPER_PAGE3_START = 384
+QSFP_MODULE_THRESHOLD_OFFSET = 128
+QSFP_MODULE_THRESHOLD_WIDTH = 24
+QSFP_CHANNL_THRESHOLD_OFFSET = 176
+QSFP_CHANNL_THRESHOLD_WIDTH = 24
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+
+qsfp_cable_length_tup = ('Length(km)', 'Length OM3(2m)',
+                         'Length OM2(m)', 'Length OM1(m)',
+                         'Length Cable Assembly(m)')
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+qsfp_compliance_code_tup = ('10/40G Ethernet Compliance Code', 'SONET Compliance codes',
+                            'SAS/SATA compliance codes', 'Gigabit Ethernet Compliant codes',
+                            'Fibre Channel link length/Transmitter Technology',
+                            'Fibre Channel transmission media', 'Fibre Channel Speed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+QSFP_TYPE = "QSFP"
+OSFP_TYPE = "OSFP"
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class Sfp(SfpBase):
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_db98cx8580_32cd-r0"
+    HWSKU = "db98cx8580_32cd"
+    _port_start = 1
+    _port_end = 257
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+        self.port_to_eeprom_mapping[index] = eeprom_path
+        sai_profile_path = self.__get_path_to_sai_profile_file()
+        cmd = "cat " + sai_profile_path  + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+        self._dom_capability_detect()
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+    
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+                cmd = "i2cset -y 0 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+                os.system(cmd)
+        else:
+                bus = smbus.SMBus(0)
+                bus.write_byte_data(device_addr, offset, value)
+
+    def __get_path_to_port_config_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "port_config.ini"])
+ 
+    def __get_path_to_sai_profile_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == COPPER_TYPE:
+            return
+
+        if self.sfp_type == "QSFP":
+            self.calibration = 1
+            sfpi_obj = sff8436InterfaceId()
+            if sfpi_obj is None:
+                self.dom_supported = False
+            offset = 128
+
+            # QSFP capability byte parse, through this byte can know whether it support tx_power or not.
+            # TODO: in the future when decided to migrate to support SFF-8636 instead of SFF-8436,
+            # need to add more code for determining the capability and version compliance
+            # in SFF-8636 dom capability definitions evolving with the versions.
+            qsfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                (offset + XCVR_DOM_CAPABILITY_OFFSET), XCVR_DOM_CAPABILITY_WIDTH)
+            if qsfp_dom_capability_raw is not None:
+                qsfp_version_compliance_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_VERSION_COMPLIANCE_OFFSET, QSFP_VERSION_COMPLIANCE_WIDTH)
+                qsfp_version_compliance = int(
+                    qsfp_version_compliance_raw[0], 16)
+                dom_capability = sfpi_obj.parse_dom_capability(
+                    qsfp_dom_capability_raw, 0)
+                if qsfp_version_compliance >= 0x08:
+                    self.dom_temp_supported = dom_capability['data']['Temp_support']['value'] == 'On'
+                    self.dom_volt_supported = dom_capability['data']['Voltage_support']['value'] == 'On'
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = dom_capability['data']['Tx_power_support']['value'] == 'On'
+                else:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = dom_capability['data']['Rx_power_support']['value'] == 'On'
+                    self.dom_tx_power_supported = True
+
+                self.dom_supported = True
+                self.calibration = 1
+                sfpd_obj = sff8436Dom()
+                if sfpd_obj is None:
+                    return None
+                qsfp_option_value_raw = self.__read_eeprom_specific_bytes(
+                    QSFP_OPTION_VALUE_OFFSET, QSFP_OPTION_VALUE_WIDTH)
+                if qsfp_option_value_raw is not None:
+                    optional_capability = sfpd_obj.parse_option_params(
+                        qsfp_option_value_raw, 0)
+                    self.dom_tx_disable_supported = optional_capability[
+                        'data']['TxDisable']['value'] == 'On'
+                dom_status_indicator = sfpd_obj.parse_dom_status_indicator(
+                    qsfp_version_compliance_raw, 1)
+                self.qsfp_page3_available = dom_status_indicator['data']['FlatMem']['value'] == 'Off'
+            else:
+                self.dom_supported = False
+                self.dom_temp_supported = False
+                self.dom_volt_supported = False
+                self.dom_rx_power_supported = False
+                self.dom_tx_power_supported = False
+                self.calibration = 0
+                self.qsfp_page3_available = False
+
+        elif self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        # ToDo: OSFP tranceiver info parsing not fully supported.
+        # in inf8628.py lack of some memory map definition
+        # will be implemented when the inf8628 memory map ready
+        if self.sfp_type == OSFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_OSFP
+
+            sfpi_obj = inf8628InterfaceId()
+            if sfpi_obj is None:
+                return None
+
+            sfp_type_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_TYPE_OFFSET), XCVR_TYPE_WIDTH)
+            if sfp_type_raw is not None:
+                sfp_type_data = sfpi_obj.parse_sfp_type(sfp_type_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_name_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_NAME_OFFSET), XCVR_VENDOR_NAME_WIDTH)
+            if sfp_vendor_name_raw is not None:
+                sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                    sfp_vendor_name_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_pn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_PN_OFFSET), XCVR_VENDOR_PN_WIDTH)
+            if sfp_vendor_pn_raw is not None:
+                sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                    sfp_vendor_pn_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_rev_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_HW_REV_OFFSET), vendor_rev_width)
+            if sfp_vendor_rev_raw is not None:
+                sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                    sfp_vendor_rev_raw, 0)
+            else:
+                return None
+
+            sfp_vendor_sn_raw = self.__read_eeprom_specific_bytes(
+                (offset + OSFP_VENDOR_SN_OFFSET), XCVR_VENDOR_SN_WIDTH)
+            if sfp_vendor_sn_raw is not None:
+                sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                    sfp_vendor_sn_raw, 0)
+            else:
+                return None
+
+            transceiver_info_dict['type'] = sfp_type_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = 'N/A'
+            transceiver_info_dict['vendor_date'] = 'N/A'
+            transceiver_info_dict['connector'] = 'N/A'
+            transceiver_info_dict['encoding'] = 'N/A'
+            transceiver_info_dict['ext_identifier'] = 'N/A'
+            transceiver_info_dict['ext_rateselect_compliance'] = 'N/A'
+            transceiver_info_dict['cable_type'] = 'N/A'
+            transceiver_info_dict['cable_length'] = 'N/A'
+            transceiver_info_dict['specification_compliance'] = 'N/A'
+            transceiver_info_dict['nominal_bit_rate'] = 'N/A'
+
+        else:
+            if self.sfp_type == QSFP_TYPE:
+                offset = 128
+                vendor_rev_width = XCVR_HW_REV_WIDTH_QSFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_QSFP
+
+                sfpi_obj = sff8436InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+
+            else:
+                offset = 0
+                vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+                interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+                sfpi_obj = sff8472InterfaceId()
+                if sfpi_obj is None:
+                    print("Error: sfp_object open failed")
+                    return None
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+            transceiver_info_dict['type'] = sfp_interface_bulk_data['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data[
+                'data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data['data']['RateIdentifier']['value']
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+            if self.sfp_type == QSFP_TYPE:
+                for key in qsfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in qsfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['Nominal Bit Rate(100Mbs)']['value'])
+            else:
+                for key in sfp_cable_length_tup:
+                    if key in sfp_interface_bulk_data['data']:
+                        transceiver_info_dict['cable_type'] = key
+                        transceiver_info_dict['cable_length'] = str(
+                            sfp_interface_bulk_data['data'][key]['value'])
+
+                for key in sfp_compliance_code_tup:
+                    if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                        compliance_code_dict[key] = sfp_interface_bulk_data['data']['Specification compliance']['value'][key]['value']
+                transceiver_info_dict['specification_compliance'] = str(
+                    compliance_code_dict)
+
+                transceiver_info_dict['nominal_bit_rate'] = str(
+                    sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 0
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_DOM_BULK_DATA_START), QSFP_DOM_BULK_DATA_SIZE)
+
+            if dom_data_raw is None:
+                return transceiver_dom_info_dict
+
+            if self.dom_temp_supported:
+                start = QSFP_TEMPE_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_TEMPE_WIDTH
+                dom_temperature_data = sfpd_obj.parse_temperature(
+                    dom_data_raw[start: end], 0)
+                temp = self.__convert_string_to_num(
+                    dom_temperature_data['data']['Temperature']['value'])
+                if temp is not None:
+                    transceiver_dom_info_dict['temperature'] = temp
+
+            if self.dom_volt_supported:
+                start = QSFP_VOLT_OFFSET - QSFP_DOM_BULK_DATA_START
+                end = start + QSFP_VOLT_WIDTH
+                dom_voltage_data = sfpd_obj.parse_voltage(
+                    dom_data_raw[start: end], 0)
+                volt = self.__convert_string_to_num(
+                    dom_voltage_data['data']['Vcc']['value'])
+                if volt is not None:
+                    transceiver_dom_info_dict['voltage'] = volt
+
+            start = QSFP_CHANNL_MON_OFFSET - QSFP_DOM_BULK_DATA_START
+            end = start + QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                dom_data_raw[start: end], 0)
+
+            if self.dom_tx_power_supported:
+                transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX1Power']['value'])
+                transceiver_dom_info_dict['tx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX2Power']['value'])
+                transceiver_dom_info_dict['tx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX3Power']['value'])
+                transceiver_dom_info_dict['tx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['TX4Power']['value'])
+
+            if self.dom_rx_power_supported:
+                transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX1Power']['value'])
+                transceiver_dom_info_dict['rx2power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX2Power']['value'])
+                transceiver_dom_info_dict['rx3power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX3Power']['value'])
+                transceiver_dom_info_dict['rx4power'] = self.__convert_string_to_num(
+                    dom_channel_monitor_data['data']['RX4Power']['value'])
+
+            transceiver_dom_info_dict['tx1bias'] = dom_channel_monitor_data['data']['TX1Bias']['value']
+            transceiver_dom_info_dict['tx2bias'] = dom_channel_monitor_data['data']['TX2Bias']['value']
+            transceiver_dom_info_dict['tx3bias'] = dom_channel_monitor_data['data']['TX3Bias']['value']
+            transceiver_dom_info_dict['tx4bias'] = dom_channel_monitor_data['data']['TX4Bias']['value']
+
+        else:
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == OSFP_TYPE:
+            pass
+
+        elif self.sfp_type == QSFP_TYPE:
+            if not self.dom_supported or not self.qsfp_page3_available:
+                return transceiver_dom_threshold_info_dict
+
+            # Dom Threshold data starts from offset 384
+            # Revert offset back to 0 once data is retrieved
+            offset = QSFP_MODULE_UPPER_PAGE3_START
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_THRESHOLD_OFFSET), QSFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_data = sfpd_obj.parse_module_threshold_values(
+                dom_module_threshold_raw, 0)
+
+            dom_channel_threshold_raw = self.__read_eeprom_specific_bytes((offset + QSFP_CHANNL_THRESHOLD_OFFSET),
+                                                                          QSFP_CHANNL_THRESHOLD_WIDTH)
+            if dom_channel_threshold_raw is None:
+                return transceiver_dom_threshold_info_dict
+            dom_channel_threshold_data = sfpd_obj.parse_channel_threshold_values(
+                dom_channel_threshold_raw, 0)
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VccHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data['data']['VccHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VccLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VccLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_channel_threshold_data['data']['RxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_channel_threshold_data['data']['RxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_channel_threshold_data['data']['RxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_channel_threshold_data['data']['RxPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_channel_threshold_data['data']['TxBiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_channel_threshold_data['data']['TxBiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_channel_threshold_data['data']['TxBiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_channel_threshold_data['data']['TxBiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_channel_threshold_data['data']['TxPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_channel_threshold_data['data']['TxPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_channel_threshold_data['data']['TxPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_channel_threshold_data['data']['TxPowerLowWarning']['value']
+
+        else:
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == OSFP_TYPE:
+            return False
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+            dom_module_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + QSFP_MODULE_MONITOR_OFFSET), QSFP_MODULE_MONITOR_WIDTH)
+
+            if dom_module_monitor_raw is not None:
+                return True
+            else:
+                return False
+        elif self.sfp_type == SFP_TYPE:
+            offset = 0
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        return False
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        return False
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+        return False
+ 
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == QSFP_TYPE:
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return False
+
+            dom_control_raw = self.__read_eeprom_specific_bytes(
+                QSFP_CONTROL_OFFSET, QSFP_CONTROL_WIDTH) if self.get_presence() else None
+            if dom_control_raw is not None:
+                dom_control_data = sfpd_obj.parse_control_bytes(
+                    dom_control_raw, 0)
+                return ('On' == dom_control_data['data']['PowerOverride']['value'])
+        else:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+            A list of four integer numbers, representing TX bias in mA
+            for channel 0 to channel 4.
+            Ex. ['110.09', '111.12', '108.21', '112.09']
+        """
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx1_bs = transceiver_bulk_status.get("tx1bias", "N/A")
+        tx2_bs = transceiver_bulk_status.get("tx2bias", "N/A")
+        tx3_bs = transceiver_bulk_status.get("tx3bias", "N/A")
+        tx4_bs = transceiver_bulk_status.get("tx4bias", "N/A")
+        tx_bias_list = [tx1_bs, tx2_bs, tx3_bs, tx4_bs]
+        return tx_bias_list
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_rx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX1Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX2Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX3Power']['value']))
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == OSFP_TYPE:
+            # OSFP not supported on our platform yet.
+            return None
+
+        elif self.sfp_type == QSFP_TYPE:
+            offset = 0
+
+            sfpd_obj = sff8436Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_tx_power_supported:
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + QSFP_CHANNL_MON_OFFSET), QSFP_CHANNL_MON_WITH_TX_POWER_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params_with_tx_power(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX1Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX2Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX3Power']['value']))
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TX4Power']['value']))
+                else:
+                    return None
+            else:
+                return None
+        else:
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP and return all user module settings to their default srate.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        # Check for invalid port_num
+        if self.port_num < self._port_start or self.port_num > self._port_end:
+            return False
+        port_ps = "/sys/bus/i2c/devices/0-0050/sfp_port_reset"
+        try:
+            reg_file = open(port_ps, 'w')
+        except IOError as e:
+            print(e)
+            return False
+
+        #toggle reset
+        reg_file.seek(0)
+        reg_file.write('1')
+        time.sleep(1)
+        reg_file.seek(0)
+        reg_file.write('0')
+        reg_file.close()
+        return True
+
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX for all channels
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                tx_disable_ctl = 0xf if tx_disable else 0x0
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            sysfsfile_eeprom = None
+            try:
+                channel_state = self.get_tx_disable_channel()
+                tx_enable_mask = [0xe, 0xd, 0xb, 0x7]
+                tx_disable_mask = [0x1, 0x3, 0x7, 0xf]
+                tx_disable_ctl = channel_state | tx_disable_mask[
+                    channel] if disable else channel_state & tx_enable_mask[channel]
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(tx_disable_ctl)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_CONTROL_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+        if self.sfp_type == QSFP_TYPE:
+            try:
+                power_override_bit = 0
+                if power_override:
+                    power_override_bit |= 1 << 0
+
+                power_set_bit = 0
+                if power_set:
+                    power_set_bit |= 1 << 1
+
+                buffer = create_string_buffer(1)
+                buffer[0] = chr(power_override_bit | power_set_bit)
+                # Write to eeprom
+                sysfsfile_eeprom = open(
+                    self.port_to_eeprom_mapping[self.port_num], "r+b")
+                sysfsfile_eeprom.seek(QSFP_POWEROVERRIDE_OFFSET)
+                sysfsfile_eeprom.write(buffer[0])
+            except IOError as e:
+                print("Error: unable to open file: %s" % str(e))
+                return False
+            finally:
+                if sysfsfile_eeprom is not None:
+                    sysfsfile_eeprom.close()
+                    time.sleep(0.01)
+            return True
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+        self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        port_index = self.port_num-1
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+        profile = sfputil_profiles[self._port_profile]
+        if  port_index not in profile:
+            return False
+        else:
+            offset = int(profile[port_index].split(",")[1])
+            bin_offset = 1<<offset
+            device_reg = int(profile[port_index].split(",")[0],16)
+            self.i2c_set(device_reg, 0, bin_offset)
+            try:
+                reg_file = open(sysfs_sfp_i2c_client_eeprom_path, 'rb')
+                reg_file.seek(1)
+                reg_file.read(2)
+            except IOError as e:
+                return False
+
+            return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..1c5ef1759
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/sfp_event.py
@@ -0,0 +1,213 @@
+#!/usr/bin/env python
+'''
+listen to the SDK for the SFP change event and return to chassis.
+'''
+
+from __future__ import print_function
+import os
+import time
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+profile_12_8_db = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4",   4:"0x70,4",   5:"0x70,4",   6:"0x70,4",   7:"0x70,4",
+  8:"0x70,5",   9:"0x70,5",  10:"0x70,5",  11:"0x70,5",  12:"0x70,5",  13:"0x70,5",  14:"0x70,5",  15:"0x70,5",
+ 16:"0x70,6",  17:"0x70,6",  18:"0x70,6",  19:"0x70,6",  20:"0x70,6",  21:"0x70,6",  22:"0x70,6",  23:"0x70,6",
+ 24:"0x70,7",  25:"0x70,7",  26:"0x70,7",  27:"0x70,7",  28:"0x70,7",  29:"0x70,7",  30:"0x70,7",  31:"0x70,7",
+ 32:"0x70,0",  33:"0x70,0",  34:"0x70,0",  35:"0x70,0",  36:"0x70,0",  37:"0x70,0",  38:"0x70,0",  39:"0x70,0",
+ 40:"0x70,1",  41:"0x70,1",  42:"0x70,1",  43:"0x70,1",  44:"0x70,1",  45:"0x70,1",  46:"0x70,1",  47:"0x70,1",
+ 48:"0x70,2",  49:"0x70,2",  50:"0x70,2",  51:"0x70,2",  52:"0x70,2",  53:"0x70,2",  54:"0x70,2",  55:"0x70,2",
+ 56:"0x70,3",  57:"0x70,3",  58:"0x70,3",  59:"0x70,3",  60:"0x70,3",  61:"0x70,3",  62:"0x70,3",  63:"0x70,3",
+ 64:"0x71,4",  65:"0x71,4",  66:"0x71,4",  67:"0x71,4",  68:"0x71,4",  69:"0x71,4",  70:"0x71,4",  71:"0x71,4",
+ 72:"0x71,5",  73:"0x71,5",  74:"0x71,5",  75:"0x71,5",  76:"0x71,5",  77:"0x71,5",  78:"0x71,5",  79:"0x71,5",
+ 80:"0x71,6",  81:"0x71,6",  82:"0x71,6",  83:"0x71,6",  84:"0x71,6",  85:"0x71,6",  86:"0x71,6",  87:"0x71,6",
+ 88:"0x71,7",  89:"0x71,7",  90:"0x71,7",  91:"0x71,7",  92:"0x71,7",  93:"0x71,7",  94:"0x71,7",  95:"0x71,7",
+ 96:"0x71,0",  97:"0x71,0",  98:"0x71,0",  99:"0x71,0", 100:"0x71,1", 101:"0x71,1", 102:"0x71,1", 103:"0x71,1",
+104:"0x71,2", 105:"0x71,2", 106:"0x71,2", 107:"0x71,2", 108:"0x71,3", 109:"0x71,3", 110:"0x71,3", 111:"0x71,3",
+112:"0x72,4", 113:"0x72,4", 114:"0x72,5", 115:"0x72,5", 116:"0x72,6", 117:"0x72,6", 118:"0x72,7", 119:"0x71,7",
+120:"0x72,0", 121:"0x72,0", 122:"0x72,1", 123:"0x72,1", 124:"0x72,2", 125:"0x72,2", 126:"0x72,3", 127:"0x72,3",
+128:"0x73,4", 129:"0x73,5", 130:"0x73,6", 131:"0x73,7", 132:"0x73,0", 133:"0x73,1", 134:"0x73,2", 135:"0x73,3",
+136:"0x74,4" }
+
+profile_32x25G = {
+ 0:"0x70,4",   1:"0x70,5",   2:"0x70,6",   3:"0x70,7",   4:"0x70,0",   5:"0x70,1",   6:"0x70,2",   7:"0x70,3",
+ 8:"0x71,4",   9:"0x71,5",  10:"0x71,6",  11:"0x71,7",  12:"0x71,0",  13:"0x71,1",  14:"0x71,2",  15:"0x71,3",
+16:"0x72,4",  17:"0x72,5",  18:"0x72,6",  19:"0x72,7",  20:"0x72,0",  21:"0x72,1",  22:"0x72,2",  23:"0x72,3",
+24:"0x73,4",  25:"0x73,5",  26:"0x73,6",  27:"0x73,7",  28:"0x73,0",  29:"0x73,1",  30:"0x73,2",  31:"0x73,3",
+32:"0x74,4" }
+
+profile_48x25G_8x100G = {
+  0:"0x70,4",   1:"0x70,4",   2:"0x70,4",   3:"0x70,4", 4:"0x70,5",   5:"0x70,5",   6:"0x70,5",   7:"0x70,5",
+  8:"0x70,6",   9:"0x70,6",  10:"0x70,6",  11:"0x70,6",  12:"0x70,7",  13:"0x70,7",  14:"0x70,7",  15:"0x70,7",
+ 16:"0x70,0",  17:"0x70,0",  18:"0x70,0",  19:"0x70,0",  20:"0x70,1",  21:"0x70,1",  22:"0x70,1",  23:"0x70,1",
+ 24:"0x70,2",  25:"0x70,2",  26:"0x70,2",  27:"0x70,2",  28:"0x70,3",  29:"0x70,3",  30:"0x70,3",  31:"0x70,3",
+ 32:"0x71,4",  33:"0x71,4",  34:"0x71,4",  35:"0x71,4",  36:"0x71,5",  37:"0x71,5",  38:"0x71,5",  39:"0x71,5",
+ 40:"0x71,6",  41:"0x71,6",  42:"0x71,6",  43:"0x71,6",  44:"0x71,7",  45:"0x71,7",  46:"0x71,7",  47:"0x71,7",
+ 48:"0x71,0",  49:"0x71,1",  50:"0x71,2",  51:"0x71,3",  52:"0x72,4",  53:"0x72,5",  54:"0x72,6",  55:"0x72,7",
+ 56:"0x74,4" }
+
+sfputil_profiles = {
+ "FC12_8T-DB":profile_12_8_db,
+ "FC48x25G8x100GR4":profile_48x25G_8x100G,
+ "FALCON32X25G":profile_32x25G
+}
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+HOST_CHK_CMD = "docker > /dev/null 2>&1"
+PLATFORM = "arm64-marvell_db98cx8580_32cd-r0"
+HWSKU = "db98cx8580_32cd"
+
+# SFP PORT numbers
+SFP_PORT_START = 1
+SFP_PORT_END = 257
+
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+
+    def __init__(self):
+        
+        self.handle = None
+        self.port_to_eeprom_mapping = {}
+        self.SFP_PORT_START=SFP_PORT_START
+        self.SFP_PORT_END=SFP_PORT_END
+        self.PLATFORM_ROOT_PATH=PLATFORM_ROOT_PATH
+        self.PLATFORM=PLATFORM
+        self.PMON_HWSKU_PATH=PMON_HWSKU_PATH
+        self.HOST_CHK_CMD = HOST_CHK_CMD
+        self.HWSKU = HWSKU
+
+        eeprom_path="/sys/bus/i2c/devices/0-0050/eeprom"
+
+        x = self.SFP_PORT_START
+        while(x<self.SFP_PORT_END+1):
+            self.port_to_eeprom_mapping[x] = eeprom_path
+            x = x + 1
+        path=self.__get_path_to_sai_file()
+        cmd = "cat " + path + " | grep hwId | cut -f2 -d="
+        port_profile = os.popen(cmd).read()
+        self._port_profile = port_profile.split("\n")[0]
+ 
+    def initialize(self):       
+        self.modprs_register = 0 
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def i2c_set(self, device_addr, offset, value):
+        if smbus_present == 0:
+            cmd = "i2cset -y 0 " + hex(device_addr) + " " + hex(offset) + " " + hex(value)
+            os.system(cmd)
+        else:
+            bus = smbus.SMBus(0)
+            bus.write_byte_data(device_addr, offset, value)
+      
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+        sfp_status = 0
+        x = 0
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+                port_index = index-1
+                profile = sfputil_profiles[self._port_profile]
+                if  port_index in profile:
+                        offset = int(profile[port_index].split(",")[1])
+                        bin_offset = 1<<offset
+                        device_reg = int(profile[port_index].split(",")[0],16)
+                        self.i2c_set(device_reg, 0, bin_offset)
+                        path = "/sys/bus/i2c/devices/0-0050/eeprom"
+                        try:
+                                reg_file = open(path, 'rb')
+                                reg_file.seek(1)
+                                reg_file.read(2)
+                                sfp_status=( x | (1<<index-self.SFP_PORT_START)) + sfp_status
+                        except IOError as e:
+                                sfp_status=( x & ~(1<<index-self.SFP_PORT_START)) + sfp_status
+
+        sfp_status = ~sfp_status
+        return sfp_status
+
+    def __get_path_to_sai_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "sai.profile"])
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+         check_sfp_status called from get_change_event,
+            this will return correct status of all 4 SFP ports if there is a change in any of them 
+        """
+    
+        start_time = time.time()
+        port = self.SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000) # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {} # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= self.SFP_PORT_START and port <=self.SFP_PORT_END):
+                    profile = sfputil_profiles[self._port_profile]
+                    port_index = port - 1 
+                    if  port_index in profile:
+                        # Mask off the bit corresponding to our port
+                        mask = (1 << port-SFP_PORT_START)
+                        if (changed_ports & mask):
+                                # ModPrsL is active high
+                                if reg_value & mask == 0:
+                                     port_change[port] = '1'
+                                else:
+                                     port_change[port] = '0'
+                    port += 1
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1) # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py
new file mode 100644
index 000000000..8c8541ea0
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/sonic_platform/watchdog.py
@@ -0,0 +1,133 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/db98cx8580/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/changelog b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/changelog
new file mode 100644
index 000000000..ce7b14905
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/changelog
@@ -0,0 +1,4 @@
+sonic-platform-db98cx8580-32cd-db98cx8580 (1.0) unstable; urgency=low
+
+  * Add support for sonic-platform-db98cx8580-32cd
+ -- Marvell Wed, 15 Apr 2020 09:35:58 +0800
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/compat b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/control b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/control
new file mode 100644
index 000000000..f492af1fa
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-db98cx8580-32cd-db98cx8580
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-db98cx8580-32cd-db98cx8580
+Architecture: arm64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/rules b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/rules
new file mode 100755
index 000000000..931db35f0
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/rules
@@ -0,0 +1,65 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-db98cx8580-32cd
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= db98cx8580 
+UTILS_DIR := utils
+SERVICE_DIR := service
+PLATFORM_DIR := sonic_platform
+
+%:
+	dh $@ --with systemd,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME)-$${mod} /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)-$${mod}/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)-$${mod}/usr/local/bin/; \
+		python2 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME)-$${mod} --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install
new file mode 100644
index 000000000..1e9d2c9ef
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.install
@@ -0,0 +1,5 @@
+db98cx8580/scripts/db98cx8580-32cd_plt_setup.sh usr/local/bin
+db98cx8580/scripts/db98cx8580-32cd-init.sh  usr/local/bin
+db98cx8580/service/db98cx8580-32cd-init.service etc/systemd/system
+db98cx8580/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-marvell_db98cx8580_32cd-r0
+
diff --git a/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst
new file mode 100644
index 000000000..feaad8d76
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-db98cx8580-32cd/debian/sonic-platform-db98cx8580-32cd-db98cx8580.postinst
@@ -0,0 +1,10 @@
+#!/bin/sh
+# postinst script for sonic-platform-db98cx8580-32cd
+#
+# see: dh_installdeb(1)
+
+sh /usr/local/bin/db98cx8580-32cd_plt_setup.sh
+chmod a+x /usr/local/bin/db98cx8580-32cd-init.sh
+systemctl enable db98cx8580-32cd-init.service
+exit 0
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/changelog b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/changelog
new file mode 100644
index 000000000..7d298cf77
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/changelog
@@ -0,0 +1,5 @@
+sonic-platform-rd98dx35xx (1.0) unstable; urgency=low
+
+  * Add support for rd98dx35xx.
+
+ -- Marvell <pnaregundi@marvell.com>  Mon, 30 Nov 2021 09:35:58 +0800
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/compat b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/control b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/control
new file mode 100644
index 000000000..b6ab54d3b
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-rd98dx35xx
+Section: unknown
+Priority: optional
+Maintainer: Marvell <pnaregundi@marvell.com>
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-rd98dx35xx
+Architecture: arm64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/install b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/install
new file mode 100644
index 000000000..ec352c93e
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/install
@@ -0,0 +1,4 @@
+rd98dx35xx/scripts/rd98dx35xx_plt_setup.sh usr/local/bin
+rd98dx35xx/scripts/rd98dx35xx-init.sh usr/local/bin
+rd98dx35xx/service/rd98dx35xx-init.service etc/systemd/system
+rd98dx35xx/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-marvell_rd98DX35xx-r0
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/postinst b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/postinst
new file mode 100644
index 000000000..d3e2f92b3
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/postinst
@@ -0,0 +1,43 @@
+#!/bin/sh
+# postinst script for sonic-platform-rd98dx35xx
+#
+# see: dh_installdeb(1)
+
+set -e
+
+# summary of how this script can be called:
+#        * <postinst> `configure' <most-recently-configured-version>
+#        * <old-postinst> `abort-upgrade' <new version>
+#        * <conflictor's-postinst> `abort-remove' `in-favour' <package>
+#          <new-version>
+#        * <postinst> `abort-remove'
+#        * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
+#          <failed-install-package> <version> `removing'
+#          <conflicting-package> <version>
+# for details, see https://www.debian.org/doc/debian-policy/ or
+# the debian-policy package
+
+
+case "$1" in
+    configure)
+	sh /usr/local/bin/rd98dx35xx_plt_setup.sh
+	chmod a+x /usr/local/bin/rd98dx35xx-init.sh
+	systemctl enable rd98dx35xx-init.service
+
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# dh_installdeb will replace this with shell code automatically
+# generated by other debhelper scripts.
+
+#DEBHELPER#
+
+exit 0
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/rules b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/rules
new file mode 100755
index 000000000..5f27b471c
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/debian/rules
@@ -0,0 +1,62 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-rd98dx35xx
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= rd98dx35xx
+UTILS_DIR := utils
+SERVICE_DIR := service
+
+%:
+	dh $@ --with systemd,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+                python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+        done)	
+
+binary: binary-arch binary-indep
+       # Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME) /usr/local/bin; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)/usr/local/bin/; \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME) --install-layout=deb; \
+	done)
+
+# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx-init.sh b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx-init.sh
new file mode 100644
index 000000000..6371cc1e8
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx-init.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+
+# Platform init script
+
+rd98DX35xx_profile()
+{
+	MAC_ADDR=$(fw_printenv -n ethaddr)
+	find /usr/share/sonic/device/*rd98DX35xx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+	echo "rd98DX35xx: Updating switch mac address ${MAC_ADDR}"
+}
+
+# Main
+rd98DX35xx_profile
+
+# LOGIC to enumerate SFP eeprom devices - send 0x50 to kernel i2c driver - initialize devices
+# the mux may be enumerated at number 4 or 5 so we check for the mux and skip if needed
+# Get list of the mux channels
+# Enumerate the SFP eeprom device on each mux channel
+echo optoe2 0x50 > /sys/bus/i2c/devices/i2c-0/new_device
+# Enumerate system eeprom
+echo 24c64 0x52 > /sys/class/i2c-adapter/i2c-0/new_device
+sleep 2
+chmod 644 /sys/class/i2c-adapter/i2c-0/0-0052/eeprom
+
+exit 0
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx_plt_setup.sh b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx_plt_setup.sh
new file mode 100644
index 000000000..e59a38bed
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/scripts/rd98dx35xx_plt_setup.sh
@@ -0,0 +1,46 @@
+#!/bin/bash
+
+PLATFORM_AC5X="arm64-marvell_rd98DX35xx-r0"
+MACH_FILE="/host/machine.conf"
+
+fw_uboot_env_cfg()
+{
+    echo "Setting up U-Boot environment..."
+
+    FW_ENV_DEFAULT='/dev/mtd0 0x400000 0x10000 0x10000'
+    echo $FW_ENV_DEFAULT > /etc/fw_env.config
+}
+
+rd98DX35xx_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*rd98DX35xx* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "rd98DX35xx: Updating switch mac address ${MAC_ADDR}"
+}
+
+update_modulelist()
+{
+    MODULE_FILE="/etc/modules-load.d/marvell.conf"
+
+    if grep -Fxq "mvMbusDrv" $MODULE_FILE
+    then
+        echo "Module list up to date"
+    else
+        echo "mvMbusDrv" >> $MODULE_FILE
+        modprobe mvMbusDrv
+    fi
+}
+
+main()
+{
+    if [ -f "$MACH_FILE" ]; then
+        PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
+        if [ "$PLATFORM" = "$PLATFORM_AC5X" ]; then
+            fw_uboot_env_cfg
+            rd98DX35xx_profile
+            update_modulelist
+        fi
+    fi
+}
+
+main $@
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/service/rd98dx35xx-init.service b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/service/rd98dx35xx-init.service
new file mode 100644
index 000000000..0d43c7e2e
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/service/rd98dx35xx-init.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=Platform rd98DX35xx Service
+After=rc-local.service
+Before=getty.target
+
+[Service]
+ExecStart=/usr/local/bin/rd98dx35xx-init.sh
+StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/setup.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/setup.py
new file mode 100644
index 000000000..e6fe69d44
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'rd98dx35xx/sonic_platform'},
+)
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/__init__.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/chassis.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/chassis.py
new file mode 100644
index 000000000..3c1ee8b08
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/chassis.py
@@ -0,0 +1,265 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 1
+COPPER_PORT_END = 48
+SFP_PORT_START =49 
+SFP_PORT_END = 54 
+PORT_END = 54
+MAX_COMPONENT=2
+
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_rd98DX35xx-r0"
+    HWSKU = "rd98DX35xx"
+
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        # Port numbers for Initialize SFP list
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        eeprom_path = '/sys/bus/i2c/devices/0-0050/eeprom'
+
+        # for non-sfp ports create dummy objects for copper / non-sfp ports
+        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
+            port=index-1
+            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
+            self._sfp_list.append(sfp_node)
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            sfp_node = Sfp(index, 'SFP', port_eeprom_path, i2cdev )
+            self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+             component = Component(i)
+             self._component_list.append(component)
+
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        #lrr = self._get_cpld_register('mb_reboot_cause')
+        #if (lrr != 'ERR'):
+        #    reset_reason = lrr
+        #    if (reset_reason in self.reset_reason_dict):
+        #        return (self.reset_reason_dict[reset_reason], None)
+        #
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/component.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/component.py
new file mode 100644
index 000000000..16e01486d
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/component.py
@@ -0,0 +1,94 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["U-Boot", "Performs initialization during booting"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+
+        if self.index == 0:
+            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data ^U-Boot /dev/mtd0ro | cut -d" " -f2')
+            return uboot_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/eeprom.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/eeprom.py
new file mode 100644
index 000000000..f43a84a87
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/eeprom.py
@@ -0,0 +1,182 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+# - PSU EEPROM : Contains Serial number, Part number, Service Tag,
+#                PSU type, Revision.
+# - Fan EEPROM : Contains Serial number, Part number, Service Tag,
+#                Fan type, Number of Fans in Fantray, Revision.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+# PSU eeprom fields in format required by EepromDecoder
+psu_eeprom_format = [
+    ('PPID', 's', 20), ('DPN Rev', 's', 3), ('Service Tag', 's', 7),
+    ('Part Number', 's', 10), ('Part Num Revision', 's', 3),
+    ('Mfg Test', 's', 2), ('Redundant copy', 's', 83), ('PSU Type', 's', 1),
+    ('Fab Rev', 's', 2)
+    ]
+
+# Fan eeprom fields in format required by EepromDecoder
+fan_eeprom_format = [
+    ('Model', 's', 12), ('Serial Number', 's', 13)
+    ]
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0052/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            print ("No other eeprom")
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        if self.is_fan_eeprom:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/platform.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp.py
new file mode 100644
index 000000000..f94583723
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp.py
@@ -0,0 +1,968 @@
+import os
+import sys
+
+try:
+    from sonic_platform_base.sfp_base import SfpBase
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472InterfaceId
+    from sonic_platform_base.sonic_sfp.sff8472 import sff8472Dom
+    from sonic_platform_base.sonic_sfp.sfputilhelper import SfpUtilHelper
+    from sonic_py_common import logger
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+
+INFO_OFFSET = 128
+DOM_OFFSET = 0
+
+# definitions of the offset and width for values in XCVR info eeprom
+XCVR_INTFACE_BULK_OFFSET = 0
+
+XCVR_INTFACE_BULK_WIDTH_SFP = 21
+XCVR_TYPE_OFFSET = 0
+XCVR_TYPE_WIDTH = 1
+XCVR_EXT_TYPE_OFFSET = 1
+XCVR_EXT_TYPE_WIDTH = 1
+XCVR_CONNECTOR_OFFSET = 2
+XCVR_CONNECTOR_WIDTH = 1
+XCVR_COMPLIANCE_CODE_OFFSET = 3
+XCVR_COMPLIANCE_CODE_WIDTH = 8
+XCVR_ENCODING_OFFSET = 11
+XCVR_ENCODING_WIDTH = 1
+XCVR_NBR_OFFSET = 12
+XCVR_NBR_WIDTH = 1
+XCVR_EXT_RATE_SEL_OFFSET = 13
+XCVR_EXT_RATE_SEL_WIDTH = 1
+XCVR_CABLE_LENGTH_OFFSET = 14
+
+XCVR_CABLE_LENGTH_WIDTH_SFP = 6
+XCVR_VENDOR_NAME_OFFSET = 20
+XCVR_VENDOR_NAME_WIDTH = 16
+XCVR_VENDOR_OUI_OFFSET = 37
+XCVR_VENDOR_OUI_WIDTH = 3
+XCVR_VENDOR_PN_OFFSET = 40
+XCVR_VENDOR_PN_WIDTH = 16
+XCVR_HW_REV_OFFSET = 56
+
+XCVR_HW_REV_WIDTH_SFP = 4
+XCVR_VENDOR_SN_OFFSET = 68
+XCVR_VENDOR_SN_WIDTH = 16
+XCVR_VENDOR_DATE_OFFSET = 84
+XCVR_VENDOR_DATE_WIDTH = 8
+XCVR_DOM_CAPABILITY_OFFSET = 92
+XCVR_DOM_CAPABILITY_WIDTH = 2
+XCVR_INTERFACE_DATA_START = 0
+XCVR_INTERFACE_DATA_SIZE = 92
+
+SFP_DOM_BULK_DATA_START = 96
+SFP_DOM_BULK_DATA_SIZE = 10
+
+SFP_MODULE_ADDRA2_OFFSET = 256
+SFP_MODULE_THRESHOLD_OFFSET = 0
+SFP_MODULE_THRESHOLD_WIDTH = 56
+SFP_CHANNL_THRESHOLD_OFFSET = 112
+SFP_CHANNL_THRESHOLD_WIDTH = 2
+
+SFP_TEMPE_OFFSET = 96
+SFP_TEMPE_WIDTH = 2
+SFP_VOLT_OFFSET = 98
+SFP_VOLT_WIDTH = 2
+SFP_CHANNL_MON_OFFSET = 100
+SFP_CHANNL_MON_WIDTH = 6
+SFP_CHANNL_STATUS_OFFSET = 110
+SFP_CHANNL_STATUS_WIDTH = 1
+
+sfp_cable_length_tup = ('LengthSMFkm-UnitsOfKm', 'LengthSMF(UnitsOf100m)',
+                        'Length50um(UnitsOf10m)', 'Length62.5um(UnitsOfm)',
+                        'LengthCable(UnitsOfm)', 'LengthOM3(UnitsOf10m)')
+
+sfp_compliance_code_tup = ('10GEthernetComplianceCode', 'InfinibandComplianceCode',
+                           'ESCONComplianceCodes', 'SONETComplianceCodes',
+                           'EthernetComplianceCodes', 'FibreChannelLinkLength',
+                           'FibreChannelTechnology', 'SFP+CableTechnology',
+                           'FibreChannelTransmissionMedia', 'FibreChannelSpeed')
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 54
+
+SYSLOG_IDENTIFIER = "xcvrd"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class Sfp(SfpBase):
+    """Platform-specific Sfp class"""
+
+    # Paths
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+
+    PLATFORM = "arm64-marvell_rd98DX35xx-r0"
+    HWSKU = "rd98DX35xx"
+
+    port_to_i2c_mapping = 0
+
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpBase.__init__(self)
+
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+
+        self.port_to_eeprom_mapping[index] = eeprom_path
+
+        self.info_dict_keys = ['type', 'hardware_rev', 'serial', 'manufacturer',
+                               'model', 'connector', 'encoding', 'ext_identifier',
+                               'ext_rateselect_compliance', 'cable_type', 'cable_length',
+                               'nominal_bit_rate', 'specification_compliance',
+                               'type_abbrv_name', 'vendor_date', 'vendor_oui']
+
+        self.dom_dict_keys = ['rx_los', 'tx_fault', 'reset_status', 'power_lpmode',
+                              'tx_disable', 'tx_disable_channel', 'temperature',
+                              'voltage', 'rx1power', 'rx2power', 'rx3power',
+                              'rx4power', 'tx1bias', 'tx2bias', 'tx3bias', 'tx4bias',
+                              'tx1power', 'tx2power', 'tx3power', 'tx4power']
+
+        self.threshold_dict_keys = ['temphighalarm', 'temphighwarning', 'templowalarm',
+                                    'templowwarning', 'vcchighalarm', 'vcchighwarning',
+                                    'vcclowalarm', 'vcclowwarning', 'rxpowerhighalarm',
+                                    'rxpowerhighwarning', 'rxpowerlowalarm', 'rxpowerlowwarning',
+                                    'txpowerhighalarm', 'txpowerhighwarning', 'txpowerlowalarm',
+                                    'txpowerlowwarning', 'txbiashighalarm', 'txbiashighwarning',
+                                    'txbiaslowalarm', 'txbiaslowwarning']
+
+        self.dom_supported = False
+        self.dom_temp_supported = False
+        self.dom_volt_supported = False
+        self.dom_rx_power_supported = False
+        self.dom_tx_power_supported = False
+        self.calibration = 0
+
+    def __convert_string_to_num(self, value_str):
+        if "-inf" in value_str:
+            return 'N/A'
+        elif "Unknown" in value_str:
+            return 'N/A'
+        elif 'dBm' in value_str:
+            t_str = value_str.rstrip('dBm')
+            return float(t_str)
+        elif 'mA' in value_str:
+            t_str = value_str.rstrip('mA')
+            return float(t_str)
+        elif 'C' in value_str:
+            t_str = value_str.rstrip('C')
+            return float(t_str)
+        elif 'Volts' in value_str:
+            t_str = value_str.rstrip('Volts')
+            return float(t_str)
+        else:
+            return 'N/A'
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def __get_path_to_port_config_file(self):
+        platform_path = "/".join([self.PLATFORM_ROOT_PATH, self.PLATFORM])
+        hwsku_path = "/".join([platform_path, self.HWSKU]
+                              ) if self.__is_host() else self.PMON_HWSKU_PATH
+        return "/".join([hwsku_path, "port_config.ini"])
+
+    def __read_eeprom_specific_bytes(self, offset, num_bytes):
+        sysfsfile_eeprom = None
+
+        eeprom_raw = []
+        for i in range(0, num_bytes):
+            eeprom_raw.append("0x00")
+
+        sysfs_sfp_i2c_client_eeprom_path = self.port_to_eeprom_mapping[self.port_num]
+
+        try:
+            sysfsfile_eeprom = open(
+                sysfs_sfp_i2c_client_eeprom_path, mode="rb", buffering=0)
+            sysfsfile_eeprom.seek(offset)
+            raw = sysfsfile_eeprom.read(num_bytes)
+            for n in range(0, num_bytes):
+                eeprom_raw[n] = hex(raw[n])[2:].zfill(2)
+        except Exception as e:
+            pass
+        finally:
+            if sysfsfile_eeprom:
+                sysfsfile_eeprom.close()
+        return eeprom_raw
+
+    def _dom_capability_detect(self):
+        if self.sfp_type == "SFP":
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                return None
+            sfp_dom_capability_raw = self.__read_eeprom_specific_bytes(
+                XCVR_DOM_CAPABILITY_OFFSET, XCVR_DOM_CAPABILITY_WIDTH)
+            if sfp_dom_capability_raw is not None:
+                sfp_dom_capability = int(sfp_dom_capability_raw[0], 16)
+                self.dom_supported = (sfp_dom_capability & 0x40 != 0)
+                if self.dom_supported:
+                    self.dom_temp_supported = True
+                    self.dom_volt_supported = True
+                    self.dom_rx_power_supported = True
+                    self.dom_tx_power_supported = True
+                    if sfp_dom_capability & 0x20 != 0:
+                        self.calibration = 1
+                    elif sfp_dom_capability & 0x10 != 0:
+                        self.calibration = 2
+                    else:
+                        self.calibration = 0
+                else:
+                    self.dom_temp_supported = False
+                    self.dom_volt_supported = False
+                    self.dom_rx_power_supported = False
+                    self.dom_tx_power_supported = False
+                    self.calibration = 0
+                self.dom_tx_disable_supported = (
+                    int(sfp_dom_capability_raw[1], 16) & 0x40 != 0)
+        else:
+            self.dom_supported = False
+            self.dom_temp_supported = False
+            self.dom_volt_supported = False
+            self.dom_rx_power_supported = False
+            self.dom_tx_power_supported = False
+
+    def get_transceiver_info(self):
+        """
+        Retrieves transceiver info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        type                       |1*255VCHAR     |type of SFP
+        hardware_rev               |1*255VCHAR     |hardware version of SFP
+        serial                     |1*255VCHAR     |serial number of the SFP
+        manufacturer               |1*255VCHAR     |SFP vendor name
+        model                      |1*255VCHAR     |SFP model name
+        connector                  |1*255VCHAR     |connector information
+        encoding                   |1*255VCHAR     |encoding information
+        ext_identifier             |1*255VCHAR     |extend identifier
+        ext_rateselect_compliance  |1*255VCHAR     |extended rateSelect compliance
+        cable_length               |INT            |cable length in m
+        nominal_bit_rate           |INT            |nominal bit rate by 100Mbs
+        specification_compliance   |1*255VCHAR     |specification compliance
+        type_abbrv_name            |1*255VCHAR     |type of SFP (abbreviated)
+        vendor_date                |1*255VCHAR     |vendor date
+        vendor_oui                 |1*255VCHAR     |vendor OUI
+        application_advertisement  |1*255VCHAR     |supported applications advertisement
+        ========================================================================
+         """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        compliance_code_dict = {}
+        transceiver_info_dict = dict.fromkeys(self.info_dict_keys, 'N/A')
+
+        if not self.get_presence():
+            return transceiver_info_dict
+
+        if self.sfp_type == SFP_TYPE:
+            offset = 0
+            vendor_rev_width = XCVR_HW_REV_WIDTH_SFP
+            interface_info_bulk_width = XCVR_INTFACE_BULK_WIDTH_SFP
+
+            sfpi_obj = sff8472InterfaceId()
+            if sfpi_obj is None:
+                print("Error: sfp_object open failed")
+                return None
+
+            sfp_interface_bulk_raw = self.__read_eeprom_specific_bytes(
+                offset + XCVR_INTERFACE_DATA_START, XCVR_INTERFACE_DATA_SIZE)
+            if sfp_interface_bulk_raw is None:
+                return None
+
+            start = XCVR_INTFACE_BULK_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + interface_info_bulk_width
+            sfp_interface_bulk_data = sfpi_obj.parse_sfp_info_bulk(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_NAME_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_NAME_WIDTH
+            sfp_vendor_name_data = sfpi_obj.parse_vendor_name(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_PN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_PN_WIDTH
+            sfp_vendor_pn_data = sfpi_obj.parse_vendor_pn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_HW_REV_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + vendor_rev_width
+            sfp_vendor_rev_data = sfpi_obj.parse_vendor_rev(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_SN_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_SN_WIDTH
+            sfp_vendor_sn_data = sfpi_obj.parse_vendor_sn(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_OUI_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_OUI_WIDTH
+            sfp_vendor_oui_data = sfpi_obj.parse_vendor_oui(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            start = XCVR_VENDOR_DATE_OFFSET - XCVR_INTERFACE_DATA_START
+            end = start + XCVR_VENDOR_DATE_WIDTH
+            sfp_vendor_date_data = sfpi_obj.parse_vendor_date(
+                sfp_interface_bulk_raw[start: end], 0)
+
+            transceiver_info_dict['type'] = sfp_interface_bulk_data \
+                ['data']['type']['value']
+            transceiver_info_dict['manufacturer'] = sfp_vendor_name_data \
+                ['data']['Vendor Name']['value']
+            transceiver_info_dict['model'] = sfp_vendor_pn_data \
+                ['data']['Vendor PN']['value']
+            transceiver_info_dict['hardware_rev'] = sfp_vendor_rev_data \
+                ['data']['Vendor Rev']['value']
+            transceiver_info_dict['serial'] = sfp_vendor_sn_data \
+                ['data']['Vendor SN']['value']
+            transceiver_info_dict['vendor_oui'] = sfp_vendor_oui_data \
+                ['data']['Vendor OUI']['value']
+            transceiver_info_dict['vendor_date'] = sfp_vendor_date_data \
+                ['data']['VendorDataCode(YYYY-MM-DD Lot)']['value']
+            transceiver_info_dict['connector'] = sfp_interface_bulk_data \
+                ['data']['Connector']['value']
+            transceiver_info_dict['encoding'] = sfp_interface_bulk_data \
+                ['data']['EncodingCodes']['value']
+            transceiver_info_dict['ext_identifier'] = sfp_interface_bulk_data \
+                ['data']['Extended Identifier']['value']
+            transceiver_info_dict['ext_rateselect_compliance'] = sfp_interface_bulk_data \
+                ['data']['RateIdentifier']['value']
+            transceiver_info_dict['type_abbrv_name'] = sfp_interface_bulk_data \
+                ['data']['type_abbrv_name']['value']
+
+            for key in sfp_cable_length_tup:
+                if key in sfp_interface_bulk_data['data']:
+                    transceiver_info_dict['cable_type'] = key
+                    transceiver_info_dict['cable_length'] = \
+                        str(sfp_interface_bulk_data['data'][key]['value'])
+
+            for key in sfp_compliance_code_tup:
+                if key in sfp_interface_bulk_data['data']['Specification compliance']['value']:
+                    compliance_code_dict[key] = sfp_interface_bulk_data \
+                        ['data']['Specification compliance']['value'][key]['value']
+
+            transceiver_info_dict['specification_compliance'] = \
+                str(compliance_code_dict)
+            transceiver_info_dict['nominal_bit_rate'] = \
+                str(sfp_interface_bulk_data['data']['NominalSignallingRate(UnitsOf100Mbd)']['value'])
+            transceiver_info_dict['application_advertisement'] = 'N/A'
+
+        return transceiver_info_dict
+
+    def get_transceiver_bulk_status(self):
+        """
+        Retrieves transceiver bulk status of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        rx_los                     |BOOLEAN        |RX loss-of-signal status, True if has RX los, False if not.
+        tx_fault                   |BOOLEAN        |TX fault status, True if has TX fault, False if not.
+        reset_status               |BOOLEAN        |reset status, True if SFP in reset, False if not.
+        lp_mode                    |BOOLEAN        |low power mode status, True in lp mode, False if not.
+        tx_disable                 |BOOLEAN        |TX disable status, True TX disabled, False if not.
+        tx_disabled_channel        |HEX            |disabled TX channels in hex, bits 0 to 3 represent channel 0
+                                   |               |to channel 3.
+        temperature                |INT            |module temperature in Celsius
+        voltage                    |INT            |supply voltage in mV
+        tx<n>bias                  |INT            |TX Bias Current in mA, n is the channel number,
+                                   |               |for example, tx2bias stands for tx bias of channel 2.
+        rx<n>power                 |INT            |received optical power in mW, n is the channel number,
+                                   |               |for example, rx2power stands for rx power of channel 2.
+        tx<n>power                 |INT            |TX output power in mW, n is the channel number,
+                                   |               |for example, tx2power stands for tx power of channel 2.
+        ========================================================================
+        """
+
+        transceiver_dom_info_dict = dict.fromkeys(self.dom_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_info_dict
+
+        if self.sfp_type == SFP_TYPE:
+
+            self._dom_capability_detect()
+            if not self.dom_supported:
+                return transceiver_dom_info_dict
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return transceiver_dom_info_dict
+            sfpd_obj._calibration_type = self.calibration
+
+            dom_data_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_DOM_BULK_DATA_START), SFP_DOM_BULK_DATA_SIZE)
+
+            start = SFP_TEMPE_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_TEMPE_WIDTH
+            dom_temperature_data = sfpd_obj.parse_temperature(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_VOLT_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_VOLT_WIDTH
+            dom_voltage_data = sfpd_obj.parse_voltage(
+                dom_data_raw[start: end], 0)
+
+            start = SFP_CHANNL_MON_OFFSET - SFP_DOM_BULK_DATA_START
+            end = start + SFP_CHANNL_MON_WIDTH
+            dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                dom_data_raw[start: end], 0)
+
+            transceiver_dom_info_dict['temperature'] = self.__convert_string_to_num(
+                dom_temperature_data['data']['Temperature']['value'])
+            transceiver_dom_info_dict['voltage'] = self.__convert_string_to_num(
+                dom_voltage_data['data']['Vcc']['value'])
+            transceiver_dom_info_dict['rx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['RXPower']['value'])
+            transceiver_dom_info_dict['tx1bias'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXBias']['value'])
+            transceiver_dom_info_dict['tx1power'] = self.__convert_string_to_num(
+                dom_channel_monitor_data['data']['TXPower']['value'])
+
+        transceiver_dom_info_dict['rx_los'] = self.get_rx_los()
+        transceiver_dom_info_dict['tx_fault'] = self.get_tx_fault()
+        transceiver_dom_info_dict['reset_status'] = self.get_reset_status()
+        transceiver_dom_info_dict['lp_mode'] = self.get_lpmode()
+
+        return transceiver_dom_info_dict
+
+    def get_transceiver_threshold_info(self):
+        """
+        Retrieves transceiver threshold info of this SFP
+        Returns:
+            A dict which contains following keys/values :
+        ========================================================================
+        keys                       |Value Format   |Information
+        ---------------------------|---------------|----------------------------
+        temphighalarm              |FLOAT          |High Alarm Threshold value of temperature in Celsius.
+        templowalarm               |FLOAT          |Low Alarm Threshold value of temperature in Celsius.
+        temphighwarning            |FLOAT          |High Warning Threshold value of temperature in Celsius.
+        templowwarning             |FLOAT          |Low Warning Threshold value of temperature in Celsius.
+        vcchighalarm               |FLOAT          |High Alarm Threshold value of supply voltage in mV.
+        vcclowalarm                |FLOAT          |Low Alarm Threshold value of supply voltage in mV.
+        vcchighwarning             |FLOAT          |High Warning Threshold value of supply voltage in mV.
+        vcclowwarning              |FLOAT          |Low Warning Threshold value of supply voltage in mV.
+        rxpowerhighalarm           |FLOAT          |High Alarm Threshold value of received power in dBm.
+        rxpowerlowalarm            |FLOAT          |Low Alarm Threshold value of received power in dBm.
+        rxpowerhighwarning         |FLOAT          |High Warning Threshold value of received power in dBm.
+        rxpowerlowwarning          |FLOAT          |Low Warning Threshold value of received power in dBm.
+        txpowerhighalarm           |FLOAT          |High Alarm Threshold value of transmit power in dBm.
+        txpowerlowalarm            |FLOAT          |Low Alarm Threshold value of transmit power in dBm.
+        txpowerhighwarning         |FLOAT          |High Warning Threshold value of transmit power in dBm.
+        txpowerlowwarning          |FLOAT          |Low Warning Threshold value of transmit power in dBm.
+        txbiashighalarm            |FLOAT          |High Alarm Threshold value of tx Bias Current in mA.
+        txbiaslowalarm             |FLOAT          |Low Alarm Threshold value of tx Bias Current in mA.
+        txbiashighwarning          |FLOAT          |High Warning Threshold value of tx Bias Current in mA.
+        txbiaslowwarning           |FLOAT          |Low Warning Threshold value of tx Bias Current in mA.
+        ========================================================================
+        """
+        transceiver_dom_threshold_info_dict = dict.fromkeys(
+            self.threshold_dict_keys, 'N/A')
+
+        if self.sfp_type == COPPER_TYPE:
+            return transceiver_dom_threshold_info_dict
+
+        if self.sfp_type == SFP_TYPE:
+
+            offset = SFP_MODULE_ADDRA2_OFFSET
+
+            self._dom_capability_detect()
+            if not self.dom_supported:
+                return transceiver_dom_threshold_info_dict
+
+            sfpd_obj = sff8472Dom(None, self.calibration)
+            if sfpd_obj is None:
+                return transceiver_dom_threshold_info_dict
+
+            dom_module_threshold_raw = self.__read_eeprom_specific_bytes((offset + SFP_MODULE_THRESHOLD_OFFSET),
+                                                                         SFP_MODULE_THRESHOLD_WIDTH)
+            if dom_module_threshold_raw is not None:
+                dom_module_threshold_data = sfpd_obj.parse_alarm_warning_threshold(
+                    dom_module_threshold_raw, 0)
+            else:
+                return transceiver_dom_threshold_info_dict
+
+            # Threshold Data
+            transceiver_dom_threshold_info_dict['temphighalarm'] = dom_module_threshold_data['data']['TempHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['templowalarm'] = dom_module_threshold_data['data']['TempLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['temphighwarning'] = dom_module_threshold_data['data']['TempHighWarning']['value']
+            transceiver_dom_threshold_info_dict['templowwarning'] = dom_module_threshold_data['data']['TempLowWarning']['value']
+            transceiver_dom_threshold_info_dict['vcchighalarm'] = dom_module_threshold_data['data']['VoltageHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcclowalarm'] = dom_module_threshold_data['data']['VoltageLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['vcchighwarning'] = dom_module_threshold_data[
+                'data']['VoltageHighWarning']['value']
+            transceiver_dom_threshold_info_dict['vcclowwarning'] = dom_module_threshold_data['data']['VoltageLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiashighalarm'] = dom_module_threshold_data['data']['BiasHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowalarm'] = dom_module_threshold_data['data']['BiasLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txbiashighwarning'] = dom_module_threshold_data['data']['BiasHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txbiaslowwarning'] = dom_module_threshold_data['data']['BiasLowWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighalarm'] = dom_module_threshold_data['data']['TXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowalarm'] = dom_module_threshold_data['data']['TXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['txpowerhighwarning'] = dom_module_threshold_data['data']['TXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['txpowerlowwarning'] = dom_module_threshold_data['data']['TXPowerLowWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighalarm'] = dom_module_threshold_data['data']['RXPowerHighAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowalarm'] = dom_module_threshold_data['data']['RXPowerLowAlarm']['value']
+            transceiver_dom_threshold_info_dict['rxpowerhighwarning'] = dom_module_threshold_data['data']['RXPowerHighWarning']['value']
+            transceiver_dom_threshold_info_dict['rxpowerlowwarning'] = dom_module_threshold_data['data']['RXPowerLowWarning']['value']
+
+        return transceiver_dom_threshold_info_dict
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        self._dom_capability_detect()
+        if not self.dom_supported:
+            return False
+        if self.sfp_type == COPPER_TYPE:
+            return False
+
+        if self.sfp_type == SFP_TYPE:
+            offset = 0
+
+            dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                (offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+
+            if dom_channel_monitor_raw is not None:
+                return False
+            else:
+                return True
+
+    def get_rx_los(self):
+        """
+        Retrieves the RX LOS (lost-of-signal) status of SFP
+        Returns:
+            A Boolean, True if SFP has RX LOS, False if not.
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return None
+        if not self.dom_supported:
+            return None
+        rx_los_list = []
+
+        offset = 256
+        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes((offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+        if dom_channel_monitor_raw is not None:
+            rx_los_data = int(dom_channel_monitor_raw[0], 16)
+            rx_los_list.append(rx_los_data & 0x02 != 0)
+        else:
+            return None
+
+        return rx_los_list
+
+    def get_tx_fault(self):
+        """
+        Retrieves the TX fault status of SFP
+        Returns:
+            A Boolean, True if SFP has TX fault, False if not
+            Note : TX fault status is lached until a call to get_tx_fault or a reset.
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return None
+        if not self.dom_supported:
+            return None
+        tx_fault_list = []
+
+        offset = 256
+        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes((offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+        if dom_channel_monitor_raw is not None:
+            tx_fault_data = int(dom_channel_monitor_raw[0], 16)
+            tx_fault_list.append(tx_fault_data & 0x04 != 0)
+        else:
+            return None
+        return tx_fault_list
+
+
+    def get_tx_disable(self):
+        """
+        Retrieves the tx_disable status of this SFP
+        Returns:
+            A Boolean, True if tx_disable is enabled, False if disabled
+        """
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+        if not self.dom_supported:
+            return None
+
+        tx_disable_list = []
+        offset = 256
+        dom_channel_monitor_raw = self.__read_eeprom_specific_bytes((offset + SFP_CHANNL_STATUS_OFFSET), SFP_CHANNL_STATUS_WIDTH)
+        if dom_channel_monitor_raw is not None:
+            tx_disable_data = int(dom_channel_monitor_raw[0], 16)
+            tx_disable_list.append(tx_disable_data & 0xC0 != 0)
+        else:
+            return None
+
+        return tx_disable_list
+
+    def get_tx_disable_channel(self):
+        """
+        Retrieves the TX disabled channels in this SFP
+        Returns:
+            A hex of 4 bits (bit 0 to bit 3 as channel 0 to channel 3) to represent
+            TX channels which have been disabled in this SFP.
+            As an example, a returned value of 0x5 indicates that channel 0
+            and channel 2 have been disabled.
+        """
+        tx_disable_list = self.get_tx_disable()
+        if tx_disable_list is None:
+            return 0
+        tx_disabled = 0
+        for i in range(len(tx_disable_list)):
+            if tx_disable_list[i]:
+                tx_disabled |= 1 << i
+        return tx_disabled
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_power_override(self):
+        """
+        Retrieves the power-override status of this SFP
+        Returns:
+            A Boolean, True if power-override is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_temperature(self):
+        """
+        Retrieves the temperature of this SFP
+        Returns:
+            An integer number of current temperature in Celsius
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("temperature", "N/A")
+
+    def get_voltage(self):
+        """
+        Retrieves the supply voltage of this SFP
+        Returns:
+            An integer number of supply voltage in mV
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        return transceiver_bulk_status.get("voltage", "N/A")
+
+    def get_tx_bias(self):
+        """
+        Retrieves the TX bias current of this SFP
+        Returns:
+
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        tx_bias_list = []
+        transceiver_bulk_status = self.get_transceiver_bulk_status()
+        tx_bias_list.append(transceiver_bulk_status.get("tx1bias", "N/A"))
+
+        return tx_bias_list
+
+
+    def get_rx_power(self):
+        """
+        Retrieves the received optical power for this SFP
+        Returns:
+            A list of four integer numbers, representing received optical
+            power in mW for channel 0 to channel 4.
+            Ex. ['1.77', '1.71', '1.68', '1.70']
+        """
+        rx_power_list = []
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == SFP_TYPE:
+
+            offset = 256
+
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            self._dom_capability_detect()
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    rx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['RXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+
+        return rx_power_list
+
+    def get_tx_power(self):
+        """
+        Retrieves the TX power of this SFP
+        Returns:
+            A list of four integer numbers, representing TX power in mW
+            for channel 0 to channel 4.
+            Ex. ['1.86', '1.86', '1.86', '1.86']
+        """
+        tx_power_list = []
+
+        if self.sfp_type == COPPER_TYPE:
+            return None
+
+        if self.sfp_type == SFP_TYPE:
+
+            offset = 256
+            sfpd_obj = sff8472Dom()
+            if sfpd_obj is None:
+                return None
+
+            self._dom_capability_detect()
+            if self.dom_supported:
+                sfpd_obj._calibration_type = self.calibration
+
+                dom_channel_monitor_raw = self.__read_eeprom_specific_bytes(
+                    (offset + SFP_CHANNL_MON_OFFSET), SFP_CHANNL_MON_WIDTH)
+                if dom_channel_monitor_raw is not None:
+                    dom_channel_monitor_data = sfpd_obj.parse_channel_monitor_params(
+                        dom_channel_monitor_raw, 0)
+                    tx_power_list.append(self.__convert_string_to_num(
+                        dom_channel_monitor_data['data']['TXPower']['value']))
+                else:
+                    return None
+            else:
+                return None
+        return tx_power_list
+
+    def reset(self):
+        """
+        Reset SFP.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        # RJ45 and SFP ports not resettable
+        return False
+
+    def tx_disable(self, tx_disable):
+        """
+        Disable SFP TX
+        Args:
+            tx_disable : A Boolean, True to enable tx_disable mode, False to disable
+                         tx_disable mode.
+        Returns:
+            A boolean, True if tx_disable is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+
+        if smbus_present == 0:  # if called from sfputil outside of pmon
+            cmdstatus, register = cmd.getstatusoutput('sudo i2cget -y 0 0x76 0x8')
+            if cmdstatus:
+                sonic_logger.log_warning("sfp cmdstatus i2c get failed %s" % register )
+                return False
+            register = int(register, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x76
+            DEVICE_REG = 0x8
+            register = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        pos = [1, 2, 4, 8, 16, 32]
+        mask = pos[self.index-SFP_PORT_START]
+        if tx_disable == True:
+            setbits = register | mask
+        else:
+            setbits = register & ~mask
+
+        if smbus_present == 0:  # if called from sfputil outside of pmon
+            cmdstatus, output = cmd.getstatusoutput('sudo i2cset -y -m 0x0f 0 0x76 0x8 %d' % setbits)
+            if cmdstatus:
+                sonic_logger.log_warning("sfp cmdstatus i2c write failed %s" % output )
+                return False
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x76
+            DEVICE_REG = 0x8
+            bus.write_byte_data(DEVICE_ADDRESS, DEVICE_REG, setbits)
+
+        return True
+
+    def tx_disable_channel(self, channel, disable):
+        """
+        Sets the tx_disable for specified SFP channels
+        Args:
+            channel : A hex of 4 bits (bit 0 to bit 3) which represent channel 0 to 3,
+                      e.g. 0x5 for channel 0 and channel 2.
+            disable : A boolean, True to disable TX channels specified in channel,
+                      False to enable
+        Returns:
+            A boolean, True if successful, False if not
+        """
+
+        return NotImplementedError
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def set_power_override(self, power_override, power_set):
+        """
+        Sets SFP power level using power_override and power_set
+        Args:
+            power_override :
+                    A Boolean, True to override set_lpmode and use power_set
+                    to control SFP power, False to disable SFP power control
+                    through power_override/power_set and use set_lpmode
+                    to control SFP power.
+            power_set :
+                    Only valid when power_override is True.
+                    A Boolean, True to set SFP to low power mode, False to set
+                    SFP to high power mode.
+        Returns:
+            A boolean, True if power-override and power_set are set successfully,
+            False if not
+        """
+
+        return NotImplementedError
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        sfputil_helper = SfpUtilHelper()
+        sfputil_helper.read_porttab_mappings(
+            self.__get_path_to_port_config_file())
+        name = sfputil_helper.logical[self.index-1] or "Unknown"
+        return name
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+
+        if smbus_present == 0:  # if called from sfputil outside of pmon
+            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x76 0xa')
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x76
+            DEVICE_REG = 0xa
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        pos = [1, 2, 4, 8, 16, 32]
+        bit_pos = pos[self.index-SFP_PORT_START]
+        sfpstatus = sfpstatus & (bit_pos)
+
+        if sfpstatus == 0:
+            return True
+
+        return False
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the device
+        Returns:
+            string: Model/part number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("model", "N/A")
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the device
+        Returns:
+            string: Serial number of device
+        """
+        transceiver_dom_info_dict = self.get_transceiver_info()
+        return transceiver_dom_info_dict.get("serial", "N/A")
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        Returns:
+            A boolean value, True if device is operating properly, False if not
+        """
+        return self.get_presence()
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+
+        if self.sfp_type == "SFP":
+            return True
+        else:
+            return False
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device
+        Returns:
+            integer: The 1-based relative physical position in parent device
+        """
+        return self.index
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp_event.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..45afd59fc
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/sfp_event.py
@@ -0,0 +1,117 @@
+'''
+listen for the SFP change event and return to chassis.
+'''
+import sys
+import time
+from sonic_py_common import logger
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 52
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    def __init__(self):
+        self.handle = None
+
+    def initialize(self):
+        self.modprs_register = 0
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+            cmdstatus, sfpstatus = cmd.getstatusoutput('sudo i2cget -y 0 0x76 0xa')
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x76
+            DEVICE_REG = 0xa
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+            sfpstatus = ~sfpstatus
+            sfpstatus = sfpstatus & 0xF
+
+        return sfpstatus
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+        check_sfp_status called from get_change_event, this will return correct
+            status of all 4 SFP ports if there is a change in any of them
+        """
+        start_time = time.time()
+        port = SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000)  # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {}  # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
+                    # Mask off the bit corresponding to our port
+                    mask = (1 << port-SFP_PORT_START)
+                    if (changed_ports & mask):
+                        # ModPrsL is active high
+                        if reg_value & mask == 0:
+                            port_change[port] = '0'
+                        else:
+                            port_change[port] = '1'
+                    port += 1
+
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1)  # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
+        return False, {}
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/watchdog.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/watchdog.py
new file mode 100644
index 000000000..2726d19d4
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/sonic_platform/watchdog.py
@@ -0,0 +1,184 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_READ_WRITE = 0xC0000000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_SETTIMEOUT = 6 | WDWR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+WDIOC_GETTIMELEFT = 10 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _settimeout(self, seconds):
+        """
+        Set watchdog timer timeout
+        @param seconds - timeout in seconds
+        @return is the actual set timeout
+        """
+
+        req = array.array('I', [seconds])
+        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeleft(self):
+        """
+        Get time left before watchdog timer expires
+        @return time left in seconds
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
+
+        return int(req[0])
+
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
+
+    def is_armed(self):
+        """
+        Implements is_armed WatchdogBase API
+        """
+
+        return self.armed
+
+    def get_remaining_time(self):
+        """
+        Implements get_remaining_time WatchdogBase API
+        """
+
+        timeleft = WD_COMMON_ERROR
+
+        if self.armed:
+            try:
+                timeleft = self._gettimeleft()
+            except IOError:
+                pass
+
+        return timeleft
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/utils/get-base-mac.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx/rd98dx35xx/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell-arm64/sonic_fit.its b/platform/marvell-arm64/sonic_fit.its
index 9b09d4cd3..5112b895a 100644
--- a/platform/marvell-arm64/sonic_fit.its
+++ b/platform/marvell-arm64/sonic_fit.its
@@ -5,9 +5,9 @@
     #address-cells = <1>;
   
     images {
-        kernel@0 {
+        kernel_falcon {
             description = "Linux Kernel";
-            data = /incbin/("/boot/vmlinuz-4.9.0-9-2-arm64");
+            data = /incbin/("/boot/vmlinuz-5.10.0-18-2-arm64");
             type = "kernel";
             arch = "arm64";
             os = "linux";
@@ -18,7 +18,7 @@
                 algo = "sha1";
             };
         };
-        fdt@0 {
+        fdt_falcon {
             description = "Flattened Device Tree blob";
             data = /incbin/("/boot/armada-7020-comexpress.dtb");
             type = "flat_dt";
@@ -28,9 +28,9 @@
                 algo = "sha1";
             };
         };
-        ramdisk@0 {
+        ramdisk_falcon {
             description = "ramdisk";
-            data = /incbin/("/boot/initrd.img-4.9.0-9-2-arm64");
+            data = /incbin/("/boot/initrd.img-5.10.0-18-2-arm64");
             type = "ramdisk";
             arch = "arm64";
             os = "linux";
@@ -39,14 +39,60 @@
                 algo = "sha1";
             };
         };
+        kernel_ac5x {
+            description = "Linux Kernel for AC5x";
+            data = /incbin/("/boot/vmlinuz-5.10.0-18-2-arm64");
+            type = "kernel";
+            arch = "arm64";
+            os = "linux";
+            compression = "none";
+            load = <0x2 0x2080000>;
+            entry = <0x2 0x2080000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        fdt_ac5x {
+            description = "Flattened Device Tree blob for AC5x";
+            data = /incbin/("/boot/ac5x.dtb");
+            type = "flat_dt";
+            arch = "arm64";
+            compression = "none";
+            load = <0x2 0x1000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        ramdisk_ac5x {
+            description = "ramdisk for AC5x";
+            data = /incbin/("/boot/initrd.img-5.10.0-18-2-arm64");
+            type = "ramdisk";
+            arch = "arm64";
+            os = "linux";
+            compression = "gzip";
+            load = <0x2 0x6000000>;
+            entry = <0x2 0x6000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
     };
     configurations {
         default = "conf@1";
         conf@1 {
             description = "Boot Linux kernel with FDT blob + ramdisk";
-            kernel = "kernel@0";
-            fdt = "fdt@0";
-            ramdisk = "ramdisk@0";
+            kernel = "kernel_falcon";
+            fdt = "fdt_falcon";
+            ramdisk = "ramdisk_falcon";
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        conf_ac5x {
+            description = "Boot Linux kernel with FDT blob + ramdisk for RD_AC5x";
+            kernel = "kernel_ac5x";
+            fdt = "fdt_ac5x";
+            ramdisk = "ramdisk_ac5x";
             hash@1 {
                 algo = "sha1";
             };
